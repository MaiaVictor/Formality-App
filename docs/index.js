/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../formality/node_modules/decode-uri-component/index.js":
/*!***************************************************************!*\
  !*** ../formality/node_modules/decode-uri-component/index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar token = '%[a-f0-9]{2}';\nvar singleMatcher = new RegExp(token, 'gi');\nvar multiMatcher = new RegExp('(' + token + ')+', 'gi');\n\nfunction decodeComponents(components, split) {\n\ttry {\n\t\t// Try to decode the entire string first\n\t\treturn decodeURIComponent(components.join(''));\n\t} catch (err) {\n\t\t// Do nothing\n\t}\n\n\tif (components.length === 1) {\n\t\treturn components;\n\t}\n\n\tsplit = split || 1;\n\n\t// Split the array in 2 parts\n\tvar left = components.slice(0, split);\n\tvar right = components.slice(split);\n\n\treturn Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));\n}\n\nfunction decode(input) {\n\ttry {\n\t\treturn decodeURIComponent(input);\n\t} catch (err) {\n\t\tvar tokens = input.match(singleMatcher);\n\n\t\tfor (var i = 1; i < tokens.length; i++) {\n\t\t\tinput = decodeComponents(tokens, i).join('');\n\n\t\t\ttokens = input.match(singleMatcher);\n\t\t}\n\n\t\treturn input;\n\t}\n}\n\nfunction customDecodeURIComponent(input) {\n\t// Keep track of all the replacements and prefill the map with the `BOM`\n\tvar replaceMap = {\n\t\t'%FE%FF': '\\uFFFD\\uFFFD',\n\t\t'%FF%FE': '\\uFFFD\\uFFFD'\n\t};\n\n\tvar match = multiMatcher.exec(input);\n\twhile (match) {\n\t\ttry {\n\t\t\t// Decode as big chunks as possible\n\t\t\treplaceMap[match[0]] = decodeURIComponent(match[0]);\n\t\t} catch (err) {\n\t\t\tvar result = decode(match[0]);\n\n\t\t\tif (result !== match[0]) {\n\t\t\t\treplaceMap[match[0]] = result;\n\t\t\t}\n\t\t}\n\n\t\tmatch = multiMatcher.exec(input);\n\t}\n\n\t// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else\n\treplaceMap['%C2'] = '\\uFFFD';\n\n\tvar entries = Object.keys(replaceMap);\n\n\tfor (var i = 0; i < entries.length; i++) {\n\t\t// Replace all decoded components\n\t\tvar key = entries[i];\n\t\tinput = input.replace(new RegExp(key, 'g'), replaceMap[key]);\n\t}\n\n\treturn input;\n}\n\nmodule.exports = function (encodedURI) {\n\tif (typeof encodedURI !== 'string') {\n\t\tthrow new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');\n\t}\n\n\ttry {\n\t\tencodedURI = encodedURI.replace(/\\+/g, ' ');\n\n\t\t// Try the built in decoder first\n\t\treturn decodeURIComponent(encodedURI);\n\t} catch (err) {\n\t\t// Fallback to a more advanced decoder\n\t\treturn customDecodeURIComponent(encodedURI);\n\t}\n};\n\n\n//# sourceURL=webpack:///../formality/node_modules/decode-uri-component/index.js?");

/***/ }),

/***/ "../formality/node_modules/define-properties/index.js":
/*!************************************************************!*\
  !*** ../formality/node_modules/define-properties/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar keys = __webpack_require__(/*! object-keys */ \"../formality/node_modules/object-keys/index.js\");\nvar hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';\n\nvar toStr = Object.prototype.toString;\nvar concat = Array.prototype.concat;\nvar origDefineProperty = Object.defineProperty;\n\nvar isFunction = function (fn) {\n\treturn typeof fn === 'function' && toStr.call(fn) === '[object Function]';\n};\n\nvar arePropertyDescriptorsSupported = function () {\n\tvar obj = {};\n\ttry {\n\t\torigDefineProperty(obj, 'x', { enumerable: false, value: obj });\n\t\t// eslint-disable-next-line no-unused-vars, no-restricted-syntax\n\t\tfor (var _ in obj) { // jscs:ignore disallowUnusedVariables\n\t\t\treturn false;\n\t\t}\n\t\treturn obj.x === obj;\n\t} catch (e) { /* this is IE 8. */\n\t\treturn false;\n\t}\n};\nvar supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();\n\nvar defineProperty = function (object, name, value, predicate) {\n\tif (name in object && (!isFunction(predicate) || !predicate())) {\n\t\treturn;\n\t}\n\tif (supportsDescriptors) {\n\t\torigDefineProperty(object, name, {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tvalue: value,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\tobject[name] = value;\n\t}\n};\n\nvar defineProperties = function (object, map) {\n\tvar predicates = arguments.length > 2 ? arguments[2] : {};\n\tvar props = keys(map);\n\tif (hasSymbols) {\n\t\tprops = concat.call(props, Object.getOwnPropertySymbols(map));\n\t}\n\tfor (var i = 0; i < props.length; i += 1) {\n\t\tdefineProperty(object, props[i], map[props[i]], predicates[props[i]]);\n\t}\n};\n\ndefineProperties.supportsDescriptors = !!supportsDescriptors;\n\nmodule.exports = defineProperties;\n\n\n//# sourceURL=webpack:///../formality/node_modules/define-properties/index.js?");

/***/ }),

/***/ "../formality/node_modules/es-abstract/GetIntrinsic.js":
/*!*************************************************************!*\
  !*** ../formality/node_modules/es-abstract/GetIntrinsic.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/* globals\n\tSet,\n\tMap,\n\tWeakSet,\n\tWeakMap,\n\n\tPromise,\n\n\tSymbol,\n\tProxy,\n\n\tAtomics,\n\tSharedArrayBuffer,\n\n\tArrayBuffer,\n\tDataView,\n\tUint8Array,\n\tFloat32Array,\n\tFloat64Array,\n\tInt8Array,\n\tInt16Array,\n\tInt32Array,\n\tUint8ClampedArray,\n\tUint16Array,\n\tUint32Array,\n*/\n\nvar undefined; // eslint-disable-line no-shadow-restricted-names\n\nvar ThrowTypeError = Object.getOwnPropertyDescriptor\n\t? (function () { return Object.getOwnPropertyDescriptor(arguments, 'callee').get; }())\n\t: function () { throw new TypeError(); };\n\nvar hasSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';\n\nvar getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto\n\nvar generator; // = function * () {};\nvar generatorFunction = generator ? getProto(generator) : undefined;\nvar asyncFn; // async function() {};\nvar asyncFunction = asyncFn ? asyncFn.constructor : undefined;\nvar asyncGen; // async function * () {};\nvar asyncGenFunction = asyncGen ? getProto(asyncGen) : undefined;\nvar asyncGenIterator = asyncGen ? asyncGen() : undefined;\n\nvar TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);\n\nvar INTRINSICS = {\n\t'$ %Array%': Array,\n\t'$ %ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,\n\t'$ %ArrayBufferPrototype%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer.prototype,\n\t'$ %ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,\n\t'$ %ArrayPrototype%': Array.prototype,\n\t'$ %ArrayProto_entries%': Array.prototype.entries,\n\t'$ %ArrayProto_forEach%': Array.prototype.forEach,\n\t'$ %ArrayProto_keys%': Array.prototype.keys,\n\t'$ %ArrayProto_values%': Array.prototype.values,\n\t'$ %AsyncFromSyncIteratorPrototype%': undefined,\n\t'$ %AsyncFunction%': asyncFunction,\n\t'$ %AsyncFunctionPrototype%': asyncFunction ? asyncFunction.prototype : undefined,\n\t'$ %AsyncGenerator%': asyncGen ? getProto(asyncGenIterator) : undefined,\n\t'$ %AsyncGeneratorFunction%': asyncGenFunction,\n\t'$ %AsyncGeneratorPrototype%': asyncGenFunction ? asyncGenFunction.prototype : undefined,\n\t'$ %AsyncIteratorPrototype%': asyncGenIterator && hasSymbols && Symbol.asyncIterator ? asyncGenIterator[Symbol.asyncIterator]() : undefined,\n\t'$ %Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,\n\t'$ %Boolean%': Boolean,\n\t'$ %BooleanPrototype%': Boolean.prototype,\n\t'$ %DataView%': typeof DataView === 'undefined' ? undefined : DataView,\n\t'$ %DataViewPrototype%': typeof DataView === 'undefined' ? undefined : DataView.prototype,\n\t'$ %Date%': Date,\n\t'$ %DatePrototype%': Date.prototype,\n\t'$ %decodeURI%': decodeURI,\n\t'$ %decodeURIComponent%': decodeURIComponent,\n\t'$ %encodeURI%': encodeURI,\n\t'$ %encodeURIComponent%': encodeURIComponent,\n\t'$ %Error%': Error,\n\t'$ %ErrorPrototype%': Error.prototype,\n\t'$ %eval%': eval, // eslint-disable-line no-eval\n\t'$ %EvalError%': EvalError,\n\t'$ %EvalErrorPrototype%': EvalError.prototype,\n\t'$ %Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,\n\t'$ %Float32ArrayPrototype%': typeof Float32Array === 'undefined' ? undefined : Float32Array.prototype,\n\t'$ %Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,\n\t'$ %Float64ArrayPrototype%': typeof Float64Array === 'undefined' ? undefined : Float64Array.prototype,\n\t'$ %Function%': Function,\n\t'$ %FunctionPrototype%': Function.prototype,\n\t'$ %Generator%': generator ? getProto(generator()) : undefined,\n\t'$ %GeneratorFunction%': generatorFunction,\n\t'$ %GeneratorPrototype%': generatorFunction ? generatorFunction.prototype : undefined,\n\t'$ %Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,\n\t'$ %Int8ArrayPrototype%': typeof Int8Array === 'undefined' ? undefined : Int8Array.prototype,\n\t'$ %Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,\n\t'$ %Int16ArrayPrototype%': typeof Int16Array === 'undefined' ? undefined : Int8Array.prototype,\n\t'$ %Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,\n\t'$ %Int32ArrayPrototype%': typeof Int32Array === 'undefined' ? undefined : Int32Array.prototype,\n\t'$ %isFinite%': isFinite,\n\t'$ %isNaN%': isNaN,\n\t'$ %IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,\n\t'$ %JSON%': JSON,\n\t'$ %JSONParse%': JSON.parse,\n\t'$ %Map%': typeof Map === 'undefined' ? undefined : Map,\n\t'$ %MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),\n\t'$ %MapPrototype%': typeof Map === 'undefined' ? undefined : Map.prototype,\n\t'$ %Math%': Math,\n\t'$ %Number%': Number,\n\t'$ %NumberPrototype%': Number.prototype,\n\t'$ %Object%': Object,\n\t'$ %ObjectPrototype%': Object.prototype,\n\t'$ %ObjProto_toString%': Object.prototype.toString,\n\t'$ %ObjProto_valueOf%': Object.prototype.valueOf,\n\t'$ %parseFloat%': parseFloat,\n\t'$ %parseInt%': parseInt,\n\t'$ %Promise%': typeof Promise === 'undefined' ? undefined : Promise,\n\t'$ %PromisePrototype%': typeof Promise === 'undefined' ? undefined : Promise.prototype,\n\t'$ %PromiseProto_then%': typeof Promise === 'undefined' ? undefined : Promise.prototype.then,\n\t'$ %Promise_all%': typeof Promise === 'undefined' ? undefined : Promise.all,\n\t'$ %Promise_reject%': typeof Promise === 'undefined' ? undefined : Promise.reject,\n\t'$ %Promise_resolve%': typeof Promise === 'undefined' ? undefined : Promise.resolve,\n\t'$ %Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,\n\t'$ %RangeError%': RangeError,\n\t'$ %RangeErrorPrototype%': RangeError.prototype,\n\t'$ %ReferenceError%': ReferenceError,\n\t'$ %ReferenceErrorPrototype%': ReferenceError.prototype,\n\t'$ %Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,\n\t'$ %RegExp%': RegExp,\n\t'$ %RegExpPrototype%': RegExp.prototype,\n\t'$ %Set%': typeof Set === 'undefined' ? undefined : Set,\n\t'$ %SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),\n\t'$ %SetPrototype%': typeof Set === 'undefined' ? undefined : Set.prototype,\n\t'$ %SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,\n\t'$ %SharedArrayBufferPrototype%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer.prototype,\n\t'$ %String%': String,\n\t'$ %StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,\n\t'$ %StringPrototype%': String.prototype,\n\t'$ %Symbol%': hasSymbols ? Symbol : undefined,\n\t'$ %SymbolPrototype%': hasSymbols ? Symbol.prototype : undefined,\n\t'$ %SyntaxError%': SyntaxError,\n\t'$ %SyntaxErrorPrototype%': SyntaxError.prototype,\n\t'$ %ThrowTypeError%': ThrowTypeError,\n\t'$ %TypedArray%': TypedArray,\n\t'$ %TypedArrayPrototype%': TypedArray ? TypedArray.prototype : undefined,\n\t'$ %TypeError%': TypeError,\n\t'$ %TypeErrorPrototype%': TypeError.prototype,\n\t'$ %Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,\n\t'$ %Uint8ArrayPrototype%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array.prototype,\n\t'$ %Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,\n\t'$ %Uint8ClampedArrayPrototype%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray.prototype,\n\t'$ %Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,\n\t'$ %Uint16ArrayPrototype%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array.prototype,\n\t'$ %Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,\n\t'$ %Uint32ArrayPrototype%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array.prototype,\n\t'$ %URIError%': URIError,\n\t'$ %URIErrorPrototype%': URIError.prototype,\n\t'$ %WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,\n\t'$ %WeakMapPrototype%': typeof WeakMap === 'undefined' ? undefined : WeakMap.prototype,\n\t'$ %WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,\n\t'$ %WeakSetPrototype%': typeof WeakSet === 'undefined' ? undefined : WeakSet.prototype\n};\n\nmodule.exports = function GetIntrinsic(name, allowMissing) {\n\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\n\t\tthrow new TypeError('\"allowMissing\" argument must be a boolean');\n\t}\n\n\tvar key = '$ ' + name;\n\tif (!(key in INTRINSICS)) {\n\t\tthrow new SyntaxError('intrinsic ' + name + ' does not exist!');\n\t}\n\n\t// istanbul ignore if // hopefully this is impossible to test :-)\n\tif (typeof INTRINSICS[key] === 'undefined' && !allowMissing) {\n\t\tthrow new TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\n\t}\n\treturn INTRINSICS[key];\n};\n\n\n//# sourceURL=webpack:///../formality/node_modules/es-abstract/GetIntrinsic.js?");

/***/ }),

/***/ "../formality/node_modules/es-abstract/es5.js":
/*!****************************************************!*\
  !*** ../formality/node_modules/es-abstract/es5.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar GetIntrinsic = __webpack_require__(/*! ./GetIntrinsic */ \"../formality/node_modules/es-abstract/GetIntrinsic.js\");\n\nvar $Object = GetIntrinsic('%Object%');\nvar $TypeError = GetIntrinsic('%TypeError%');\nvar $String = GetIntrinsic('%String%');\n\nvar assertRecord = __webpack_require__(/*! ./helpers/assertRecord */ \"../formality/node_modules/es-abstract/helpers/assertRecord.js\");\nvar $isNaN = __webpack_require__(/*! ./helpers/isNaN */ \"../formality/node_modules/es-abstract/helpers/isNaN.js\");\nvar $isFinite = __webpack_require__(/*! ./helpers/isFinite */ \"../formality/node_modules/es-abstract/helpers/isFinite.js\");\n\nvar sign = __webpack_require__(/*! ./helpers/sign */ \"../formality/node_modules/es-abstract/helpers/sign.js\");\nvar mod = __webpack_require__(/*! ./helpers/mod */ \"../formality/node_modules/es-abstract/helpers/mod.js\");\n\nvar IsCallable = __webpack_require__(/*! is-callable */ \"../formality/node_modules/is-callable/index.js\");\nvar toPrimitive = __webpack_require__(/*! es-to-primitive/es5 */ \"../formality/node_modules/es-to-primitive/es5.js\");\n\nvar has = __webpack_require__(/*! has */ \"../formality/node_modules/has/src/index.js\");\n\n// https://es5.github.io/#x9\nvar ES5 = {\n\tToPrimitive: toPrimitive,\n\n\tToBoolean: function ToBoolean(value) {\n\t\treturn !!value;\n\t},\n\tToNumber: function ToNumber(value) {\n\t\treturn +value; // eslint-disable-line no-implicit-coercion\n\t},\n\tToInteger: function ToInteger(value) {\n\t\tvar number = this.ToNumber(value);\n\t\tif ($isNaN(number)) { return 0; }\n\t\tif (number === 0 || !$isFinite(number)) { return number; }\n\t\treturn sign(number) * Math.floor(Math.abs(number));\n\t},\n\tToInt32: function ToInt32(x) {\n\t\treturn this.ToNumber(x) >> 0;\n\t},\n\tToUint32: function ToUint32(x) {\n\t\treturn this.ToNumber(x) >>> 0;\n\t},\n\tToUint16: function ToUint16(value) {\n\t\tvar number = this.ToNumber(value);\n\t\tif ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }\n\t\tvar posInt = sign(number) * Math.floor(Math.abs(number));\n\t\treturn mod(posInt, 0x10000);\n\t},\n\tToString: function ToString(value) {\n\t\treturn $String(value);\n\t},\n\tToObject: function ToObject(value) {\n\t\tthis.CheckObjectCoercible(value);\n\t\treturn $Object(value);\n\t},\n\tCheckObjectCoercible: function CheckObjectCoercible(value, optMessage) {\n\t\t/* jshint eqnull:true */\n\t\tif (value == null) {\n\t\t\tthrow new $TypeError(optMessage || 'Cannot call method on ' + value);\n\t\t}\n\t\treturn value;\n\t},\n\tIsCallable: IsCallable,\n\tSameValue: function SameValue(x, y) {\n\t\tif (x === y) { // 0 === -0, but they are not identical.\n\t\t\tif (x === 0) { return 1 / x === 1 / y; }\n\t\t\treturn true;\n\t\t}\n\t\treturn $isNaN(x) && $isNaN(y);\n\t},\n\n\t// https://www.ecma-international.org/ecma-262/5.1/#sec-8\n\tType: function Type(x) {\n\t\tif (x === null) {\n\t\t\treturn 'Null';\n\t\t}\n\t\tif (typeof x === 'undefined') {\n\t\t\treturn 'Undefined';\n\t\t}\n\t\tif (typeof x === 'function' || typeof x === 'object') {\n\t\t\treturn 'Object';\n\t\t}\n\t\tif (typeof x === 'number') {\n\t\t\treturn 'Number';\n\t\t}\n\t\tif (typeof x === 'boolean') {\n\t\t\treturn 'Boolean';\n\t\t}\n\t\tif (typeof x === 'string') {\n\t\t\treturn 'String';\n\t\t}\n\t},\n\n\t// https://ecma-international.org/ecma-262/6.0/#sec-property-descriptor-specification-type\n\tIsPropertyDescriptor: function IsPropertyDescriptor(Desc) {\n\t\tif (this.Type(Desc) !== 'Object') {\n\t\t\treturn false;\n\t\t}\n\t\tvar allowed = {\n\t\t\t'[[Configurable]]': true,\n\t\t\t'[[Enumerable]]': true,\n\t\t\t'[[Get]]': true,\n\t\t\t'[[Set]]': true,\n\t\t\t'[[Value]]': true,\n\t\t\t'[[Writable]]': true\n\t\t};\n\n\t\tfor (var key in Desc) { // eslint-disable-line\n\t\t\tif (has(Desc, key) && !allowed[key]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tvar isData = has(Desc, '[[Value]]');\n\t\tvar IsAccessor = has(Desc, '[[Get]]') || has(Desc, '[[Set]]');\n\t\tif (isData && IsAccessor) {\n\t\t\tthrow new $TypeError('Property Descriptors may not be both accessor and data descriptors');\n\t\t}\n\t\treturn true;\n\t},\n\n\t// https://ecma-international.org/ecma-262/5.1/#sec-8.10.1\n\tIsAccessorDescriptor: function IsAccessorDescriptor(Desc) {\n\t\tif (typeof Desc === 'undefined') {\n\t\t\treturn false;\n\t\t}\n\n\t\tassertRecord(this, 'Property Descriptor', 'Desc', Desc);\n\n\t\tif (!has(Desc, '[[Get]]') && !has(Desc, '[[Set]]')) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t},\n\n\t// https://ecma-international.org/ecma-262/5.1/#sec-8.10.2\n\tIsDataDescriptor: function IsDataDescriptor(Desc) {\n\t\tif (typeof Desc === 'undefined') {\n\t\t\treturn false;\n\t\t}\n\n\t\tassertRecord(this, 'Property Descriptor', 'Desc', Desc);\n\n\t\tif (!has(Desc, '[[Value]]') && !has(Desc, '[[Writable]]')) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t},\n\n\t// https://ecma-international.org/ecma-262/5.1/#sec-8.10.3\n\tIsGenericDescriptor: function IsGenericDescriptor(Desc) {\n\t\tif (typeof Desc === 'undefined') {\n\t\t\treturn false;\n\t\t}\n\n\t\tassertRecord(this, 'Property Descriptor', 'Desc', Desc);\n\n\t\tif (!this.IsAccessorDescriptor(Desc) && !this.IsDataDescriptor(Desc)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t},\n\n\t// https://ecma-international.org/ecma-262/5.1/#sec-8.10.4\n\tFromPropertyDescriptor: function FromPropertyDescriptor(Desc) {\n\t\tif (typeof Desc === 'undefined') {\n\t\t\treturn Desc;\n\t\t}\n\n\t\tassertRecord(this, 'Property Descriptor', 'Desc', Desc);\n\n\t\tif (this.IsDataDescriptor(Desc)) {\n\t\t\treturn {\n\t\t\t\tvalue: Desc['[[Value]]'],\n\t\t\t\twritable: !!Desc['[[Writable]]'],\n\t\t\t\tenumerable: !!Desc['[[Enumerable]]'],\n\t\t\t\tconfigurable: !!Desc['[[Configurable]]']\n\t\t\t};\n\t\t} else if (this.IsAccessorDescriptor(Desc)) {\n\t\t\treturn {\n\t\t\t\tget: Desc['[[Get]]'],\n\t\t\t\tset: Desc['[[Set]]'],\n\t\t\t\tenumerable: !!Desc['[[Enumerable]]'],\n\t\t\t\tconfigurable: !!Desc['[[Configurable]]']\n\t\t\t};\n\t\t} else {\n\t\t\tthrow new $TypeError('FromPropertyDescriptor must be called with a fully populated Property Descriptor');\n\t\t}\n\t},\n\n\t// https://ecma-international.org/ecma-262/5.1/#sec-8.10.5\n\tToPropertyDescriptor: function ToPropertyDescriptor(Obj) {\n\t\tif (this.Type(Obj) !== 'Object') {\n\t\t\tthrow new $TypeError('ToPropertyDescriptor requires an object');\n\t\t}\n\n\t\tvar desc = {};\n\t\tif (has(Obj, 'enumerable')) {\n\t\t\tdesc['[[Enumerable]]'] = this.ToBoolean(Obj.enumerable);\n\t\t}\n\t\tif (has(Obj, 'configurable')) {\n\t\t\tdesc['[[Configurable]]'] = this.ToBoolean(Obj.configurable);\n\t\t}\n\t\tif (has(Obj, 'value')) {\n\t\t\tdesc['[[Value]]'] = Obj.value;\n\t\t}\n\t\tif (has(Obj, 'writable')) {\n\t\t\tdesc['[[Writable]]'] = this.ToBoolean(Obj.writable);\n\t\t}\n\t\tif (has(Obj, 'get')) {\n\t\t\tvar getter = Obj.get;\n\t\t\tif (typeof getter !== 'undefined' && !this.IsCallable(getter)) {\n\t\t\t\tthrow new TypeError('getter must be a function');\n\t\t\t}\n\t\t\tdesc['[[Get]]'] = getter;\n\t\t}\n\t\tif (has(Obj, 'set')) {\n\t\t\tvar setter = Obj.set;\n\t\t\tif (typeof setter !== 'undefined' && !this.IsCallable(setter)) {\n\t\t\t\tthrow new $TypeError('setter must be a function');\n\t\t\t}\n\t\t\tdesc['[[Set]]'] = setter;\n\t\t}\n\n\t\tif ((has(desc, '[[Get]]') || has(desc, '[[Set]]')) && (has(desc, '[[Value]]') || has(desc, '[[Writable]]'))) {\n\t\t\tthrow new $TypeError('Invalid property descriptor. Cannot both specify accessors and a value or writable attribute');\n\t\t}\n\t\treturn desc;\n\t}\n};\n\nmodule.exports = ES5;\n\n\n//# sourceURL=webpack:///../formality/node_modules/es-abstract/es5.js?");

/***/ }),

/***/ "../formality/node_modules/es-abstract/helpers/assertRecord.js":
/*!*********************************************************************!*\
  !*** ../formality/node_modules/es-abstract/helpers/assertRecord.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar GetIntrinsic = __webpack_require__(/*! ../GetIntrinsic */ \"../formality/node_modules/es-abstract/GetIntrinsic.js\");\n\nvar $TypeError = GetIntrinsic('%TypeError%');\nvar $SyntaxError = GetIntrinsic('%SyntaxError%');\n\nvar has = __webpack_require__(/*! has */ \"../formality/node_modules/has/src/index.js\");\n\nvar predicates = {\n  // https://ecma-international.org/ecma-262/6.0/#sec-property-descriptor-specification-type\n  'Property Descriptor': function isPropertyDescriptor(ES, Desc) {\n    if (ES.Type(Desc) !== 'Object') {\n      return false;\n    }\n    var allowed = {\n      '[[Configurable]]': true,\n      '[[Enumerable]]': true,\n      '[[Get]]': true,\n      '[[Set]]': true,\n      '[[Value]]': true,\n      '[[Writable]]': true\n    };\n\n    for (var key in Desc) { // eslint-disable-line\n      if (has(Desc, key) && !allowed[key]) {\n        return false;\n      }\n    }\n\n    var isData = has(Desc, '[[Value]]');\n    var IsAccessor = has(Desc, '[[Get]]') || has(Desc, '[[Set]]');\n    if (isData && IsAccessor) {\n      throw new $TypeError('Property Descriptors may not be both accessor and data descriptors');\n    }\n    return true;\n  }\n};\n\nmodule.exports = function assertRecord(ES, recordType, argumentName, value) {\n  var predicate = predicates[recordType];\n  if (typeof predicate !== 'function') {\n    throw new $SyntaxError('unknown record type: ' + recordType);\n  }\n  if (!predicate(ES, value)) {\n    throw new $TypeError(argumentName + ' must be a ' + recordType);\n  }\n  console.log(predicate(ES, value), value);\n};\n\n\n//# sourceURL=webpack:///../formality/node_modules/es-abstract/helpers/assertRecord.js?");

/***/ }),

/***/ "../formality/node_modules/es-abstract/helpers/isFinite.js":
/*!*****************************************************************!*\
  !*** ../formality/node_modules/es-abstract/helpers/isFinite.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var $isNaN = Number.isNaN || function (a) { return a !== a; };\n\nmodule.exports = Number.isFinite || function (x) { return typeof x === 'number' && !$isNaN(x) && x !== Infinity && x !== -Infinity; };\n\n\n//# sourceURL=webpack:///../formality/node_modules/es-abstract/helpers/isFinite.js?");

/***/ }),

/***/ "../formality/node_modules/es-abstract/helpers/isNaN.js":
/*!**************************************************************!*\
  !*** ../formality/node_modules/es-abstract/helpers/isNaN.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = Number.isNaN || function isNaN(a) {\n\treturn a !== a;\n};\n\n\n//# sourceURL=webpack:///../formality/node_modules/es-abstract/helpers/isNaN.js?");

/***/ }),

/***/ "../formality/node_modules/es-abstract/helpers/mod.js":
/*!************************************************************!*\
  !*** ../formality/node_modules/es-abstract/helpers/mod.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function mod(number, modulo) {\n\tvar remain = number % modulo;\n\treturn Math.floor(remain >= 0 ? remain : remain + modulo);\n};\n\n\n//# sourceURL=webpack:///../formality/node_modules/es-abstract/helpers/mod.js?");

/***/ }),

/***/ "../formality/node_modules/es-abstract/helpers/sign.js":
/*!*************************************************************!*\
  !*** ../formality/node_modules/es-abstract/helpers/sign.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function sign(number) {\n\treturn number >= 0 ? 1 : -1;\n};\n\n\n//# sourceURL=webpack:///../formality/node_modules/es-abstract/helpers/sign.js?");

/***/ }),

/***/ "../formality/node_modules/es-to-primitive/es5.js":
/*!********************************************************!*\
  !*** ../formality/node_modules/es-to-primitive/es5.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar toStr = Object.prototype.toString;\n\nvar isPrimitive = __webpack_require__(/*! ./helpers/isPrimitive */ \"../formality/node_modules/es-to-primitive/helpers/isPrimitive.js\");\n\nvar isCallable = __webpack_require__(/*! is-callable */ \"../formality/node_modules/is-callable/index.js\");\n\n// http://ecma-international.org/ecma-262/5.1/#sec-8.12.8\nvar ES5internalSlots = {\n\t'[[DefaultValue]]': function (O) {\n\t\tvar actualHint;\n\t\tif (arguments.length > 1) {\n\t\t\tactualHint = arguments[1];\n\t\t} else {\n\t\t\tactualHint = toStr.call(O) === '[object Date]' ? String : Number;\n\t\t}\n\n\t\tif (actualHint === String || actualHint === Number) {\n\t\t\tvar methods = actualHint === String ? ['toString', 'valueOf'] : ['valueOf', 'toString'];\n\t\t\tvar value, i;\n\t\t\tfor (i = 0; i < methods.length; ++i) {\n\t\t\t\tif (isCallable(O[methods[i]])) {\n\t\t\t\t\tvalue = O[methods[i]]();\n\t\t\t\t\tif (isPrimitive(value)) {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new TypeError('No default value');\n\t\t}\n\t\tthrow new TypeError('invalid [[DefaultValue]] hint supplied');\n\t}\n};\n\n// http://ecma-international.org/ecma-262/5.1/#sec-9.1\nmodule.exports = function ToPrimitive(input) {\n\tif (isPrimitive(input)) {\n\t\treturn input;\n\t}\n\tif (arguments.length > 1) {\n\t\treturn ES5internalSlots['[[DefaultValue]]'](input, arguments[1]);\n\t}\n\treturn ES5internalSlots['[[DefaultValue]]'](input);\n};\n\n\n//# sourceURL=webpack:///../formality/node_modules/es-to-primitive/es5.js?");

/***/ }),

/***/ "../formality/node_modules/es-to-primitive/helpers/isPrimitive.js":
/*!************************************************************************!*\
  !*** ../formality/node_modules/es-to-primitive/helpers/isPrimitive.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function isPrimitive(value) {\n\treturn value === null || (typeof value !== 'function' && typeof value !== 'object');\n};\n\n\n//# sourceURL=webpack:///../formality/node_modules/es-to-primitive/helpers/isPrimitive.js?");

/***/ }),

/***/ "../formality/node_modules/for-each/index.js":
/*!***************************************************!*\
  !*** ../formality/node_modules/for-each/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar isCallable = __webpack_require__(/*! is-callable */ \"../formality/node_modules/is-callable/index.js\");\n\nvar toStr = Object.prototype.toString;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar forEachArray = function forEachArray(array, iterator, receiver) {\n    for (var i = 0, len = array.length; i < len; i++) {\n        if (hasOwnProperty.call(array, i)) {\n            if (receiver == null) {\n                iterator(array[i], i, array);\n            } else {\n                iterator.call(receiver, array[i], i, array);\n            }\n        }\n    }\n};\n\nvar forEachString = function forEachString(string, iterator, receiver) {\n    for (var i = 0, len = string.length; i < len; i++) {\n        // no such thing as a sparse string.\n        if (receiver == null) {\n            iterator(string.charAt(i), i, string);\n        } else {\n            iterator.call(receiver, string.charAt(i), i, string);\n        }\n    }\n};\n\nvar forEachObject = function forEachObject(object, iterator, receiver) {\n    for (var k in object) {\n        if (hasOwnProperty.call(object, k)) {\n            if (receiver == null) {\n                iterator(object[k], k, object);\n            } else {\n                iterator.call(receiver, object[k], k, object);\n            }\n        }\n    }\n};\n\nvar forEach = function forEach(list, iterator, thisArg) {\n    if (!isCallable(iterator)) {\n        throw new TypeError('iterator must be a function');\n    }\n\n    var receiver;\n    if (arguments.length >= 3) {\n        receiver = thisArg;\n    }\n\n    if (toStr.call(list) === '[object Array]') {\n        forEachArray(list, iterator, receiver);\n    } else if (typeof list === 'string') {\n        forEachString(list, iterator, receiver);\n    } else {\n        forEachObject(list, iterator, receiver);\n    }\n};\n\nmodule.exports = forEach;\n\n\n//# sourceURL=webpack:///../formality/node_modules/for-each/index.js?");

/***/ }),

/***/ "../formality/node_modules/function-bind/implementation.js":
/*!*****************************************************************!*\
  !*** ../formality/node_modules/function-bind/implementation.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/* eslint no-invalid-this: 1 */\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar slice = Array.prototype.slice;\nvar toStr = Object.prototype.toString;\nvar funcType = '[object Function]';\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.call(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slice.call(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                args.concat(slice.call(arguments))\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        } else {\n            return target.apply(\n                that,\n                args.concat(slice.call(arguments))\n            );\n        }\n    };\n\n    var boundLength = Math.max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs.push('$' + i);\n    }\n\n    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n\n\n//# sourceURL=webpack:///../formality/node_modules/function-bind/implementation.js?");

/***/ }),

/***/ "../formality/node_modules/function-bind/index.js":
/*!********************************************************!*\
  !*** ../formality/node_modules/function-bind/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar implementation = __webpack_require__(/*! ./implementation */ \"../formality/node_modules/function-bind/implementation.js\");\n\nmodule.exports = Function.prototype.bind || implementation;\n\n\n//# sourceURL=webpack:///../formality/node_modules/function-bind/index.js?");

/***/ }),

/***/ "../formality/node_modules/global/window.js":
/*!**************************************************!*\
  !*** ../formality/node_modules/global/window.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var win;\n\nif (typeof window !== \"undefined\") {\n    win = window;\n} else if (typeof global !== \"undefined\") {\n    win = global;\n} else if (typeof self !== \"undefined\"){\n    win = self;\n} else {\n    win = {};\n}\n\nmodule.exports = win;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../inferno-hello-world/node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///../formality/node_modules/global/window.js?");

/***/ }),

/***/ "../formality/node_modules/has/src/index.js":
/*!**************************************************!*\
  !*** ../formality/node_modules/has/src/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar bind = __webpack_require__(/*! function-bind */ \"../formality/node_modules/function-bind/index.js\");\n\nmodule.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);\n\n\n//# sourceURL=webpack:///../formality/node_modules/has/src/index.js?");

/***/ }),

/***/ "../formality/node_modules/is-callable/index.js":
/*!******************************************************!*\
  !*** ../formality/node_modules/is-callable/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar fnToStr = Function.prototype.toString;\n\nvar constructorRegex = /^\\s*class\\b/;\nvar isES6ClassFn = function isES6ClassFunction(value) {\n\ttry {\n\t\tvar fnStr = fnToStr.call(value);\n\t\treturn constructorRegex.test(fnStr);\n\t} catch (e) {\n\t\treturn false; // not a function\n\t}\n};\n\nvar tryFunctionObject = function tryFunctionToStr(value) {\n\ttry {\n\t\tif (isES6ClassFn(value)) { return false; }\n\t\tfnToStr.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\nvar toStr = Object.prototype.toString;\nvar fnClass = '[object Function]';\nvar genClass = '[object GeneratorFunction]';\nvar hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\n\nmodule.exports = function isCallable(value) {\n\tif (!value) { return false; }\n\tif (typeof value !== 'function' && typeof value !== 'object') { return false; }\n\tif (typeof value === 'function' && !value.prototype) { return true; }\n\tif (hasToStringTag) { return tryFunctionObject(value); }\n\tif (isES6ClassFn(value)) { return false; }\n\tvar strClass = toStr.call(value);\n\treturn strClass === fnClass || strClass === genClass;\n};\n\n\n//# sourceURL=webpack:///../formality/node_modules/is-callable/index.js?");

/***/ }),

/***/ "../formality/node_modules/is-function/index.js":
/*!******************************************************!*\
  !*** ../formality/node_modules/is-function/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = isFunction\n\nvar toString = Object.prototype.toString\n\nfunction isFunction (fn) {\n  var string = toString.call(fn)\n  return string === '[object Function]' ||\n    (typeof fn === 'function' && string !== '[object RegExp]') ||\n    (typeof window !== 'undefined' &&\n     // IE8 and below\n     (fn === window.setTimeout ||\n      fn === window.alert ||\n      fn === window.confirm ||\n      fn === window.prompt))\n};\n\n\n//# sourceURL=webpack:///../formality/node_modules/is-function/index.js?");

/***/ }),

/***/ "../formality/node_modules/object-assign/index.js":
/*!********************************************************!*\
  !*** ../formality/node_modules/object-assign/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n\n//# sourceURL=webpack:///../formality/node_modules/object-assign/index.js?");

/***/ }),

/***/ "../formality/node_modules/object-keys/implementation.js":
/*!***************************************************************!*\
  !*** ../formality/node_modules/object-keys/implementation.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar keysShim;\nif (!Object.keys) {\n\t// modified from https://github.com/es-shims/es5-shim\n\tvar has = Object.prototype.hasOwnProperty;\n\tvar toStr = Object.prototype.toString;\n\tvar isArgs = __webpack_require__(/*! ./isArguments */ \"../formality/node_modules/object-keys/isArguments.js\"); // eslint-disable-line global-require\n\tvar isEnumerable = Object.prototype.propertyIsEnumerable;\n\tvar hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');\n\tvar hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');\n\tvar dontEnums = [\n\t\t'toString',\n\t\t'toLocaleString',\n\t\t'valueOf',\n\t\t'hasOwnProperty',\n\t\t'isPrototypeOf',\n\t\t'propertyIsEnumerable',\n\t\t'constructor'\n\t];\n\tvar equalsConstructorPrototype = function (o) {\n\t\tvar ctor = o.constructor;\n\t\treturn ctor && ctor.prototype === o;\n\t};\n\tvar excludedKeys = {\n\t\t$applicationCache: true,\n\t\t$console: true,\n\t\t$external: true,\n\t\t$frame: true,\n\t\t$frameElement: true,\n\t\t$frames: true,\n\t\t$innerHeight: true,\n\t\t$innerWidth: true,\n\t\t$onmozfullscreenchange: true,\n\t\t$onmozfullscreenerror: true,\n\t\t$outerHeight: true,\n\t\t$outerWidth: true,\n\t\t$pageXOffset: true,\n\t\t$pageYOffset: true,\n\t\t$parent: true,\n\t\t$scrollLeft: true,\n\t\t$scrollTop: true,\n\t\t$scrollX: true,\n\t\t$scrollY: true,\n\t\t$self: true,\n\t\t$webkitIndexedDB: true,\n\t\t$webkitStorageInfo: true,\n\t\t$window: true\n\t};\n\tvar hasAutomationEqualityBug = (function () {\n\t\t/* global window */\n\t\tif (typeof window === 'undefined') { return false; }\n\t\tfor (var k in window) {\n\t\t\ttry {\n\t\t\t\tif (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tequalsConstructorPrototype(window[k]);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}());\n\tvar equalsConstructorPrototypeIfNotBuggy = function (o) {\n\t\t/* global window */\n\t\tif (typeof window === 'undefined' || !hasAutomationEqualityBug) {\n\t\t\treturn equalsConstructorPrototype(o);\n\t\t}\n\t\ttry {\n\t\t\treturn equalsConstructorPrototype(o);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\tkeysShim = function keys(object) {\n\t\tvar isObject = object !== null && typeof object === 'object';\n\t\tvar isFunction = toStr.call(object) === '[object Function]';\n\t\tvar isArguments = isArgs(object);\n\t\tvar isString = isObject && toStr.call(object) === '[object String]';\n\t\tvar theKeys = [];\n\n\t\tif (!isObject && !isFunction && !isArguments) {\n\t\t\tthrow new TypeError('Object.keys called on a non-object');\n\t\t}\n\n\t\tvar skipProto = hasProtoEnumBug && isFunction;\n\t\tif (isString && object.length > 0 && !has.call(object, 0)) {\n\t\t\tfor (var i = 0; i < object.length; ++i) {\n\t\t\t\ttheKeys.push(String(i));\n\t\t\t}\n\t\t}\n\n\t\tif (isArguments && object.length > 0) {\n\t\t\tfor (var j = 0; j < object.length; ++j) {\n\t\t\t\ttheKeys.push(String(j));\n\t\t\t}\n\t\t} else {\n\t\t\tfor (var name in object) {\n\t\t\t\tif (!(skipProto && name === 'prototype') && has.call(object, name)) {\n\t\t\t\t\ttheKeys.push(String(name));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (hasDontEnumBug) {\n\t\t\tvar skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);\n\n\t\t\tfor (var k = 0; k < dontEnums.length; ++k) {\n\t\t\t\tif (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {\n\t\t\t\t\ttheKeys.push(dontEnums[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn theKeys;\n\t};\n}\nmodule.exports = keysShim;\n\n\n//# sourceURL=webpack:///../formality/node_modules/object-keys/implementation.js?");

/***/ }),

/***/ "../formality/node_modules/object-keys/index.js":
/*!******************************************************!*\
  !*** ../formality/node_modules/object-keys/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar slice = Array.prototype.slice;\nvar isArgs = __webpack_require__(/*! ./isArguments */ \"../formality/node_modules/object-keys/isArguments.js\");\n\nvar origKeys = Object.keys;\nvar keysShim = origKeys ? function keys(o) { return origKeys(o); } : __webpack_require__(/*! ./implementation */ \"../formality/node_modules/object-keys/implementation.js\");\n\nvar originalKeys = Object.keys;\n\nkeysShim.shim = function shimObjectKeys() {\n\tif (Object.keys) {\n\t\tvar keysWorksWithArguments = (function () {\n\t\t\t// Safari 5.0 bug\n\t\t\tvar args = Object.keys(arguments);\n\t\t\treturn args && args.length === arguments.length;\n\t\t}(1, 2));\n\t\tif (!keysWorksWithArguments) {\n\t\t\tObject.keys = function keys(object) { // eslint-disable-line func-name-matching\n\t\t\t\tif (isArgs(object)) {\n\t\t\t\t\treturn originalKeys(slice.call(object));\n\t\t\t\t}\n\t\t\t\treturn originalKeys(object);\n\t\t\t};\n\t\t}\n\t} else {\n\t\tObject.keys = keysShim;\n\t}\n\treturn Object.keys || keysShim;\n};\n\nmodule.exports = keysShim;\n\n\n//# sourceURL=webpack:///../formality/node_modules/object-keys/index.js?");

/***/ }),

/***/ "../formality/node_modules/object-keys/isArguments.js":
/*!************************************************************!*\
  !*** ../formality/node_modules/object-keys/isArguments.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar toStr = Object.prototype.toString;\n\nmodule.exports = function isArguments(value) {\n\tvar str = toStr.call(value);\n\tvar isArgs = str === '[object Arguments]';\n\tif (!isArgs) {\n\t\tisArgs = str !== '[object Array]' &&\n\t\t\tvalue !== null &&\n\t\t\ttypeof value === 'object' &&\n\t\t\ttypeof value.length === 'number' &&\n\t\t\tvalue.length >= 0 &&\n\t\t\ttoStr.call(value.callee) === '[object Function]';\n\t}\n\treturn isArgs;\n};\n\n\n//# sourceURL=webpack:///../formality/node_modules/object-keys/isArguments.js?");

/***/ }),

/***/ "../formality/node_modules/parse-headers/parse-headers.js":
/*!****************************************************************!*\
  !*** ../formality/node_modules/parse-headers/parse-headers.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var trim = __webpack_require__(/*! string.prototype.trim */ \"../formality/node_modules/string.prototype.trim/index.js\")\n  , forEach = __webpack_require__(/*! for-each */ \"../formality/node_modules/for-each/index.js\")\n  , isArray = function(arg) {\n      return Object.prototype.toString.call(arg) === '[object Array]';\n    }\n\nmodule.exports = function (headers) {\n  if (!headers)\n    return {}\n\n  var result = {}\n\n  forEach(\n      trim(headers).split('\\n')\n    , function (row) {\n        var index = row.indexOf(':')\n          , key = trim(row.slice(0, index)).toLowerCase()\n          , value = trim(row.slice(index + 1))\n\n        if (typeof(result[key]) === 'undefined') {\n          result[key] = value\n        } else if (isArray(result[key])) {\n          result[key].push(value)\n        } else {\n          result[key] = [ result[key], value ]\n        }\n      }\n  )\n\n  return result\n}\n\n\n//# sourceURL=webpack:///../formality/node_modules/parse-headers/parse-headers.js?");

/***/ }),

/***/ "../formality/node_modules/query-string/index.js":
/*!*******************************************************!*\
  !*** ../formality/node_modules/query-string/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar strictUriEncode = __webpack_require__(/*! strict-uri-encode */ \"../formality/node_modules/strict-uri-encode/index.js\");\nvar objectAssign = __webpack_require__(/*! object-assign */ \"../formality/node_modules/object-assign/index.js\");\nvar decodeComponent = __webpack_require__(/*! decode-uri-component */ \"../formality/node_modules/decode-uri-component/index.js\");\n\nfunction encoderForArrayFormat(opts) {\n\tswitch (opts.arrayFormat) {\n\t\tcase 'index':\n\t\t\treturn function (key, value, index) {\n\t\t\t\treturn value === null ? [\n\t\t\t\t\tencode(key, opts),\n\t\t\t\t\t'[',\n\t\t\t\t\tindex,\n\t\t\t\t\t']'\n\t\t\t\t].join('') : [\n\t\t\t\t\tencode(key, opts),\n\t\t\t\t\t'[',\n\t\t\t\t\tencode(index, opts),\n\t\t\t\t\t']=',\n\t\t\t\t\tencode(value, opts)\n\t\t\t\t].join('');\n\t\t\t};\n\n\t\tcase 'bracket':\n\t\t\treturn function (key, value) {\n\t\t\t\treturn value === null ? encode(key, opts) : [\n\t\t\t\t\tencode(key, opts),\n\t\t\t\t\t'[]=',\n\t\t\t\t\tencode(value, opts)\n\t\t\t\t].join('');\n\t\t\t};\n\n\t\tdefault:\n\t\t\treturn function (key, value) {\n\t\t\t\treturn value === null ? encode(key, opts) : [\n\t\t\t\t\tencode(key, opts),\n\t\t\t\t\t'=',\n\t\t\t\t\tencode(value, opts)\n\t\t\t\t].join('');\n\t\t\t};\n\t}\n}\n\nfunction parserForArrayFormat(opts) {\n\tvar result;\n\n\tswitch (opts.arrayFormat) {\n\t\tcase 'index':\n\t\t\treturn function (key, value, accumulator) {\n\t\t\t\tresult = /\\[(\\d*)\\]$/.exec(key);\n\n\t\t\t\tkey = key.replace(/\\[\\d*\\]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = {};\n\t\t\t\t}\n\n\t\t\t\taccumulator[key][result[1]] = value;\n\t\t\t};\n\n\t\tcase 'bracket':\n\t\t\treturn function (key, value, accumulator) {\n\t\t\t\tresult = /(\\[\\])$/.exec(key);\n\t\t\t\tkey = key.replace(/\\[\\]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t} else if (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = [value];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n\t\t\t};\n\n\t\tdefault:\n\t\t\treturn function (key, value, accumulator) {\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n\t\t\t};\n\t}\n}\n\nfunction encode(value, opts) {\n\tif (opts.encode) {\n\t\treturn opts.strict ? strictUriEncode(value) : encodeURIComponent(value);\n\t}\n\n\treturn value;\n}\n\nfunction keysSorter(input) {\n\tif (Array.isArray(input)) {\n\t\treturn input.sort();\n\t} else if (typeof input === 'object') {\n\t\treturn keysSorter(Object.keys(input)).sort(function (a, b) {\n\t\t\treturn Number(a) - Number(b);\n\t\t}).map(function (key) {\n\t\t\treturn input[key];\n\t\t});\n\t}\n\n\treturn input;\n}\n\nfunction extract(str) {\n\tvar queryStart = str.indexOf('?');\n\tif (queryStart === -1) {\n\t\treturn '';\n\t}\n\treturn str.slice(queryStart + 1);\n}\n\nfunction parse(str, opts) {\n\topts = objectAssign({arrayFormat: 'none'}, opts);\n\n\tvar formatter = parserForArrayFormat(opts);\n\n\t// Create an object with no prototype\n\t// https://github.com/sindresorhus/query-string/issues/47\n\tvar ret = Object.create(null);\n\n\tif (typeof str !== 'string') {\n\t\treturn ret;\n\t}\n\n\tstr = str.trim().replace(/^[?#&]/, '');\n\n\tif (!str) {\n\t\treturn ret;\n\t}\n\n\tstr.split('&').forEach(function (param) {\n\t\tvar parts = param.replace(/\\+/g, ' ').split('=');\n\t\t// Firefox (pre 40) decodes `%3D` to `=`\n\t\t// https://github.com/sindresorhus/query-string/pull/37\n\t\tvar key = parts.shift();\n\t\tvar val = parts.length > 0 ? parts.join('=') : undefined;\n\n\t\t// missing `=` should be `null`:\n\t\t// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\n\t\tval = val === undefined ? null : decodeComponent(val);\n\n\t\tformatter(decodeComponent(key), val, ret);\n\t});\n\n\treturn Object.keys(ret).sort().reduce(function (result, key) {\n\t\tvar val = ret[key];\n\t\tif (Boolean(val) && typeof val === 'object' && !Array.isArray(val)) {\n\t\t\t// Sort object keys, not values\n\t\t\tresult[key] = keysSorter(val);\n\t\t} else {\n\t\t\tresult[key] = val;\n\t\t}\n\n\t\treturn result;\n\t}, Object.create(null));\n}\n\nexports.extract = extract;\nexports.parse = parse;\n\nexports.stringify = function (obj, opts) {\n\tvar defaults = {\n\t\tencode: true,\n\t\tstrict: true,\n\t\tarrayFormat: 'none'\n\t};\n\n\topts = objectAssign(defaults, opts);\n\n\tif (opts.sort === false) {\n\t\topts.sort = function () {};\n\t}\n\n\tvar formatter = encoderForArrayFormat(opts);\n\n\treturn obj ? Object.keys(obj).sort(opts.sort).map(function (key) {\n\t\tvar val = obj[key];\n\n\t\tif (val === undefined) {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (val === null) {\n\t\t\treturn encode(key, opts);\n\t\t}\n\n\t\tif (Array.isArray(val)) {\n\t\t\tvar result = [];\n\n\t\t\tval.slice().forEach(function (val2) {\n\t\t\t\tif (val2 === undefined) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tresult.push(formatter(key, val2, result.length));\n\t\t\t});\n\n\t\t\treturn result.join('&');\n\t\t}\n\n\t\treturn encode(key, opts) + '=' + encode(val, opts);\n\t}).filter(function (x) {\n\t\treturn x.length > 0;\n\t}).join('&') : '';\n};\n\nexports.parseUrl = function (str, opts) {\n\treturn {\n\t\turl: str.split('?')[0] || '',\n\t\tquery: parse(extract(str), opts)\n\t};\n};\n\n\n//# sourceURL=webpack:///../formality/node_modules/query-string/index.js?");

/***/ }),

/***/ "../formality/node_modules/strict-uri-encode/index.js":
/*!************************************************************!*\
  !*** ../formality/node_modules/strict-uri-encode/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function (str) {\n\treturn encodeURIComponent(str).replace(/[!'()*]/g, function (c) {\n\t\treturn '%' + c.charCodeAt(0).toString(16).toUpperCase();\n\t});\n};\n\n\n//# sourceURL=webpack:///../formality/node_modules/strict-uri-encode/index.js?");

/***/ }),

/***/ "../formality/node_modules/string.prototype.trim/implementation.js":
/*!*************************************************************************!*\
  !*** ../formality/node_modules/string.prototype.trim/implementation.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar bind = __webpack_require__(/*! function-bind */ \"../formality/node_modules/function-bind/index.js\");\nvar ES = __webpack_require__(/*! es-abstract/es5 */ \"../formality/node_modules/es-abstract/es5.js\");\nvar replace = bind.call(Function.call, String.prototype.replace);\n\n/* eslint-disable no-control-regex */\nvar leftWhitespace = /^[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]+/;\nvar rightWhitespace = /[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]+$/;\n/* eslint-enable no-control-regex */\n\nmodule.exports = function trim() {\n\tvar S = ES.ToString(ES.CheckObjectCoercible(this));\n\treturn replace(replace(S, leftWhitespace, ''), rightWhitespace, '');\n};\n\n\n//# sourceURL=webpack:///../formality/node_modules/string.prototype.trim/implementation.js?");

/***/ }),

/***/ "../formality/node_modules/string.prototype.trim/index.js":
/*!****************************************************************!*\
  !*** ../formality/node_modules/string.prototype.trim/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar bind = __webpack_require__(/*! function-bind */ \"../formality/node_modules/function-bind/index.js\");\nvar define = __webpack_require__(/*! define-properties */ \"../formality/node_modules/define-properties/index.js\");\n\nvar implementation = __webpack_require__(/*! ./implementation */ \"../formality/node_modules/string.prototype.trim/implementation.js\");\nvar getPolyfill = __webpack_require__(/*! ./polyfill */ \"../formality/node_modules/string.prototype.trim/polyfill.js\");\nvar shim = __webpack_require__(/*! ./shim */ \"../formality/node_modules/string.prototype.trim/shim.js\");\n\nvar boundTrim = bind.call(Function.call, getPolyfill());\n\ndefine(boundTrim, {\n\tgetPolyfill: getPolyfill,\n\timplementation: implementation,\n\tshim: shim\n});\n\nmodule.exports = boundTrim;\n\n\n//# sourceURL=webpack:///../formality/node_modules/string.prototype.trim/index.js?");

/***/ }),

/***/ "../formality/node_modules/string.prototype.trim/polyfill.js":
/*!*******************************************************************!*\
  !*** ../formality/node_modules/string.prototype.trim/polyfill.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar implementation = __webpack_require__(/*! ./implementation */ \"../formality/node_modules/string.prototype.trim/implementation.js\");\n\nvar zeroWidthSpace = '\\u200b';\n\nmodule.exports = function getPolyfill() {\n\tif (String.prototype.trim && zeroWidthSpace.trim() === zeroWidthSpace) {\n\t\treturn String.prototype.trim;\n\t}\n\treturn implementation;\n};\n\n\n//# sourceURL=webpack:///../formality/node_modules/string.prototype.trim/polyfill.js?");

/***/ }),

/***/ "../formality/node_modules/string.prototype.trim/shim.js":
/*!***************************************************************!*\
  !*** ../formality/node_modules/string.prototype.trim/shim.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar define = __webpack_require__(/*! define-properties */ \"../formality/node_modules/define-properties/index.js\");\nvar getPolyfill = __webpack_require__(/*! ./polyfill */ \"../formality/node_modules/string.prototype.trim/polyfill.js\");\n\nmodule.exports = function shimStringTrim() {\n\tvar polyfill = getPolyfill();\n\tdefine(String.prototype, { trim: polyfill }, {\n\t\ttrim: function testTrim() {\n\t\t\treturn String.prototype.trim !== polyfill;\n\t\t}\n\t});\n\treturn polyfill;\n};\n\n\n//# sourceURL=webpack:///../formality/node_modules/string.prototype.trim/shim.js?");

/***/ }),

/***/ "../formality/node_modules/url-set-query/index.js":
/*!********************************************************!*\
  !*** ../formality/node_modules/url-set-query/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = urlSetQuery\nfunction urlSetQuery (url, query) {\n  if (query) {\n    // remove optional leading symbols\n    query = query.trim().replace(/^(\\?|#|&)/, '')\n\n    // don't append empty query\n    query = query ? ('?' + query) : query\n\n    var parts = url.split(/[\\?\\#]/)\n    var start = parts[0]\n    if (query && /\\:\\/\\/[^\\/]*$/.test(start)) {\n      // e.g. http://foo.com -> http://foo.com/\n      start = start + '/'\n    }\n    var match = url.match(/(\\#.*)$/)\n    url = start + query\n    if (match) { // add hash back in\n      url = url + match[0]\n    }\n  }\n  return url\n}\n\n\n//# sourceURL=webpack:///../formality/node_modules/url-set-query/index.js?");

/***/ }),

/***/ "../formality/node_modules/xhr-request-promise/index.js":
/*!**************************************************************!*\
  !*** ../formality/node_modules/xhr-request-promise/index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var request = __webpack_require__(/*! xhr-request */ \"../formality/node_modules/xhr-request/index.js\")\n\nmodule.exports = function (url, options) {\n  return new Promise(function (resolve, reject) {\n    request(url, options, function (err, data) {\n      if (err) reject(err);\n      else resolve(data);\n    });\n  });\n};\n\n\n//# sourceURL=webpack:///../formality/node_modules/xhr-request-promise/index.js?");

/***/ }),

/***/ "../formality/node_modules/xhr-request/index.js":
/*!******************************************************!*\
  !*** ../formality/node_modules/xhr-request/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var queryString = __webpack_require__(/*! query-string */ \"../formality/node_modules/query-string/index.js\")\nvar setQuery = __webpack_require__(/*! url-set-query */ \"../formality/node_modules/url-set-query/index.js\")\nvar assign = __webpack_require__(/*! object-assign */ \"../formality/node_modules/object-assign/index.js\")\nvar ensureHeader = __webpack_require__(/*! ./lib/ensure-header.js */ \"../formality/node_modules/xhr-request/lib/ensure-header.js\")\n\n// this is replaced in the browser\nvar request = __webpack_require__(/*! ./lib/request.js */ \"../formality/node_modules/xhr-request/lib/request-browser.js\")\n\nvar mimeTypeJson = 'application/json'\nvar noop = function () {}\n\nmodule.exports = xhrRequest\nfunction xhrRequest (url, opt, cb) {\n  if (!url || typeof url !== 'string') {\n    throw new TypeError('must specify a URL')\n  }\n  if (typeof opt === 'function') {\n    cb = opt\n    opt = {}\n  }\n  if (cb && typeof cb !== 'function') {\n    throw new TypeError('expected cb to be undefined or a function')\n  }\n\n  cb = cb || noop\n  opt = opt || {}\n\n  var defaultResponse = opt.json ? 'json' : 'text'\n  opt = assign({ responseType: defaultResponse }, opt)\n\n  var headers = opt.headers || {}\n  var method = (opt.method || 'GET').toUpperCase()\n  var query = opt.query\n  if (query) {\n    if (typeof query !== 'string') {\n      query = queryString.stringify(query)\n    }\n    url = setQuery(url, query)\n  }\n\n  // allow json response\n  if (opt.responseType === 'json') {\n    ensureHeader(headers, 'Accept', mimeTypeJson)\n  }\n\n  // if body content is json\n  if (opt.json && method !== 'GET' && method !== 'HEAD') {\n    ensureHeader(headers, 'Content-Type', mimeTypeJson)\n    opt.body = JSON.stringify(opt.body)\n  }\n\n  opt.method = method\n  opt.url = url\n  opt.headers = headers\n  delete opt.query\n  delete opt.json\n\n  return request(opt, cb)\n}\n\n\n//# sourceURL=webpack:///../formality/node_modules/xhr-request/index.js?");

/***/ }),

/***/ "../formality/node_modules/xhr-request/lib/ensure-header.js":
/*!******************************************************************!*\
  !*** ../formality/node_modules/xhr-request/lib/ensure-header.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = ensureHeader\nfunction ensureHeader (headers, key, value) {\n  var lower = key.toLowerCase()\n  if (!headers[key] && !headers[lower]) {\n    headers[key] = value\n  }\n}\n\n\n//# sourceURL=webpack:///../formality/node_modules/xhr-request/lib/ensure-header.js?");

/***/ }),

/***/ "../formality/node_modules/xhr-request/lib/normalize-response.js":
/*!***********************************************************************!*\
  !*** ../formality/node_modules/xhr-request/lib/normalize-response.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = getResponse\nfunction getResponse (opt, resp) {\n  if (!resp) return null\n  return {\n    statusCode: resp.statusCode,\n    headers: resp.headers,\n    method: opt.method,\n    url: opt.url,\n    // the XHR object in browser, http response in Node\n    rawRequest: resp.rawRequest ? resp.rawRequest : resp\n  }\n}\n\n\n//# sourceURL=webpack:///../formality/node_modules/xhr-request/lib/normalize-response.js?");

/***/ }),

/***/ "../formality/node_modules/xhr-request/lib/request-browser.js":
/*!********************************************************************!*\
  !*** ../formality/node_modules/xhr-request/lib/request-browser.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var xhr = __webpack_require__(/*! xhr */ \"../formality/node_modules/xhr/index.js\")\nvar normalize = __webpack_require__(/*! ./normalize-response */ \"../formality/node_modules/xhr-request/lib/normalize-response.js\")\nvar noop = function () {}\n\nmodule.exports = xhrRequest\nfunction xhrRequest (opt, cb) {\n  delete opt.uri\n\n  // for better JSON.parse error handling than xhr module\n  var useJson = false\n  if (opt.responseType === 'json') {\n    opt.responseType = 'text'\n    useJson = true\n  }\n\n  var req = xhr(opt, function xhrRequestResult (err, resp, body) {\n    if (useJson && !err) {\n      try {\n        var text = resp.rawRequest.responseText\n        body = JSON.parse(text)\n      } catch (e) {\n        err = e\n      }\n    }\n\n    resp = normalize(opt, resp)\n    if (err) cb(err, null, resp)\n    else cb(err, body, resp)\n    cb = noop\n  })\n\n  // Patch abort() so that it also calls the callback, but with an error\n  var onabort = req.onabort\n  req.onabort = function () {\n    var ret = onabort.apply(req, Array.prototype.slice.call(arguments))\n    cb(new Error('XHR Aborted'))\n    cb = noop\n    return ret\n  }\n\n  return req\n}\n\n\n//# sourceURL=webpack:///../formality/node_modules/xhr-request/lib/request-browser.js?");

/***/ }),

/***/ "../formality/node_modules/xhr/index.js":
/*!**********************************************!*\
  !*** ../formality/node_modules/xhr/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar window = __webpack_require__(/*! global/window */ \"../formality/node_modules/global/window.js\")\nvar isFunction = __webpack_require__(/*! is-function */ \"../formality/node_modules/is-function/index.js\")\nvar parseHeaders = __webpack_require__(/*! parse-headers */ \"../formality/node_modules/parse-headers/parse-headers.js\")\nvar xtend = __webpack_require__(/*! xtend */ \"../formality/node_modules/xtend/immutable.js\")\n\nmodule.exports = createXHR\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = createXHR;\ncreateXHR.XMLHttpRequest = window.XMLHttpRequest || noop\ncreateXHR.XDomainRequest = \"withCredentials\" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest\n\nforEachArray([\"get\", \"put\", \"post\", \"patch\", \"head\", \"delete\"], function(method) {\n    createXHR[method === \"delete\" ? \"del\" : method] = function(uri, options, callback) {\n        options = initParams(uri, options, callback)\n        options.method = method.toUpperCase()\n        return _createXHR(options)\n    }\n})\n\nfunction forEachArray(array, iterator) {\n    for (var i = 0; i < array.length; i++) {\n        iterator(array[i])\n    }\n}\n\nfunction isEmpty(obj){\n    for(var i in obj){\n        if(obj.hasOwnProperty(i)) return false\n    }\n    return true\n}\n\nfunction initParams(uri, options, callback) {\n    var params = uri\n\n    if (isFunction(options)) {\n        callback = options\n        if (typeof uri === \"string\") {\n            params = {uri:uri}\n        }\n    } else {\n        params = xtend(options, {uri: uri})\n    }\n\n    params.callback = callback\n    return params\n}\n\nfunction createXHR(uri, options, callback) {\n    options = initParams(uri, options, callback)\n    return _createXHR(options)\n}\n\nfunction _createXHR(options) {\n    if(typeof options.callback === \"undefined\"){\n        throw new Error(\"callback argument missing\")\n    }\n\n    var called = false\n    var callback = function cbOnce(err, response, body){\n        if(!called){\n            called = true\n            options.callback(err, response, body)\n        }\n    }\n\n    function readystatechange() {\n        if (xhr.readyState === 4) {\n            setTimeout(loadFunc, 0)\n        }\n    }\n\n    function getBody() {\n        // Chrome with requestType=blob throws errors arround when even testing access to responseText\n        var body = undefined\n\n        if (xhr.response) {\n            body = xhr.response\n        } else {\n            body = xhr.responseText || getXml(xhr)\n        }\n\n        if (isJson) {\n            try {\n                body = JSON.parse(body)\n            } catch (e) {}\n        }\n\n        return body\n    }\n\n    function errorFunc(evt) {\n        clearTimeout(timeoutTimer)\n        if(!(evt instanceof Error)){\n            evt = new Error(\"\" + (evt || \"Unknown XMLHttpRequest Error\") )\n        }\n        evt.statusCode = 0\n        return callback(evt, failureResponse)\n    }\n\n    // will load the data & process the response in a special response object\n    function loadFunc() {\n        if (aborted) return\n        var status\n        clearTimeout(timeoutTimer)\n        if(options.useXDR && xhr.status===undefined) {\n            //IE8 CORS GET successful response doesn't have a status field, but body is fine\n            status = 200\n        } else {\n            status = (xhr.status === 1223 ? 204 : xhr.status)\n        }\n        var response = failureResponse\n        var err = null\n\n        if (status !== 0){\n            response = {\n                body: getBody(),\n                statusCode: status,\n                method: method,\n                headers: {},\n                url: uri,\n                rawRequest: xhr\n            }\n            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE\n                response.headers = parseHeaders(xhr.getAllResponseHeaders())\n            }\n        } else {\n            err = new Error(\"Internal XMLHttpRequest Error\")\n        }\n        return callback(err, response, response.body)\n    }\n\n    var xhr = options.xhr || null\n\n    if (!xhr) {\n        if (options.cors || options.useXDR) {\n            xhr = new createXHR.XDomainRequest()\n        }else{\n            xhr = new createXHR.XMLHttpRequest()\n        }\n    }\n\n    var key\n    var aborted\n    var uri = xhr.url = options.uri || options.url\n    var method = xhr.method = options.method || \"GET\"\n    var body = options.body || options.data\n    var headers = xhr.headers = options.headers || {}\n    var sync = !!options.sync\n    var isJson = false\n    var timeoutTimer\n    var failureResponse = {\n        body: undefined,\n        headers: {},\n        statusCode: 0,\n        method: method,\n        url: uri,\n        rawRequest: xhr\n    }\n\n    if (\"json\" in options && options.json !== false) {\n        isJson = true\n        headers[\"accept\"] || headers[\"Accept\"] || (headers[\"Accept\"] = \"application/json\") //Don't override existing accept header declared by user\n        if (method !== \"GET\" && method !== \"HEAD\") {\n            headers[\"content-type\"] || headers[\"Content-Type\"] || (headers[\"Content-Type\"] = \"application/json\") //Don't override existing accept header declared by user\n            body = JSON.stringify(options.json === true ? body : options.json)\n        }\n    }\n\n    xhr.onreadystatechange = readystatechange\n    xhr.onload = loadFunc\n    xhr.onerror = errorFunc\n    // IE9 must have onprogress be set to a unique function.\n    xhr.onprogress = function () {\n        // IE must die\n    }\n    xhr.onabort = function(){\n        aborted = true;\n    }\n    xhr.ontimeout = errorFunc\n    xhr.open(method, uri, !sync, options.username, options.password)\n    //has to be after open\n    if(!sync) {\n        xhr.withCredentials = !!options.withCredentials\n    }\n    // Cannot set timeout with sync request\n    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly\n    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent\n    if (!sync && options.timeout > 0 ) {\n        timeoutTimer = setTimeout(function(){\n            if (aborted) return\n            aborted = true//IE9 may still call readystatechange\n            xhr.abort(\"timeout\")\n            var e = new Error(\"XMLHttpRequest timeout\")\n            e.code = \"ETIMEDOUT\"\n            errorFunc(e)\n        }, options.timeout )\n    }\n\n    if (xhr.setRequestHeader) {\n        for(key in headers){\n            if(headers.hasOwnProperty(key)){\n                xhr.setRequestHeader(key, headers[key])\n            }\n        }\n    } else if (options.headers && !isEmpty(options.headers)) {\n        throw new Error(\"Headers cannot be set on an XDomainRequest object\")\n    }\n\n    if (\"responseType\" in options) {\n        xhr.responseType = options.responseType\n    }\n\n    if (\"beforeSend\" in options &&\n        typeof options.beforeSend === \"function\"\n    ) {\n        options.beforeSend(xhr)\n    }\n\n    // Microsoft Edge browser sends \"undefined\" when send is called with undefined value.\n    // XMLHttpRequest spec says to pass null as body to indicate no body\n    // See https://github.com/naugtur/xhr/issues/100.\n    xhr.send(body || null)\n\n    return xhr\n\n\n}\n\nfunction getXml(xhr) {\n    // xhr.responseXML will throw Exception \"InvalidStateError\" or \"DOMException\"\n    // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseXML.\n    try {\n        if (xhr.responseType === \"document\") {\n            return xhr.responseXML\n        }\n        var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === \"parsererror\"\n        if (xhr.responseType === \"\" && !firefoxBugTakenEffect) {\n            return xhr.responseXML\n        }\n    } catch (e) {}\n\n    return null\n}\n\nfunction noop() {}\n\n\n//# sourceURL=webpack:///../formality/node_modules/xhr/index.js?");

/***/ }),

/***/ "../formality/node_modules/xtend/immutable.js":
/*!****************************************************!*\
  !*** ../formality/node_modules/xtend/immutable.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n\n\n//# sourceURL=webpack:///../formality/node_modules/xtend/immutable.js?");

/***/ }),

/***/ "../formality/package.json":
/*!*********************************!*\
  !*** ../formality/package.json ***!
  \*********************************/
/*! exports provided: name, version, description, main, bin, scripts, repository, author, license, bugs, homepage, dependencies, default */
/***/ (function(module) {

eval("module.exports = {\"name\":\"formality-lang\",\"version\":\"0.1.166\",\"description\":\"\",\"main\":\"src/fm-lib.js\",\"bin\":{\"fm\":\"src/main.js\"},\"scripts\":{\"test\":\"echo \\\"Error: no test specified\\\" && exit 1\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/moonad/formality-core.git\"},\"author\":\"Victor Maia\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/moonad/formality-core/issues\"},\"homepage\":\"https://github.com/moonad/formality-core#readme\",\"dependencies\":{\"xhr-request-promise\":\"^0.1.2\"}};\n\n//# sourceURL=webpack:///../formality/package.json?");

/***/ }),

/***/ "../formality/src/fm-core.js":
/*!***********************************!*\
  !*** ../formality/src/fm-core.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// ~~ Formality Core Language ~~\n\n// ::::::::::\n// :: Term ::\n// ::::::::::\n\n// An FM-Lang term is an ADT represented as a JSON.\n// - Var: a variable\n// - Typ: the type of types, `Type`\n// - All: the dependent function type, `{x : A} -> B`, optionally erased\n// - Lam: a lambda, `{x} => B`, optionally erased/annotated\n// - App: an application `f(a)`, optionally erased\n// - Box: a boxed type, `!A`\n// - Put: a boxed value, `#a`\n// - Tak: unboxes a boxed value, `<>a`\n// - Dup: copies a boxed value, `dup x = a; b`\n// - Dbl: type of a native number\n// - Val: value of a native number\n// - Op1: partially applied binary numeric operation, `|n + k|`, with `k` fixed\n// - Op2: binary numeric operation, `|x + y|`\n// - Ite: if-then-else, `if n p`,  with a numeric conditional `n`, and two branches in a pair `p`\n// - Cpy: copies a number, `cpy x = a; b`\n// - Sig: type of a dependent pair, `[x : A, B(x)]`, or of a subset type, `[x : A ~ B(x)]`\n// - Par: value of a dependent pair, `[a, b]`, or of a dependent intersection `[a ~ b]`\n// - Fst: extracts 1st value of a dependent pair, `fst p`, or of a dependent intersection, `~fst p`\n// - Snd: extracts 2nd value of a dependent pair, `snd p`, or of a dependent intersection, `~snd p`\n// - Prj: projects a dependent pair, `get [x , y] = a; b`, or a dependent intersection, `get [x ~ y] = a; b`\n// - Ann: an explicit type annotaion, `: A a`\n// - Log: debug-prints a term during evaluation\n// - Hol: a type-hole\n// - Ref: a reference to a global def\nconst Var = (index, loc)                          => [\"Var\", {index},                        MEMO && (\"^\" + index)                             , loc];\nconst Typ = (loc)                                 => [\"Typ\", {},                             MEMO && (\"ty\")                                    , loc];\nconst Tid = (expr, loc)                           => [\"Tid\", {expr},                         MEMO && expr[2]                                   , loc];\nconst Utt = (expr, loc)                           => [\"Utt\", {expr},                         MEMO && (\"ut\" + expr[2])                          , loc];\nconst Utv = (expr, loc)                           => [\"Utv\", {expr},                         MEMO && (\"uv\" + expr[2])                          , loc];\nconst Ute = (expr, loc)                           => [\"Ute\", {expr},                         MEMO && (\"ue\" + expr[2])                          , loc];\nconst All = (name, bind, body, eras, loc)         => [\"All\", {name, bind, body, eras},       MEMO && (\"al\" + (eras?\"~\":\"\") + bind[2] + body[2]), loc];\nconst Lam = (name, bind, body, eras, loc)         => [\"Lam\", {name, bind, body, eras},       MEMO && (\"lm\" + (eras?\"~\":\"\") + body[2])          , loc];\nconst App = (func, argm, eras, loc)               => [\"App\", {func, argm, eras},             MEMO && (\"ap\" + (eras?\"~\":\"\") + func[2] + argm[2]), loc];\nconst Box = (expr, loc)                           => [\"Box\", {expr},                         MEMO && (\"bx\" + expr[2])                          , loc];\nconst Put = (expr, loc)                           => [\"Put\", {expr},                         MEMO && (\"pt\" + expr[2])                          , loc];\nconst Tak = (expr, loc)                           => [\"Tak\", {expr},                         MEMO && (\"tk\" + expr[2])                          , loc];\nconst Dup = (name, expr, body, loc)               => [\"Dup\", {name, expr, body},             MEMO && (\"dp\" + expr[2] + body[2])                , loc];\nconst Num = (loc)                                 => [\"Num\", {},                             MEMO && (\"wd\")                                    , loc];\nconst Val = (numb, loc)                           => [\"Val\", {numb},                         MEMO && (\"[\" + numb + \"]\")                        , loc];\nconst Op1 = (func, num0, num1, loc)               => [\"Op1\", {func, num0, num1},             MEMO && (\"o1\" + func + num0[2] + num1[2])         , loc];\nconst Op2 = (func, num0, num1, loc)               => [\"Op2\", {func, num0, num1},             MEMO && (\"o2\" + func + num0[2] + num1[2])         , loc];\nconst Ite = (cond, pair, loc)                     => [\"Ite\", {cond, pair},                   MEMO && (\"ie\" + cond[2] + pair[2])                , loc];\nconst Cpy = (name, numb, body, loc)               => [\"Cpy\", {name, numb, body},             MEMO && (\"cy\" + numb[2] + body[2])                , loc];\nconst Sig = (name, typ0, typ1, eras, loc)         => [\"Sig\", {name, typ0, typ1, eras},       MEMO && (\"sg\" + eras + typ0[2] + typ1[2])         , loc];\nconst Par = (val0, val1, eras, loc)               => [\"Par\", {val0, val1, eras},             MEMO && (\"pr\" + eras + val0[2] + val1[2])         , loc];\nconst Fst = (pair, eras=0, loc)                   => [\"Fst\", {pair, eras},                   MEMO && (\"ft\" + eras + pair[2])                   , loc];\nconst Snd = (pair, eras=0, loc)                   => [\"Snd\", {pair, eras},                   MEMO && (\"sd\" + eras + pair[2])                   , loc];\nconst Prj = (nam0, nam1, pair, body, eras=0, loc) => [\"Prj\", {nam0, nam1, pair, body, eras}, MEMO && (\"pj\" + eras + pair[2] + body[2])         , loc];\nconst Slf = (name, type, loc)                     => [\"Slf\", {name, type},                   MEMO && (\"sf\" + type[2])                          , loc];\nconst New = (type, expr, loc)                     => [\"New\", {type, expr},                   MEMO && expr[2]                                   , loc];\nconst Use = (expr, loc)                           => [\"Use\", {expr},                         MEMO && expr[2]                                   , loc];\nconst Ann = (type, expr, done, loc)               => [\"Ann\", {type, expr, done},             MEMO && expr[2]                                   , loc];\nconst Log = (msge, expr, loc)                     => [\"Log\", {msge, expr},                   MEMO && expr[2]                                   , loc];\nconst Hol = (name, loc)                           => [\"Hol\", {name},                         MEMO && (\"{?\" + name + \"?}\")                      , loc];\nconst Ref = (name, eras, loc)                     => [\"Ref\", {name, eras},                   MEMO && (\"{\" + name + \"}\")                        , loc];\nvar MEMO  = true;\n\n// ::::::::::::::::::\n// :: Substitution ::\n// ::::::::::::::::::\n\n// Shifts a term\n// shift : Maybe(Term) -> Nat -> Nat -> Maybe(Term)\nconst shift = (term, inc, depth) => {\n  if  (!term) {\n    return null;\n  } else {\n    const [f, [c, t, h, l], i, d] = [shift, term, inc, depth];\n    switch (c) {\n      case \"Var\": return Var(t.index < d ? t.index : t.index + i, l);\n      case \"Typ\": return Typ(l);\n      case \"Tid\": return Tid(f(t.expr, i, d), l);\n      case \"Utt\": return Utt(f(t.expr, i, d), l);\n      case \"Utv\": return Utv(f(t.expr, i, d), l);\n      case \"Ute\": return Ute(f(t.expr, i, d), l);\n      case \"All\": return All(t.name, f(t.bind, i, d), f(t.body, i, d+1), t.eras, l);\n      case \"Lam\": return Lam(t.name, f(t.bind, i, d), f(t.body, i, d+1), t.eras, l);\n      case \"App\": return App(f(t.func, i, d), f(t.argm, i, d), t.eras, l);\n      case \"Box\": return Box(f(t.expr, i, d), l);\n      case \"Put\": return Put(f(t.expr, i, d), l);\n      case \"Tak\": return Tak(f(t.expr, i, d), l);\n      case \"Dup\": return Dup(t.name, f(t.expr, i, d), f(t.body, i, d+1), l);\n      case \"Num\": return Num(l);\n      case \"Val\": return Val(t.numb, l);\n      case \"Op1\": return Op1(t.func, f(t.num0, i, d), f(t.num1, i, d), l);\n      case \"Op2\": return Op2(t.func, f(t.num0, i, d), f(t.num1, i, d), l);\n      case \"Ite\": return Ite(f(t.cond, i, d), f(t.pair, i, d), l);\n      case \"Cpy\": return Cpy(t.name, f(t.numb, i, d), f(t.body, i, d+1), l);\n      case \"Sig\": return Sig(t.name, f(t.typ0, i, d), f(t.typ1, i, d+1),  t.eras, l);\n      case \"Par\": return Par(f(t.val0, i, d), f(t.val1, i, d), t.eras, l);\n      case \"Fst\": return Fst(f(t.pair, i, d), t.eras, l);\n      case \"Snd\": return Snd(f(t.pair, i, d), t.eras, l);\n      case \"Prj\": return Prj(t.nam0, t.nam1, f(t.pair, i,  d), f(t.body, i, d+2), t.eras, l);\n      case \"Slf\": return Slf(t.name, f(t.type, i, d+1), l);\n      case \"New\": return New(f(t.type, i, d), f(t.expr, i, d), l);\n      case \"Use\": return Use(f(t.expr, i, d), l);\n      case \"Ann\": return Ann(f(t.type, i, d), f(t.expr, i, d), t.done, l);\n      case \"Log\": return Log(f(t.msge, i, d), f(t.expr, i, d), l);\n      case \"Hol\": return Hol(t.name, l);\n      case \"Ref\": return Ref(t.name, t.eras, l);\n    }\n  }\n}\n\n// shift : Maybe(Term) -> Term -> Nat -> Maybe(Term)\nconst subst = (term, val, depth) => {\n  if  (!term) {\n    return null;\n  } else {\n    const [s, f, [c, t, h, l], v, d] = [shift, subst, term, val, depth];\n    switch (c) {\n      case \"Var\": return d === t.index ? v : Var(t.index - (t.index > d ? 1 : 0), l);\n      case \"Typ\": return Typ(l);\n      case \"Tid\": return Tid(f(t.expr, v, d), l);\n      case \"Utt\": return Utt(f(t.expr, v, d), l);\n      case \"Utv\": return Utv(f(t.expr, v, d), l);\n      case \"Ute\": return Ute(f(t.expr, v, d), l);\n      case \"All\": return All(t.name, f(t.bind, v, d), f(t.body, s(v,1,0), d+1), t.eras, l);\n      case \"Lam\": return Lam(t.name, f(t.bind, v, d), f(t.body, s(v,1,0), d+1), t.eras, l);\n      case \"App\": return App(f(t.func, v, d), f(t.argm, v, d), t.eras, l);\n      case \"Box\": return Box(f(t.expr, v, d), l);\n      case \"Put\": return Put(f(t.expr, v, d), l);\n      case \"Tak\": return Tak(f(t.expr, v, d), l);\n      case \"Dup\": return Dup(t.name, f(t.expr, v, d), f(t.body, s(v,1,0), d+1), l);\n      case \"Num\": return Num(l);\n      case \"Val\": return Val(t.numb, l);\n      case \"Op1\": return Op1(t.func, f(t.num0, v, d), f(t.num1, v, d), l);\n      case \"Op2\": return Op2(t.func, f(t.num0, v, d), f(t.num1, v, d), l);\n      case \"Ite\": return Ite(f(t.cond, v, d), f(t.pair, v, d), l);\n      case \"Cpy\": return Cpy(t.name, f(t.numb, v, d), f(t.body, s(v,1,0), d+1), l);\n      case \"Sig\": return Sig(t.name, f(t.typ0, v, d), f(t.typ1, s(v,1,0), d+1),  t.eras, l);\n      case \"Par\": return Par(f(t.val0, v, d), f(t.val1, v, d), t.eras, l);\n      case \"Fst\": return Fst(f(t.pair, v, d), t.eras, l);\n      case \"Snd\": return Snd(f(t.pair, v, d), t.eras, l);\n      case \"Prj\": return Prj(t.nam0, t.nam1, f(t.pair, v, d), f(t.body, s(v,2,0), d+2), t.eras, l);\n      case \"Slf\": return Slf(t.name, f(t.type, s(v,1,0), d+1), l);\n      case \"New\": return New(f(t.type, v, d), f(t.expr, v, d), l);\n      case \"Use\": return Use(f(t.expr, v, d), l);\n      case \"Ann\": return Ann(f(t.type, v, d), f(t.expr, v, d), t.done, l);\n      case \"Log\": return Log(f(t.msge, v, d), f(t.expr, v, d), l);\n      case \"Hol\": return Hol(t.name, l);\n      case \"Ref\": return Ref(t.name, t.eras, l);\n    }\n  }\n}\n\n// subst_many : Term -> [Term] -> Nat -> Term\nconst subst_many = (term, vals, depth) => {\n  for (var i = 0; i < vals.length; ++i) {\n    term = subst(term, shift(vals[i], vals.length - i - 1, 0), depth + vals.length - i - 1);\n  }\n  return term;\n}\n\n// ::::::::::::::::\n// :: Evaluation ::\n// ::::::::::::::::\n\n// Reduces a term to normal form or head normal form\n// Opts: weak, unbox, logging, eta\nconst reduce = (term, opts = {}) => {\n  const names_new = null;\n  const names_ext = (bind, name, rest) => {\n    return {bind, name, rest};\n  }\n  const names_get = (i, names) => {\n    for (var k = 0; k < i; ++k) {\n      names = names ? names.rest : null;\n    }\n    return names ? {bind: names.bind, name: names.name} : null;\n  };\n  const names_len = (names) => {\n    for (var i = 0; names; ++i) {\n      names = names.rest;\n    }\n    return i;\n  };\n  const names_arr = names => {\n    return names ? [names.name].concat(names_arr(names.rest)) : [];\n  };\n  const names_var = (i, names) => {\n    const got = names_get(i, names);\n    return got ? got.bind : Var(names_len(names) - i - 1);\n  };\n  const apply = (func, argm, eras, names) => {\n    var func = reduce(func, names);\n    if (!opts.no_app && func[0] === \"Lam\") {\n      return reduce(func[1].body(argm), names);\n    } else if (!opts.no_app && func[0] === \"Dup\") {\n      return Dup(func[1].name, func[1].expr, x => weak_reduce(App(func[1].body(x), argm, eras), names_ext(x, func[1].name, names)));\n    } else {\n      return App(func, weak_reduce(argm, names), eras);\n    }\n  };\n  const take = (expr, names) => {\n    var expr = reduce(expr, names);\n    if (!opts.no_tak && expr[0] === \"Put\") {\n      return reduce(expr[1].expr, names);\n    } else if (!opts.no_tak && expr[0] === \"Dup\"){\n      return Dup(expr[1].name, expr[1].expr, x => weak_reduce(Tak(expr[1].body(x)), names_ext(x, expr[1].name, names)));\n    } else {\n      return Tak(expr);\n    }\n  };\n  const duplicate = (name, expr, body, names) => {\n    var expr = reduce(expr, names);\n    if (!opts.dup && expr[0] === \"Put\") {\n      return reduce(body(expr[1].expr), names);\n    } else if (!opts.no_dup && expr[0] === \"Dup\") {\n      return Dup(expr[1].name, expr[1].expr, x => weak_reduce(Dup(name, expr[1].body(x), x => body(x)), names_ext(x, name, expr[1].name)));\n    } else {\n      if (opts.undup) {\n        return reduce(body(Tak(expr)), names);\n      } else {\n        return Dup(name, expr, x => weak_reduce(body(x), names_ext(x, name, names)));\n      }\n    }\n  };\n  const dereference = (name, eras, names) => {\n    if (!opts.no_ref && (opts.defs||{})[name]) {\n      return reduce(unquote(eras ? erase((opts.defs||{})[name]) : (opts.defs||{})[name]), names_new);\n    } else {\n      return Ref(name, eras);\n    }\n  };\n  const op1 = (func, num0, num1, names) => {\n    var num0 = reduce(num0, names);\n    if (!opts.no_op1 && num0[0] === \"Val\") {\n      switch (func) {\n        case \".+.\"   : return Val(num0[1].numb + num1[1].numb);\n        case \".-.\"   : return Val(num0[1].numb - num1[1].numb);\n        case \".*.\"   : return Val(num0[1].numb * num1[1].numb);\n        case \"./.\"   : return Val(num0[1].numb / num1[1].numb);\n        case \".%.\"   : return Val(num0[1].numb % num1[1].numb);\n        case \".**.\"  : return Val(num0[1].numb ** num1[1].numb);\n        case \".&.\"   : return Val((num0[1].numb & num1[1].numb) >>> 0);\n        case \".|.\"   : return Val((num0[1].numb | num1[1].numb) >>> 0);\n        case \".^.\"   : return Val((num0[1].numb ^ num1[1].numb) >>> 0);\n        case \".~.\"   : return Val(~ num1[1].numb);\n        case \".>>>.\" : return Val((num0[1].numb >>> num1[1].numb));\n        case \".<<.\"  : return Val((num0[1].numb << num1[1].numb));\n        case \".>.\"   : return Val(num0[1].numb > num1[1].numb ? 1 : 0);\n        case \".<.\"   : return Val(num0[1].numb < num1[1].numb ? 1 : 0);\n        case \".==.\"  : return Val(num0[1].numb === num1[1].numb ? 1 : 0);\n        default      : throw \"[NORMALIZATION-ERROR]\\nUnknown primitive: \" + func + \".\";\n      }\n    } else {\n      return Op1(func, num0, num1);\n    }\n  };\n  const op2 = (func, num0, num1, names) => {\n    var num1 = reduce(num1, names);\n    if (!opts.no_op2 && num1[0] === \"Val\") {\n      return reduce(Op1(func, num0, num1, null), names);\n    } else {\n      return Op2(func, weak_reduce(num0, names), num1);\n    }\n  };\n  const if_then_else = (cond, pair, names) => {\n    var cond = reduce(cond, names);\n    if (!opts.no_ite && cond[0] === \"Val\") {\n      return cond[1].numb > 0 ? reduce(Fst(pair, false, null), names) : reduce(Snd(pair, false, null), names);\n    } else {\n      return Ite(cond, weak_reduce(pair, names));\n    }\n  };\n  const copy = (name, numb, body, names) => {\n    var numb = reduce(numb, names);\n    if (!opts.no_cpy && numb[0] === \"Val\") {\n      return reduce(body(numb), names);\n    } else {\n      return Cpy(name, numb, x => weak_reduce(body(x), names_ext(x, name, names)));\n    }\n  };\n  const first = (pair, eras, names) => {\n    var pair = reduce(pair, names);\n    if (!opts.no_fst && pair[0] === \"Par\") {\n      return reduce(pair[1].val0, names);\n    } else {\n      return Fst(pair, eras);\n    }\n  };\n  const second = (pair, eras, names) => {\n    var pair = reduce(pair, names);\n    if (!opts.no_snd && pair[0] === \"Par\") {\n      return reduce(pair[1].val1, names);\n    } else {\n      return Snd(pair, eras);\n    }\n  };\n  const project = (nam0, nam1, pair, body, eras, names) => {\n    var pair = reduce(pair, names);\n    if (!opts.no_prj && pair[0] === \"Par\") {\n      return reduce(body(pair[1].val0, pair[1].val1), names);\n    } else {\n      return Prj(nam0, nam1, pair, (x,y) => weak_reduce(body(x,y), names_ext(y, nam0, names_ext(x, nam1, names))), eras);\n    }\n  };\n  //const restrict = (expr, names) => {\n    //var expr = reduce(expr, names);\n    //if (expr[0] === \"Utv\") {\n      //return reduce(expr[1].expr, names);\n    //} else {\n      //return Ute(expr);\n    //}\n  //};\n  //const unrestrict = (expr, names) => {\n    //var expr = reduce(expr, names);\n    //if (expr[0] === \"Ute\") {\n      //return reduce(expr[1].expr, names);\n    //} else {\n      //return Ute(expr);\n    //}\n  //};\n  const log = (msge, expr, names) => {\n    var msge = reduce(msge, names);\n    var expr = reduce(expr, names);\n    if (opts.logging) {\n      var nams = names_arr(names).reverse();\n    }\n    if (opts.show) {\n      console.log(opts.show(quote(msge, 0), names || null));\n    }\n    return expr;\n  };\n  const unquote = (term, names = null) => {\n    var [ctor, term] = term;\n    switch (ctor) {\n      case \"Var\": return names_var(term.index, names);\n      case \"Typ\": return Typ();\n      case \"Tid\": return Tid(unquote(term.expr, names));\n      case \"Utt\": return Utt(unquote(term.expr, names));\n      case \"Utv\": return Utv(unquote(term.expr, names));\n      case \"Ute\": return Ute(unquote(term.expr, names));\n      case \"All\": return All(term.name, unquote(term.bind, names), x => unquote(term.body, names_ext(x, null, names)), term.eras);\n      case \"Lam\": return Lam(term.name, term.bind && unquote(term.bind, names), x => unquote(term.body, names_ext(x, null, names)), term.eras);\n      case \"App\": return App(unquote(term.func, names), unquote(term.argm, names), term.eras);\n      case \"Box\": return Box(unquote(term.expr, names));\n      case \"Put\": return Put(unquote(term.expr, names));\n      case \"Tak\": return Tak(unquote(term.expr, names));\n      case \"Dup\": return Dup(term.name, unquote(term.expr, names), x => unquote(term.body, names_ext(x, null, names)));\n      case \"Num\": return Num();\n      case \"Val\": return Val(term.numb);\n      case \"Op1\": return Op1(term.func, unquote(term.num0, names), unquote(term.num1, names));\n      case \"Op2\": return Op2(term.func, unquote(term.num0, names), unquote(term.num1, names));\n      case \"Ite\": return Ite(unquote(term.cond, names), unquote(term.pair, names));\n      case \"Cpy\": return Cpy(term.name, unquote(term.numb, names), x => unquote(term.body, names_ext(x, null, names)));\n      case \"Sig\": return Sig(term.name, unquote(term.typ0, names), x => unquote(term.typ1, names_ext(x, null, names)), term.eras);\n      case \"Par\": return Par(unquote(term.val0, names), unquote(term.val1, names), term.eras);\n      case \"Fst\": return Fst(unquote(term.pair, names), term.eras);\n      case \"Snd\": return Snd(unquote(term.pair, names), term.eras);\n      case \"Prj\": return Prj(term.nam0, term.nam1, unquote(term.pair, names), (x,y) => unquote(term.body, names_ext(y, null, names_ext(x, null, names)), term.eras));\n      case \"Slf\": return Slf(term.name, x => unquote(term.type, names_ext(x, null, names)));\n      case \"New\": return New(unquote(term.type, names), unquote(term.expr, names));\n      case \"Use\": return Use(unquote(term.expr, names));\n      case \"Ann\": return Ann(unquote(term.type, names), unquote(term.expr, names), term.done);\n      case \"Log\": return Log(unquote(term.msge, names), unquote(term.expr, names));\n      case \"Hol\": return Hol(term.name);\n      case \"Ref\": return Ref(term.name, term.eras);\n    }\n  };\n  const reduce = (term, names = null) => {\n    var [ctor, term] = term;\n    switch (ctor) {\n      case \"Var\": return Var(term.index);\n      case \"Typ\": return Typ();\n      case \"Tid\": return reduce(term.expr, names);\n      case \"Utt\": return Utt(reduce(term.expr, names));\n      case \"Utv\": return reduce(term.expr, names);\n      case \"Ute\": return reduce(term.expr, names);\n      case \"All\": return All(term.name, weak_reduce(term.bind, names), x => weak_reduce(term.body(x), names_ext(x, term.name, names)), term.eras);\n      case \"Lam\": return Lam(term.name, term.bind && weak_reduce(term.bind, names), x => weak_reduce(term.body(x), names_ext(x, term.name, names)), term.eras);\n      case \"App\": return apply(term.func, term.argm, term.eras, names);\n      case \"Box\": return Box(weak_reduce(term.expr, names));\n      case \"Put\": return opts.unbox ? reduce(term.expr, names) : Put(weak_reduce(term.expr, names));\n      case \"Tak\": return opts.unbox ? reduce(term.expr, names) : take(weak_reduce(term.expr, names), names);\n      case \"Dup\": return opts.unbox ? reduce(term.body(term.expr), names) : duplicate(term.name, term.expr, term.body, names);\n      case \"Num\": return Num();\n      case \"Val\": return Val(term.numb);\n      case \"Op1\": return op1(term.func, term.num0, term.num1, names);\n      case \"Op2\": return op2(term.func, term.num0, term.num1, names);\n      case \"Ite\": return if_then_else(term.cond, term.pair, names);\n      case \"Cpy\": return opts.unbox ? reduce(term.body(term.numb), names) : copy(term.name, term.numb, term.body, names);\n      case \"Sig\": return Sig(term.name, weak_reduce(term.typ0, names), x => weak_reduce(term.typ1(x), names_ext(x, term.name, names)), term.eras);\n      case \"Par\": return Par(weak_reduce(term.val0, names), weak_reduce(term.val1, names), term.eras);\n      case \"Fst\": return first(term.pair, term.eras, names);\n      case \"Snd\": return second(term.pair, term.eras, names);\n      case \"Prj\": return project(term.nam0, term.nam1, term.pair, term.body, term.eras, names);\n      case \"Slf\": return Slf(term.name, x => weak_reduce(term.type(x), names_ext(x, term.name, names)));\n      case \"New\": return reduce(term.expr, names);\n      case \"Use\": return reduce(term.expr, names);\n      case \"Ann\": return reduce(term.expr, names);\n      case \"Log\": return log(term.msge, term.expr, names);\n      case \"Hol\": return Hol(term.name);\n      case \"Ref\": return dereference(term.name, term.eras, names);\n    }\n  };\n  const quote = (term, depth) => {\n    var [ctor, term] = term;\n    switch (ctor) {\n      case \"Var\": return Var(depth - 1 - term.index);\n      case \"Typ\": return Typ();\n      case \"Tid\": return Tid(quote(term.expr, depth));\n      case \"Utt\": return Utt(quote(term.expr, depth));\n      case \"Utv\": return Utv(quote(term.expr, depth));\n      case \"Ute\": return Ute(quote(term.expr, depth));\n      case \"All\": return All(term.name, quote(term.bind, depth), quote(term.body(Var(depth)), depth + 1), term.eras);\n      case \"Lam\": return Lam(term.name, term.bind && quote(term.bind, depth), quote(term.body(Var(depth)), depth + 1), term.eras);\n      case \"App\": return App(quote(term.func, depth), quote(term.argm, depth), term.eras);\n      case \"Box\": return Box(quote(term.expr, depth));\n      case \"Put\": return Put(quote(term.expr, depth));\n      case \"Tak\": return Tak(quote(term.expr, depth));\n      case \"Dup\": return Dup(term.name, quote(term.expr, depth), quote(term.body(Var(depth)), depth + 1));\n      case \"Num\": return Num();\n      case \"Val\": return Val(term.numb);\n      case \"Op1\": return Op1(term.func, quote(term.num0, depth), quote(term.num1, depth));\n      case \"Op2\": return Op2(term.func, quote(term.num0, depth), quote(term.num1, depth));\n      case \"Ite\": return Ite(quote(term.cond, depth), quote(term.pair, depth));\n      case \"Cpy\": return Cpy(term.name, quote(term.numb, depth), quote(term.body(Var(depth)), depth + 1));\n      case \"Sig\": return Sig(term.name, quote(term.typ0, depth), quote(term.typ1(Var(depth)), depth + 1), term.eras);\n      case \"Par\": return Par(quote(term.val0, depth), quote(term.val1, depth), term.eras);\n      case \"Fst\": return Fst(quote(term.pair, depth), term.eras);\n      case \"Snd\": return Snd(quote(term.pair, depth), term.eras);\n      case \"Prj\": return Prj(term.nam0, term.nam1, quote(term.pair, depth), quote(term.body(Var(depth), Var(depth + 1)), depth + 2), term.eras);\n      case \"Slf\": return Slf(term.name, quote(term.type(Var(depth)), depth + 1));\n      case \"New\": return New(quote(term.type, depth), quote(term.expr, depth));\n      case \"Use\": return Use(quote(term.expr, depth));\n      case \"Ann\": return Ann(quote(term.type, depth), quote(term.expr, depth), term.done);\n      case \"Log\": return Log(quote(term.msge, depth), quote(term.expr, depth));\n      case \"Hol\": return Hol(term.name);\n      case \"Ref\": return Ref(term.name, term.eras);\n    }\n  };\n  const weak_reduce = (term, names) => {\n    return opts.weak ? term : reduce(term, names);\n  };\n  MEMO = false;\n  var unquoted = unquote(term);\n  var reduced = reduce(unquoted);\n  MEMO = true;\n  var quoted = quote(reduced, 0);\n  return quoted;\n};\n\n// erase : Term -> Term\nconst erase = (term) => {\n  const [f,[c,t],e] = [erase, term, Put(Hol(\"\"))];\n  switch (c) {\n    case \"Var\": return Var(t.index);\n    case \"Typ\": return Typ();\n    case \"Tid\": return f(t.expr);\n    case \"Utt\": return Utt(f(t.expr));\n    case \"Utv\": return f(t.expr);\n    case \"Ute\": return f(t.expr);\n    case \"All\": return All(t.name, f(t.bind), f(t.body), t.eras);\n    case \"Lam\": return t.eras ? f(subst(t.body, e, 0)) : Lam(t.name, null, f(t.body), t.eras);\n    case \"App\": return t.eras ? f(t.func)              : App(f(t.func), f(t.argm), t.eras);\n    case \"Box\": return Box(f(t.expr));\n    case \"Put\": return Put(f(t.expr));\n    case \"Tak\": return Tak(f(t.expr));\n    case \"Dup\": return Dup(t.name, f(t.expr), f(t.body));\n    case \"Num\": return Num();\n    case \"Val\": return Val(t.numb);\n    case \"Op1\": return Op1(t.func, f(t.num0), f(t.num1));\n    case \"Op2\": return Op2(t.func, f(t.num0), f(t.num1));\n    case \"Ite\": return Ite(f(t.cond), f(t.pair));\n    case \"Cpy\": return Cpy(t.name, f(t.numb), f(t.body));\n    case \"Sig\": return Sig(t.name, f(t.typ0), f(t.typ1), t.eras);\n    case \"Par\": return (t.eras === 1 ? f(t.val1) : t.eras === 2 ? f(t.val0) : Par(f(t.val0), f(t.val1), t.eras));\n    case \"Fst\": return (t.eras === 1 ? e         : t.eras === 2 ? f(t.pair) : Fst(f(t.pair), t.eras));\n    case \"Snd\": return (t.eras === 1 ? f(t.pair) : t.eras === 2 ? e         : Snd(f(t.pair), t.eras));\n    case \"Prj\": return (\n      t.eras === 1 ? f(subst_many(t.body, [e, f(t.pair)]), 0) :\n      t.eras === 2 ? f(subst_many(t.body, [f(t.pair), e]), 0) :\n      Prj(t.nam0, t.nam1, f(t.pair), f(t.body), t.eras));\n    case \"Slf\": return Slf(t.name, f(t.type));\n    case \"New\": return f(t.expr);\n    case \"Use\": return f(t.expr);\n    case \"Ann\": return f(t.expr);\n    case \"Log\": return f(t.expr);\n    case \"Hol\": return Hol(t.name);\n    case \"Ref\": return Ref(t.name, true);\n  }\n}\n\n// ::::::::::::::\n// :: Equality ::\n// ::::::::::::::\n\n// equal : Term -> Term -> Opts -> Bool\nconst equal = (a, b, d, opts) => {\n  const Eqs = (a, b, d) => [\"Eqs\", {a, b, d}];\n  const Bop = (v, x, y) => [\"Bop\", {v, x, y}];\n  const And = (x,y)     => Bop(false, x, y);\n  const Or  = (x,y)     => Bop(true, x, y);\n  const Val = (v)       => [\"Val\", {v}];\n\n  const step = (node) => {\n    switch (node[0]) {\n      // An equality test\n      case \"Eqs\":\n        var {a, b, d} = node[1];\n\n        // Gets whnfs with and without dereferencing\n        // Note: can't use weak:true because it won't give opportunity to eta...\n        var ax = reduce(a, {show: null, defs: opts.defs, weak: true, undup: true, defs: {}});\n        var bx = reduce(b, {show: null, defs: opts.defs, weak: true, undup: true, defs: {}});\n        var ay = reduce(a, {show: null, defs: opts.defs, weak: true, undup: true});\n        var by = reduce(b, {show: null, defs: opts.defs, weak: true, undup: true});\n\n        // Optimization: if hashes are equal, then a == b prematurely\n        if (a[2] === b[2] || ax[2] === bx[2] || ay[2] === by[2]) {\n          return Val(true);\n        }\n\n        // If non-deref whnfs are app and fields are equal, then a == b\n        var x = null;\n        if (ax[0] === \"Ref\" && bx[0] === \"Ref\" && ax[1].name === bx[1].name) {\n          x = Val(true);\n        } else if (ax[0] === \"App\" && bx[0] === \"App\") {\n          var func = Eqs(ax[1].func, bx[1].func, d);\n          var argm = Eqs(ax[1].argm, bx[1].argm, d);\n          x = Bop(false, func, argm);\n        }\n\n        // If whnfs are equal and fields are equal, then a == b\n        var y = null;\n        switch (ay[0] + \"-\" + by[0]) {\n          case \"Var-Var\": y = Val(ay[1].index === by[1].index); break;\n          case \"Typ-Typ\": y = Val(true); break;\n          case \"Tid-Tid\": y = Eqs(ay[1].expr, by[1].expr, d); break;\n          case \"Utt-Utt\": y = Eqs(ay[1].expr, by[1].expr, d); break;\n          case \"Utv-Utv\": y = Eqs(ay[1].expr, by[1].expr, d); break;\n          case \"Ute-Ute\": y = Eqs(ay[1].expr, by[1].expr, d); break;\n          case \"All-All\": y = And(And(Eqs(ay[1].bind, by[1].bind, d), Eqs(ay[1].body, by[1].body, d+1)), Val(ay[1].eras === by[1].eras)); break;\n          case \"Lam-Lam\": y = And(Eqs(ay[1].body, by[1].body, d+1), Val(ay[1].eras === by[1].eras)); break;\n          case \"App-App\": y = And(And(Eqs(ay[1].func, by[1].func, d), Eqs(ay[1].argm, by[1].argm, d)), Val(ay[1].eras === by[1].eras)); break;\n          case \"Box-Box\": y = Eqs(ay[1].expr, by[1].expr, d); break;\n          case \"Put-Put\": y = Eqs(ay[1].expr, by[1].expr, d); break;\n          case \"Tak-Tak\": y = Eqs(ay[1].expr, by[1].expr, d); break;\n          case \"Dup-Dup\": y = And(Eqs(ay[1].expr, by[1].expr, d), Eqs(ay[1].body, by[1].body, d+1)); break;\n          case \"Num-Num\": y = Val(true); break;\n          case \"Val-Val\": y = Val(ay[1].numb === by[1].numb); break;\n          case \"Op1-Op1\": y = And(Val(ay[1].func === by[1].func), And(Eqs(ay[1].num0, by[1].num0, d), Val(ay[1].num1[1].numb === ay[1].num1[1].numb))); break;\n          case \"Op2-Op2\": y = And(Val(ay[1].func === by[1].func), And(Eqs(ay[1].num0, by[1].num0, d), Eqs(ay[1].num1, by[1].num1, d))); break;\n          case \"Ite-Ite\": y = And(Eqs(ay[1].cond, by[1].cond, d), Eqs(ay[1].pair, by[1].pair, d)); break;\n          case \"Cpy-Cpy\": y = And(Eqs(ay[1].numb, by[1].numb, d), Eqs(ay[1].body, by[1].body, d+1)); break;\n          case \"Sig-Sig\": y = And(Eqs(ay[1].typ0, by[1].typ0, d), Eqs(ay[1].typ1, by[1].typ1, d+1)); break;\n          case \"Par-Par\": y = And(Eqs(ay[1].val0, by[1].val0, d), Eqs(ay[1].val1, by[1].val1, d)); break;\n          case \"Fst-Fst\": y = And(Eqs(ay[1].pair, by[1].pair, d), Val(ay[1].eras === by[1].eras)); break;\n          case \"Snd-Snd\": y = And(Eqs(ay[1].pair, by[1].pair, d), Val(ay[1].eras === by[1].eras)); break;\n          case \"Prj-Prj\": y = And(Eqs(ay[1].pair, by[1].pair, d), Eqs(ay[1].body, by[1].body, d+2)); break;\n          case \"Slf-Slf\": y = Eqs(ay[1].type, by[1].type, d+1); break;\n          case \"New-New\": y = Eqs(ay[1].expr, by[1].expr, d); break;\n          case \"Use-Use\": y = Eqs(ay[1].expr, by[1].expr, d); break;\n          case \"Log-Log\": y = Eqs(ay[1].expr, by[1].expr, d); break;\n          case \"Ann-Ann\": y = Eqs(ay[1].expr, by[1].expr, d); break;\n          default:\n            if (ay[0] === \"Hol\") {\n              y = Val(true);\n            } else if (by[0] === \"Hol\") {\n              y = Val(true);\n            } else {\n              y = Val(false);\n            }\n        }\n\n        return x ? Bop(true, x, y) : y;\n\n      // A binary operation (or / and)\n      case \"Bop\":\n        var {v, x, y} = node[1];\n        if (x[0] === \"Val\") {\n          return x[1].v === v ? Val(v) : y;\n        } else if (y[0] === \"Val\") {\n          return y[1].v === v ? Val(v) : x;\n        } else {\n          var X = step(x);\n          var Y = step(y);\n          return Bop(v, X, Y);\n        }\n\n      // A result value (true / false)\n      case \"Val\":\n        return node;\n    }\n  }\n\n  // Expands the search tree until it finds an answer\n  var tree = Eqs(erase(a), erase(b), d);\n  while (tree[0] !== \"Val\") {\n    var tree = step(tree);\n  }\n  return tree[1].v;\n}\n\n// :::::::::::::::::::\n// :: Type Checking ::\n// :::::::::::::::::::\n\nconst {marked_code, random_excuse} = __webpack_require__(/*! ./fm-error.js */ \"../formality/src/fm-error.js\");\n\n// Type-checks a term and returns both its type and its program (an erased\n// copy of the term with holes filled and adjustments made). Does NOT check\n// termination, so a well-typed term may be bottom. Use haltcheck for that.\n// typecheck : Term -> Term -> Opts -> [Term, Term]\nconst typecheck = (term, expect, opts = {}) => {\n  var type_memo  = {};\n  var hole_msg   = {};\n  var hole_depth = {};\n  var found_anns = [];\n\n  const pad_right = (len, chr, str) => {\n    while (str.length < len) {\n      str += chr;\n    }\n    return str;\n  };\n\n  const highlight = (str)  => {\n    return \"\\x1b[2m\" + str + \"\\x1b[0m\";\n  };\n\n  const ctx_new = null;\n\n  const ctx_ext = (name, term, type, eras, many, lvel, ctx) => {\n    return {name, term, type, eras, many, lvel, uses: 0, rest: ctx};\n  };\n\n  const ctx_get = (i, ctx, use) => {\n    if (i < 0) return null;\n    for (var k = 0; k < i; ++k) {\n      if (!ctx.rest) return null;\n      ctx = ctx.rest;\n    }\n    var got = {\n      name: ctx.name,\n      term: ctx.term ? shift(ctx.term, i + 1, 0) : Var(i),\n      type: shift(ctx.type, i + 1, 0),\n      eras: ctx.eras,\n      many: ctx.many,\n      uses: ctx.uses,\n      lvel: ctx.lvel,\n    };\n    if (use) {\n      ctx.uses += 1;\n    }\n    return got;\n  };\n\n  const ctx_str = (ctx) => {\n    var txt = [];\n    var idx = 0;\n    var max_len = 0;\n    for (var c = ctx; c !== null; c = c.rest) {\n      max_len = Math.max(c.name.length, max_len);\n    }\n    for (var c = ctx; c !== null; c = c.rest) {\n      var name = c.name;\n      var type = c.type;\n      var tstr = opts.show(reduce(type, {defs: {}, undup: true}) , ctx_names(c.rest));\n      txt.push(\"\\x1b[2m- \" + pad_right(max_len, \" \", c.name) + \" : \" + tstr + \"\\x1b[0m\");\n    }\n    return txt.reverse().join(\"\\n\");\n  };\n\n  const ctx_names = (ctx) => {\n    var names = [];\n    while (ctx !== null) {\n      names.push(ctx.name);\n      ctx = ctx.rest;\n    }\n    return names.reverse();\n  };\n\n\n  const ctx_cpy = ctx => {\n    if (ctx === null) {\n      return null;\n    } else {\n      return {\n        name: ctx.name,\n        term: ctx.term,\n        type: ctx.type,\n        eras: ctx.eras,\n        many: ctx.many,\n        uses: ctx.uses,\n        lvel: ctx.lvel,\n        rest: ctx_cpy(ctx.rest)\n      }\n    }\n  };\n\n  const ctx_subst = (ctx, term) => {\n    var vals = [];\n    for (var c = ctx, i = 0; c !== null; c = c.rest, ++i) {\n      vals.push(c.term ? shift(c.term, i + 1, 0) : Var(i));\n    }\n    var term = shift(term, vals.length, vals.length);\n    var term = subst_many(term, vals.reverse(), 0)\n    return term;\n  };\n\n  const weak_normal = (term) => {\n    return reduce(term, {defs: opts.defs, undup: true, weak: true});\n  };\n\n  const display_normal = (term) => {\n    return reduce(term, {defs: opts.defs, defs: {}, undup: true, weak: false});\n  };\n\n  const format = (ctx, term) => {\n    return opts.show ? highlight(opts.show(display_normal(term), ctx_names(ctx))) : \"?\";\n  };\n\n  // Checks and returns the type of a term\n  const typecheck = (term, expect, ctx = ctx_new, affine = true, lvel = 0) => {\n    const do_error = (str)  => {\n      var err_msg = \"\";\n      err_msg += \"[ERROR]\\n\" + str;\n      err_msg += \"\\n- When checking \" + format(ctx, term)\n      if (ctx !== null) {\n        err_msg += \"\\n- With context:\\n\" + ctx_str(ctx);\n      }\n      if (term[3]) {\n        err_msg += \"\\n- On line \" + (term[3].row+1) + \", col \" + (term[3].col) + \", file \\x1b[4m\" + term[3].file + \".fm\\x1b[0m:\";\n        err_msg += \"\\n\" + marked_code(term[3]);\n      }\n      throw err_msg;\n    };\n\n    const do_match = (a, b) => {\n      if (!equal(a, b, ctx_names(ctx).length, {show: opts.show, defs: opts.defs, hole_depth})) {\n        do_error(\"Type mismatch.\"\n          + \"\\n- Found type... \" + format(ctx, a)\n          + \"\\n- Instead of... \" + format(ctx, b));\n      }\n    };\n\n    if (expect) {\n      var expect_nf = weak_normal(expect);\n      if (expect[0] === \"Typ\" || expect[0] === \"Utt\") {\n        affine = false;\n      }\n    } else {\n      var expect_nf = null;\n    }\n\n    var ctx_arg = ctx_cpy(ctx);\n\n    var type;\n    switch (term[0]) {\n      case \"Var\":\n        var got = ctx_get(term[1].index, ctx, affine);\n        if (got) {\n          if (affine) {\n            if (got.eras) {\n              do_error(\"Use of erased variable `\" + got.name + \"` in proof-relevant position.\");\n            }\n            if (got.uses > 0 && !got.many) {\n              do_error(\"Use of affine variable `\" + got.name + \"` more than once in proof-relevant position.\");\n            }\n            if (got.lvel !== lvel) {\n              do_error(\"Use of variable `\" + got.name + \"` would change its level in proof-relevant position.\");\n            }\n          }\n          type = got.type;\n        } else {\n          do_error(\"Unbound variable.\");\n        }\n        break;\n      case \"Typ\":\n        type = Typ();\n        break;\n      case \"Tid\":\n        var expr_t = typecheck(term[1].expr, Typ(), ctx, false, lvel, [term, ctx]);\n        type = Typ();\n        break;\n      case \"Utt\":\n        if (expect_nf !== null && expect_nf[0] !== \"Typ\") {\n          do_error(\"The inferred type of an unrestricted type (example: \"\n            + format(ctx, Utt(Ref(\"A\"))) + \") isn't \"\n            + format(ctx, Typ())\n            + \".\\n- Inferred type is \" + format(ctx, expect_nf));\n        }\n        var expr_t = typecheck(term[1].expr, Typ(), ctx, false, lvel, [term, ctx]);\n        type = Typ();\n        break;\n      case \"Utv\":\n        if (expect_nf !== null && expect_nf[0] !== \"Utt\") {\n          do_error(\"The inferred type of an unrestricted term (example: \"\n            + format(ctx, Utv(Ref(\"x\")))\n            + \") isn't an unrestricted type (example: \"\n            + format(ctx, Utt(Ref(\"A\")))\n            + \").\\n- Inferred type is \"\n            + format(ctx, expect_nf));\n        }\n        var expr_t = expect_nf && expect_nf[0] === \"Utt\" ? expect_nf[1].expr : null;\n        var expr_t = typecheck(term[1].expr, expr_t, ctx, false, lvel, [term, ctx]);\n        type = Utt(expr_t);\n        break;\n      case \"Ute\":\n        if (affine) {\n          do_error(\"Attempted to unrestrict a term (ex: \"\n            + format(ctx, Ute(Ref(\"+x\")))\n            + \") in a proof-relevant position.\");\n        }\n        var expr_t = typecheck(term[1].expr, null, ctx, false, lvel, [term, ctx]);\n        var expr_t = weak_normal(expr_t);\n        if (expr_t[0] !== \"Utt\") {\n          do_error(\"Expected an unrestricted type (example: \"\n            + format(ctx, Utt(Ref(\"A\")))\n            + \").\\n- Found type... \"\n            + format(ctx, expr_t));\n        }\n        type = expr_t[1].expr;\n        break;\n      case \"All\":\n        if (expect_nf && expect_nf[0] !== \"Typ\") {\n          do_error(\"The inferred type of a forall (example: \"\n            + format(ctx, All(\"x\", Ref(\"A\"), Ref(\"B\"), false))\n            + \") isn't \"\n            + format(ctx, Typ())\n            + \".\\n- Inferred type is \"\n            + format(ctx, expect_nf));\n        }\n        var bind_t = typecheck(term[1].bind, Typ(), ctx, false, lvel, [term, ctx]);\n        var ex_ctx = ctx_ext(term[1].name, null, term[1].bind, term[1].eras, false, lvel, ctx);\n        var body_t = typecheck(term[1].body, Typ(), ex_ctx, false, lvel, [term, ctx]);\n        type = Typ();\n        break;\n      case \"Lam\":\n        var bind_v = expect_nf && expect_nf[0] === \"All\" ? expect_nf[1].bind : term[1].bind;\n        if (bind_v === null && expect_nf === null) {\n          do_error(\"Can't infer non-annotated lambda.\");\n        }\n        if (bind_v === null && expect_nf !== null) {\n          do_error(\"The inferred type of a lambda (example: \"\n            + format(ctx, Lam(\"x\",null,Ref(\"f\"),false))\n            + \") isn't forall (example: \"\n            + format(ctx, All(\"x\", Ref(\"A\"), Ref(\"B\"), false))\n            + \").\\n- Inferred type is \"\n            + format(ctx, expect_nf));\n        }\n        var bind_t = typecheck(bind_v, Typ(), ctx, false, lvel, ctx);\n        var ex_ctx = ctx_ext(term[1].name, null, bind_v, term[1].eras, false, lvel, ctx);\n        var body_t = typecheck(term[1].body, expect_nf && expect_nf[0] === \"All\" ? expect_nf[1].body : null, ex_ctx, affine, lvel, [term, ctx]);\n        var body_T = typecheck(body_t, Typ(), ex_ctx, false, lvel, ctx);\n        type = All(term[1].name, bind_v, body_t, term[1].eras);\n        break;\n      case \"App\":\n        var func_t = typecheck(term[1].func, null, ctx, affine, lvel, [term, ctx]);\n        var func_t = weak_normal(func_t);\n        if (func_t[0] !== \"All\") {\n          do_error(\"Attempted to apply a value that isn't a function.\");\n        }\n        var argm_t = typecheck(term[1].argm, func_t[1].bind, ctx, affine, lvel, [term, ctx]);\n        if (func_t[1].eras !== term[1].eras) {\n          do_error(\"Mismatched erasure.\");\n        }\n        type = subst(func_t[1].body, Ann(func_t[1].bind, term[1].argm, false), 0);\n        break;\n      case \"Box\":\n        if (expect_nf !== null && expect_nf[0] !== \"Typ\") {\n          do_error(\"The inferred type of a box (example: \"\n            + format(ctx, Box(Ref(\"A\")))\n            + \") isn't \"\n            + format(ctx, Typ())\n            + \".\\n- Inferred type is \"\n            + format(ctx, expect_nf));\n        }\n        var expr_t = typecheck(term[1].expr, Typ(), ctx, affine, lvel, [term, ctx]);\n        var expr_t = weak_normal(expr_t);\n        type = Typ();\n        break;\n      case \"Put\":\n        if (expect_nf !== null && expect_nf[0] !== \"Box\") {\n          do_error(\"The inferred type of a boxed value (example: \"\n            + format(ctx, Put(Ref(\"x\")))\n            + \") isn't a box (example: \"\n            + format(ctx, Box(Ref(\"A\")))\n            + \").\\n- Inferred type is \"\n            + format(ctx, expect_nf));\n        }\n        var expr_t = expect_nf && expect_nf[0] === \"Box\" ? expect_nf[1].expr : null;\n        var term_t = typecheck(term[1].expr, expr_t, ctx, affine, lvel + 1, [term, ctx]);\n        type = Box(term_t);\n        break;\n      case \"Tak\":\n        var expr_t = typecheck(term[1].expr, null, ctx, affine, lvel - 1, [term, ctx]);\n        var expr_t = weak_normal(expr_t);\n        if (expr_t[0] !== \"Box\") {\n          do_error(\"Expected a boxed type (example: \"\n            + format(ctx, Box(Ref(\"A\")))\n            + \").\\n- Found type... \"\n            + format(ctx, expr_t));\n        }\n        type = expr_t[1].expr;\n        break;\n      case \"Dup\":\n        var expr_t = typecheck(term[1].expr, null, ctx, affine, lvel, [term, ctx]);\n        var expr_t = weak_normal(expr_t);\n        if (expr_t[0] !== \"Box\") {\n          do_error(\"Expected a boxed type (example: \"\n            + format(ctx, Box(Ref(\"A\")))\n            + \").\\n- Found type... \"\n            + format(ctx, expr_t));\n        }\n        var ex_ctx = ctx_ext(term[1].name, Tak(term[1].expr), expr_t[1].expr, false, true, lvel + 1, ctx);\n        var body_t = typecheck(term[1].body, expect_nf && shift(expect_nf, 1, 0), ex_ctx, affine, lvel, [term, ctx]);\n        type = subst(body_t, Tak(term[1].expr), 0);\n        break;\n      case \"Num\":\n        type = Typ();\n        break;\n      case \"Val\":\n        type = Num();\n        break;\n      case \"Op1\":\n      case \"Op2\":\n        if (expect_nf !== null && expect_nf[0] !== \"Num\") {\n          do_error(\"The inferred type of a numeric operation (example: \"\n            + format(ctx, Op2(term[1].func, Ref(\"x\"), Ref(\"y\")))\n            + \") isn't \"\n            + format(ctx, Num())\n            + \".\\n- Inferred type is \"\n            + format(ctx, expect_nf));\n        }\n        var num0_t = typecheck(term[1].num0, Num(), ctx, affine, lvel, [term, ctx]);\n        var num1_t = typecheck(term[1].num1, Num(), ctx, affine, lvel, [term, ctx]);\n        type = Num();\n        break;\n      case \"Ite\":\n        var cond_t = typecheck(term[1].cond, null, ctx, affine, lvel, [term, ctx]);\n        var cond_t = weak_normal(cond_t);\n        if (cond_t[0] !== \"Num\") {\n          do_error(\"Attempted to use if on a non-numeric value.\");\n        }\n        var pair_t = expect_nf ? Sig(\"x\", expect_nf, shift(expect_nf, 1, 0), 0) : null;\n        var pair_t = typecheck(term[1].pair, pair_t, ctx, affine, lvel, [term, ctx]);\n        var pair_t = weak_normal(pair_t);\n        if (pair_t[0] !== \"Sig\") {\n          do_error(\"The body of an if must be a pair.\");\n        }\n        var typ0_v = pair_t[1].typ0;\n        var typ1_v = subst(pair_t[1].typ1, Typ(), 0);\n        if (!equal(typ0_v, typ1_v, ctx_names(ctx).length, {defs: opts.defs, hole_depth})) {\n          do_error(\"Both branches of if must have the same type.\");\n        }\n        type = expect_nf || typ0_v;\n        break;\n      case \"Cpy\":\n        var numb_t = typecheck(term[1].numb, null, ctx, affine, lvel, [term, ctx]);\n        var numb_t = weak_normal(numb_t);\n        if (numb_t[0] !== \"Num\") {\n          do_error(\"Atempted to copy a non-numeric value.\");\n        }\n        var ex_ctx = ctx_ext(term[1].name, term[1].numb, Num(), false, true, lvel, ctx);\n        var body_t = typecheck(term[1].body, expect_nf && shift(expect_nf, 1, 0), ex_ctx, affine, lvel, [term, ctx]);\n        type = subst(body_t, term[1].numb, 0);\n        break;\n      case \"Sig\":\n        if (expect_nf && expect_nf[0] !== \"Typ\") {\n          do_error(\"The inferred type of a sigma (example: \"\n            + format(ctx, Sig(\"x\", Ref(\"A\"), Ref(\"B\")))\n            + \") isn't \"\n            + format(ctx, Typ())\n            + \".\\n- Inferred type is \"\n            + format(ctx, expect_nf));\n        }\n        var typ0_t = typecheck(term[1].typ0, Typ(), ctx, false, lvel, [term, ctx]);\n        var ex_ctx = ctx_ext(term[1].name, null, term[1].typ0, false, false, lvel, ctx);\n        var typ1_t = typecheck(term[1].typ1, Typ(), ex_ctx, false, lvel, [term, ctx]);\n        type = Typ();\n        break;\n      case \"Par\":\n        if (expect_nf && expect_nf[0] !== \"Sig\") {\n          do_error(\"Inferred type of a pair (example: \"\n            + format(ctx, Par(Ref(\"a\"),Ref(\"b\")))\n            + \") isn't \"\n            + format(ctx, Sig(\"x\", Ref(\"A\"), Ref(\"B\")))\n            + \".\\n- Inferred type is \"\n            + format(ctx, expect_nf));\n        }\n        var val0_t = typecheck(term[1].val0, expect_nf && expect_nf[1].typ0, ctx, affine, lvel, [term, ctx]);\n        if (expect_nf) {\n          var val1_t = typecheck(term[1].val1, subst(expect_nf[1].typ1, term[1].val0, 0), ctx, affine, lvel, [term, ctx]);\n        } else {\n          var val1_t = typecheck(term[1].val1, null, ctx, affine, lvel, [term, ctx]);\n          var val1_t = shift(val1_t, 1, 0);\n        }\n        var eras = expect_nf ? expect_nf[1].eras : term[1].eras;\n        if (term[1].eras !== eras) {\n          do_error(\"Mismatched erasure.\");\n        }\n        type = expect_nf || Sig(\"x\", val0_t, val1_t, term[1].eras);\n        break;\n      case \"Fst\":\n        if (term[1].eras === 1) {\n          do_error(\"Attempted to extract erased first element.\");\n        }\n        var pair_t = typecheck(term[1].pair, null, ctx, affine, lvel, [term, ctx]);\n        var pair_t = weak_normal(pair_t);\n        if (pair_t[0] !== \"Sig\") {\n          do_error(\"Attempted to extract the first element of a term that isn't a pair.\");\n        }\n        if (term[1].eras !== pair_t[1].eras) {\n          do_error(\"Mismatched erasure.\");\n        }\n        type = pair_t[1].typ0;\n        break;\n      case \"Snd\":\n        if (term[1].eras === 2) {\n          do_error(\"Attempted to extract erased second element.\");\n        }\n        var pair_t = typecheck(term[1].pair, null, ctx, affine, lvel, [term, ctx]);\n        var pair_t = weak_normal(pair_t);\n        if (pair_t[0] !== \"Sig\") {\n          do_error(\"Attempted to extract the second element of a term that isn't a pair.\");\n        }\n        if (term[1].eras !== pair_t[1].eras) {\n          do_error(\"Mismatched erasure.\");\n        }\n        type = subst(pair_t[1].typ1, Fst(term[1].pair, term[1].eras), 0);\n        break;\n      case \"Prj\":\n        var pair_t = typecheck(term[1].pair, null, ctx, affine, lvel, [term, ctx]);\n        var pair_t = weak_normal(pair_t);\n        if (pair_t[0] !== \"Sig\") {\n          do_error(\"Attempted to project the elements of a term that isn't a pair.\");\n        }\n        if (term[1].eras !== pair_t[1].eras) {\n          do_error(\"Mismatched erasure.\");\n        }\n        var ex_ctx = ctx_ext(term[1].nam0, null, pair_t[1].typ0, pair_t[1].eras === 1, false, lvel, ctx);\n        var ex_ctx = ctx_ext(term[1].nam1, null, pair_t[1].typ1, pair_t[1].eras === 2, false, lvel, ex_ctx);\n        try {\n          var tp_ctx = ctx_cpy(ex_ctx);\n          var body_t = typecheck(term[1].body, shift(expect, 2, 0), tp_ctx, affine, lvel, [term, ctx]);\n          var ex_ctx = tp_ctx;\n        } catch (e) {\n          var tp_ctx = ctx_cpy(ex_ctx);\n          var body_t = typecheck(term[1].body, null, ex_ctx, affine, lvel, [term, ctx]);\n          var ex_ctx = tp_ctx;\n        }\n        type = subst(subst(body_t, Snd(shift(term[1].pair, 1, 0), term[1].eras), 0), Fst(term[1].pair, term[1].eras), 0);\n        break;\n      case \"Slf\":\n        var ex_ctx = ctx_ext(term[1].name, null, term, false, false, lvel, ctx);\n        var type_t = typecheck(term[1].type, Typ(), ex_ctx, false, lvel, [term, ctx]);\n        type = Typ();\n        break;\n      case \"New\":\n        var ttyp = weak_normal(term[1].type);\n        if (ttyp[0] !== \"Slf\") {\n          do_error(\"Attempted to make an instance of a type that isn't self.\");\n        }\n        var ttyp_t = typecheck(ttyp, null, ctx, false, lvel, [term, ctx]);\n        var expr_t = typecheck(term[1].expr, subst(ttyp[1].type, Ann(ttyp, term, true), 0), ctx, affine, lvel, [term, ctx]);\n        type = term[1].type;\n        break;\n      case \"Use\":\n        var expr_t = typecheck(term[1].expr, null, ctx, affine, lvel, [term, ctx]);\n        var expr_t = weak_normal(expr_t);\n        if (expr_t[0] !== \"Slf\") {\n          do_error(\"Attempted to use a value that isn't a self type.\");\n        }\n        type = subst(expr_t[1].type, term[1].expr, 0);\n        break;\n      case \"Ann\":\n        if (!term[1].done) {\n          term[1].done = true;\n          found_anns.push(term);\n          try {\n            var expr_t = typecheck(term[1].expr, term[1].type, ctx, affine, lvel, [term, ctx]);\n            //if (term[1].expr[0] === \"Ref\" && is_recursive((opts.defs||{})[term[1].expr[1].name], term[1].expr[1].name)) {\n              //do_error(\"Recursive occurrence of '\" + term[1].expr[1].name + \"'.\");\n            //}\n            type = term[1].type;\n          } catch (e) {\n            term[1].done = false;\n            throw e;\n          }\n        } else {\n          type = term[1].type;\n        }\n        break;\n      case \"Log\":\n        var msge_v = term[1].msge;\n        try {\n          var msge_t = typecheck(msge_v, null, ctx, false, lvel, [term, ctx]);\n          var msge_t = display_normal(erase(msge_t));\n        } catch (e) {\n          console.log(e);\n          var msge_t = Hol(\"\");\n        }\n        if (!opts.no_logs) {\n          console.log(\"[LOG]\");\n          console.log(\"Term: \" + opts.show(msge_v, ctx_names(ctx)));\n          console.log(\"Type: \" + opts.show(msge_t, ctx_names(ctx)) + \"\\n\");\n        }\n        var expr_t = typecheck(term[1].expr, expect, ctx, affine, lvel);\n        type = expr_t;\n        break;\n      case \"Hol\":\n        if (!hole_msg[term[1].name]) {\n          hole_msg[term[1].name] = {ctx, name: term[1].name, expect};\n          hole_depth[term[1].name] = ctx_names(ctx).length;\n        }\n        if (expect) {\n          type = expect;\n        } else {\n          throw new Error(\"Untyped hole.\");\n        }\n        break;\n      case \"Ref\":\n        if (!(opts.defs||{})[term[1].name]) {\n          do_error(\"Undefined reference: `\" + term[1].name + \"`.\");\n        } else if (!type_memo[term[1].name]) {\n          var dref_t = typecheck((opts.defs||{})[term[1].name], null, ctx, affine, lvel, [term, ctx]);\n          type_memo[term[1].name] = dref_t;\n        }\n        type = type_memo[term[1].name];\n        break;\n      default:\n        throw \"TODO: type checker for \" + term[0] + \".\";\n    }\n    if (expect) {\n      var type_nf = weak_normal(type);\n      // Fill an Utv\n      if (expect_nf[0] === \"Utt\" && type_nf[0] !== \"Utt\") {\n        return typecheck(Utv(term), expect_nf, ctx_arg, affine, lvel)\n      }\n      // Fill an Ute\n      if (expect_nf[0] !== \"Utt\" && type_nf[0] === \"Utt\") {\n        return typecheck(Ute(term), expect_nf, ctx_arg, affine, lvel)\n      }\n      // Check if inferred and expected types match\n      do_match(type_nf, expect_nf);\n    }\n    return type;\n  };\n\n  try {\n    // Type-checks the term\n    var type = typecheck(term, expect);\n\n    // Afterwards, prints hole msgs\n    for (var hole_name in hole_msg) {\n      var info = hole_msg[hole_name];\n      var msg = \"\";\n      msg += \"Found hole\" + (info.name ? \": '\" + info.name + \"'\" : \"\") + \".\\n\";\n      if (info.expect) {\n        msg += \"- With goal... \" + format(info.ctx, info.expect) + \"\\n\";\n      }\n      var cstr = ctx_str(info.ctx);\n      msg += \"- With context:\\n\" + (cstr.length > 0 ? cstr + \"\\n\" : \"\");\n      if (!opts.no_logs) {\n        console.log(msg);\n      }\n    }\n\n    // If so, normalize it to an user-friendly form and return\n    type = display_normal(type);\n\n    // Cleans side-effects\n    for (var i = 0; i < found_anns.length; ++i) {\n      found_anns[i][1].done = false;\n    }\n\n    return type;\n\n  // In case there is an error, adjust and throw\n  } catch (e) {\n    if (typeof e === \"string\") {\n      throw e;\n    } else {\n      console.log(e);\n      throw \"Sorry, the type-checker couldn't handle your input.\";\n    }\n  }\n};\n\n// Checks if a well-typed term terminates. Since well-typed terms must be\n// elementary affine, the only way they can fail to halt is through recursion.\n// This conservative check excludes any kind of recursion. Further work may be\n// done to identify and allow well-founded recursion.\nconst haltcheck = (term, defs, seen = {}) => {\n  switch (term[0]) {\n    case \"Utv\": return haltcheck(term[1].expr, defs, seen);\n    case \"Ute\": return haltcheck(term[1].expr, defs, seen);\n    case \"Lam\": return haltcheck(term[1].body, defs, seen);\n    case \"App\": return haltcheck(term[1].func, defs, seen) && (term[1].eras ? true : haltcheck(term[1].argm, defs, seen));\n    case \"Put\": return haltcheck(term[1].expr, defs, seen);\n    case \"Dup\": return haltcheck(term[1].expr, defs, seen) && haltcheck(term[1].body, defs, seen);\n    case \"Op1\": return haltcheck(term[1].num0, defs, seen) && haltcheck(term[1].num1, defs, seen);\n    case \"Op2\": return haltcheck(term[1].num0, defs, seen) && haltcheck(term[1].num1, defs, seen);\n    case \"Ite\": return haltcheck(term[1].cond, defs, seen) && haltcheck(term[1].pair, defs, seen);\n    case \"Cpy\": return haltcheck(term[1].numb, defs, seen) && haltcheck(term[1].body, defs, seen);\n    case \"Par\": return (term[1].eras === 1 ? true : haltcheck(term[1].val0, defs, seen)) && (term[1].eras === 2 ? true : haltcheck(term[1].val1, defs, seen));\n    case \"Fst\": return haltcheck(term[1].pair, defs, seen);\n    case \"Snd\": return haltcheck(term[1].pair, defs, seen);\n    case \"Prj\": return haltcheck(term[1].pair, defs, seen) && haltcheck(term[1].body, defs, seen);\n    case \"Ann\": return haltcheck(term[1].expr, defs, seen);\n    case \"New\": return haltcheck(term[1].expr, defs, seen);\n    case \"Use\": return haltcheck(term[1].expr, defs, seen);\n    case \"Log\": return haltcheck(term[1].expr, defs, seen);\n    case \"Ref\":\n      if (seen[term[1].name]) {\n        return false;\n      } else {\n        return haltcheck(defs[term[1].name], defs, {...seen, [term[1].name]: true});\n      }\n    default: return true;\n  }\n};\n\nmodule.exports = {\n  Var, Typ, Tid, Utt, Utv, Ute, All, Lam,\n  App, Box, Put, Tak, Dup, Num, Val, Op1,\n  Op2, Ite, Cpy, Sig, Par, Fst, Snd, Prj,\n  Slf, New, Use, Ann, Log, Hol, Ref,\n  equal,\n  erase,\n  reduce,\n  shift,\n  subst,\n  subst_many,\n  typecheck,\n  haltcheck,\n};\n\n\n//# sourceURL=webpack:///../formality/src/fm-core.js?");

/***/ }),

/***/ "../formality/src/fm-error.js":
/*!************************************!*\
  !*** ../formality/src/fm-error.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function marked_code(loc) {\n  var text = \"\";\n  var idx = 0;\n  var lines = loc.code.split(\"\\n\");\n  var from_line = Math.max(loc.row - 4, 0);\n  var to_line = Math.min(loc.row + 4, lines.length - 1);\n  for (var line = 0; line < lines.length; ++line) {\n    var write = line >= from_line && line <= to_line;\n    if (write) text += \"\\x1b[2m\" + (\"    \" + (line + 1)).slice(-4) + \"| \\x1b[0m\";\n    for (var i = 0; i < lines[line].length; ++i) {\n      if (idx >= loc.idx && idx < loc.idx + loc.len) {\n        if (write) text += \"\\x1b[31m\\x1b[4m\" + lines[line][i] + \"\\x1b[0m\";\n        idx += 1;\n      } else {\n        if (write) text += \"\\x1b[2m\" + lines[line][i] + \"\\x1b[0m\";\n        idx += 1;\n      }\n    }\n    if (write) text += \"\\n\";\n    idx += 1;\n  }\n  return text;\n}\n\nfunction random_excuse() {\n  var excuses = [\n    \"My parse-robot brain isn't perfect, sorry.\",\n    \"What? If you can't get this right, don't expect me to!\",\n    \"I'm doing my best, ok?\",\n    \"I hope you figure it out!\",\n    \"I can't help any further. But I can pray for you!\",\n    \"I with I could be more precise...\",\n    \"Hey, at least I'm showing a location.\",\n    \"Why programming needs to be so hard?\",\n    \"I hope this doesn't affect your deadlines!\",\n    \"If this is hard, consider relaxing. You deserve it!\",\n    \"It takes me some time to process things. Have patience with me!\"\n  ];\n  return excuses[Math.floor(Math.random() * excuses.length)];\n}\n\nmodule.exports = {marked_code, random_excuse};\n\n\n//# sourceURL=webpack:///../formality/src/fm-error.js?");

/***/ }),

/***/ "../formality/src/fm-json.js":
/*!***********************************!*\
  !*** ../formality/src/fm-json.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const lang = __webpack_require__(/*! ./fm-lang */ \"../formality/src/fm-lang.js\");\nconst to_js = __webpack_require__(/*! ./fm-to-js */ \"../formality/src/fm-to-js.js\");\nconst core = __webpack_require__(/*! ./fm-core */ \"../formality/src/fm-core.js\");\n\n// For now, we are converting the terms from and to JS-compiled Formality\n// In the future we may convert from and to directly the Formality Core AST\nconst to = (val) => to_js.decompile(json.to(val));\nconst from = (term) => json.from(to_js.compile(term));\n\nconst call = (term_or_name, defs, argument, opts = {}) => {\n  const term =\n    typeof term_or_name === 'string'\n      ? defs[term_or_name] || Ref(term_or_name)\n      : term_or_name;\n\n  lang.typecheck(term, json_to_json_type_term, defs);\n\n  const argument_term = to(argument);\n  const default_reducer = term => lang.run(\"OPTIMAL\", term, {defs});\n  const reducer = opts.reducer || default_reducer;\n  const app_term = lang.App(term, argument_term, false);\n  return from(reducer(app_term));\n}\n\n// A Mapper is responsible for mapping between JS and Formality types.\n// It's basically two functions, to and from. To converts from JS to FormalityJS and from does the\n// other way around.\n// Some mappers are polymorphic (for polymorphic types, for example). Here they are represented as\n// functions which return mappers.\n\nconst word = {\n  to: (x) => x,\n  from: (x) => x\n}\n\nconst js_number = {\n  to: (val) => (js_number) => js_number(val),\n  from: (enc) => enc\n}\n\nconst list = (type) => ({\n  to: (val) => (cons) => (nil) => (\n    val.length == 0\n      ? nil\n      : cons(type.to(val[0]))(list(type).to(val.slice(1)))\n  ),\n  from: (val) => {\n    const cons = (head) => (tail) => [type.from(head)].concat(list(type).from(tail))\n    const nil = []\n\n    return val(cons)(nil)\n  }\n})\n\nconst string = {\n  to: (str) => {\n    let bytes = Array.from(new TextEncoder(\"utf-8\").encode(str));\n    while (bytes.length % 4 !== 0) {\n      bytes.push(0);\n    }\n    const nums = new Uint32Array(new Uint8Array(bytes).buffer)\n    return list(word).to(nums)\n  },\n  from: (enc) => {\n    const nums = list(word).from(enc);\n    const bytes = new Uint8Array(new Uint32Array(nums).buffer)\n    const str = new TextDecoder(\"utf-8\").decode(bytes)\n    return str.replace(/\\0*$/, '')\n  }\n}\n\nconst pair = (tfst, tsnd) => ({\n  to: ([fst, snd]) => [tfst.to(fst), tsnd.to(snd)],\n  from: ([fst, snd]) => [tfst.from(fst), tsnd.from(snd)]\n})\n\n// This is the main mapper of this module, which enables converting almost all JS objects\nconst json = {\n  to: (val) => (j_null) => (j_number) => (j_string) => (j_list) => (j_object) => {\n    if(val === null) {\n      return j_null\n    } else if(typeof val === \"number\") {\n      return j_number(js_number.to(val))\n    } else if(typeof val === \"string\") {\n      return j_string(string.to(val))\n    } else if (Array.isArray(val)) {\n      return j_list(list(json).to(val))\n    } else {\n      return j_object(list(pair(string, json)).to(obj_to_kw(val)))\n    }\n  },\n  from: (enc) => {\n    const j_null = null\n    const j_number = js_number.from\n    const j_string = string.from\n    const j_list = list(json).from\n    const j_object = (o) => kw_to_obj(list(pair(string, json)).from(o))\n\n    return enc(j_null)(j_number)(j_string)(j_list)(j_object)\n  }\n}\n\n// Object to keyword list conversion\nconst obj_to_kw = (obj) => Object.keys(obj).map((key) => [key.toString(), obj[key]])\nconst kw_to_obj = (kw) => kw.reduce((obj, [k, v]) => ({[k]: v, ...obj}), {})\n\nmodule.exports = { to, from, native_to: json.to, native_from: json.from, call }\n\n\n//# sourceURL=webpack:///../formality/src/fm-json.js?");

/***/ }),

/***/ "../formality/src/fm-lang.js":
/*!***********************************!*\
  !*** ../formality/src/fm-lang.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// WARNING: here shall be dragons!\n// This is the parser for Formality-Lang. This is NOT fm-core, which is meant\n// to be small, elegant and portable. Instead, it is our user-facing language,\n// which is meant to be big and fully-featured, including several syntax-sugars\n// meant to make programming easier. As such, this file is complex and involves\n// hard transformations of terms, Bruijn-index shifts, crazy parsing flows.\n// You've been warned (:\n\nconst {\n  Var, Typ, Tid, Utt, Utv, Ute, All, Lam,\n  App, Box, Put, Tak, Dup, Num, Val, Op1,\n  Op2, Ite, Cpy, Sig, Par, Fst, Snd, Prj,\n  Slf, New, Use, Ann, Log, Hol, Ref,\n  reduce: core_reduce,\n  typecheck: core_typecheck,\n  haltcheck,\n  ctx_ext,\n  ctx_get,\n  ctx_names,\n  ctx_new,\n  ctx_str,\n  equal,\n  erase,\n  shift,\n  subst,\n  subst_many,\n} = __webpack_require__(/*! ./fm-core.js */ \"../formality/src/fm-core.js\");\n\nconst version = __webpack_require__(/*! ./../package.json */ \"../formality/package.json\").version;\nconst to_net = __webpack_require__(/*! ./fm-to-net.js */ \"../formality/src/fm-to-net.js\");\nconst to_js = __webpack_require__(/*! ./fm-to-js.js */ \"../formality/src/fm-to-js.js\");\nconst net = __webpack_require__(/*! ./fm-net.js */ \"../formality/src/fm-net.js\");\nconst {load_file} = __webpack_require__(/*! ./forall.js */ \"../formality/src/forall.js\");\nconst {marked_code, random_excuse} = __webpack_require__(/*! ./fm-error.js */ \"../formality/src/fm-error.js\");\n\n// :::::::::::::::::::::\n// :: Stringification ::\n// :::::::::::::::::::::\n\n// Converts a term to a string\nconst show = ([ctor, args], nams = [], opts = {}) => {\n  const print_output = (term) => {\n    try {\n      if (term[1].val0[1].numb === 0x53484f57) {\n        term = term[1].val1;\n        var nums = [];\n        while (term[1].body[1].body[0] !== \"Var\") {\n          term = term[1].body[1].body;\n          nums.push(term[1].func[1].argm[1].numb);\n          term = term[1].argm;\n        }\n        return new TextDecoder(\"utf-8\").decode(new Uint8Array(new Uint32Array(nums).buffer));\n      } else {\n        return null;\n      }\n    } catch (e) {\n      return null;\n    }\n  }\n  switch (ctor) {\n    case \"Var\":\n      var name = nams[nams.length - args.index - 1];\n      if (!name) {\n        return \"^\" + args.index;\n      } else {\n        var suff = \"\";\n        for (var i = 0; i < args.index; ++i) {\n          if (nams[nams.length - i - 1] === name) {\n            var suff = suff + \"^\";\n          }\n        }\n        return name + suff;\n      }\n    case \"Typ\":\n      return \"Type\";\n    case \"Tid\":\n      var expr = show(args.expr, nams, opts);\n      return \"&\" + expr;\n    case \"Utt\":\n      var expr = show(args.expr, nams, opts);\n      return \"-\" + expr;\n    case \"Utv\":\n      var expr = show(args.expr, nams, opts);\n      return \"%\" + expr;\n    case \"Ute\":\n      var expr = show(args.expr, nams, opts);\n      return \"+\" + expr;\n    case \"All\":\n      var term = [ctor, args];\n      var erase = [];\n      var names = [];\n      var types = [];\n      while (term[0] === \"All\") {\n        erase.push(term[1].eras);\n        names.push(term[1].name);\n        types.push(show(term[1].bind, nams.concat(names.slice(0,-1)), opts));\n        term = term[1].body;\n      }\n      var text = \"{\";\n      for (var i = 0; i < names.length; ++i) {\n        text += erase[i] ? \"~\" : \"\";\n        text += names[i] + (names[i].length > 0 ? \" : \" : \":\") + types[i];\n        text += i < names.length - 1 ? \", \" : \"\";\n      }\n      text += \"} -> \";\n      text += show(term, nams.concat(names), opts);\n      return text;\n    case \"Lam\":\n      var term = [ctor, args];\n      var erase = [];\n      var names = [];\n      var types = [];\n      while (term[0] === \"Lam\") {\n        erase.push(term[1].eras);\n        names.push(term[1].name);\n        types.push(term[1].bind && term[1].bind[0] !== \"Hol\" ? show(term[1].bind, nams.concat(names.slice(0,-1)), opts) : null);\n        term = term[1].body;\n      }\n      var text = \"{\";\n      for (var i = 0; i < names.length; ++i) {\n        text += erase[i] ? \"~\" : \"\";\n        text += names[i] + (types[i] !== null ? \" : \" + types[i] : \"\");\n        text += i < names.length - 1 ? \", \" : \"\";\n      }\n      text += \"} \";\n      text += show(term, nams.concat(names), opts);\n      return text;\n    case \"App\":\n      var text = \")\";\n      var term = [ctor, args];\n      while (term[0] === \"App\") {\n        text = (term[1].func[0] === \"App\" ? \", \" : \"\") + (term[1].eras ? \"~\" : \"\") + show(term[1].argm, nams, opts) + text;\n        term = term[1].func;\n      }\n      if (term[0] === \"Ref\" || term[0] === \"Var\" || term[0] === \"Tak\") {\n        var func = show(term, nams, opts);\n      } else {\n        var func = \"(\" + show(term,nams, opts) + \")\";\n      }\n      return func + \"(\" + text;\n    case \"Box\":\n      var expr = show(args.expr, nams, opts);\n      return \"!\" + expr;\n    case \"Put\":\n      var expr = show(args.expr, nams, opts);\n      return \"#\" + expr;\n    case \"Tak\":\n      var expr = show(args.expr, nams, opts);\n      return \"$\" + expr;\n    case \"Dup\":\n      var name = args.name;\n      var expr = show(args.expr, nams, opts);\n      if (args.body[0] === \"Var\" && args.body[1].index === 0) {\n        return \"$\" + expr;\n      } else {\n        var body = show(args.body, nams.concat([name]), opts);\n        return \"dup \" + name + \" = \" + expr + \"; \" + body;\n      }\n    case \"Num\":\n      return \"Num\";\n    case \"Val\":\n      return args.numb.toString();\n    case \"Op1\":\n    case \"Op2\":\n      var func = args.func;\n      var num0 = show(args.num0, nams, opts);\n      var num1 = show(args.num1, nams, opts);\n      return num0 + \" \" + func + \" \" + num1;\n    case \"Ite\":\n      var cond = show(args.cond, nams, opts);\n      var pair = show(args.pair, nams, opts);\n      return \"if \" + cond + \" \" + pair;\n    case \"Cpy\":\n      var name = args.name;\n      var numb = show(args.numb, nams, opts);\n      var body = show(args.body, nams.concat([name]), opts);\n      return \"cpy \" + name + \" = \" + numb + \"; \" + body;\n    case \"Sig\":\n      var term = [ctor, args];\n      var erase = [];\n      var names = [];\n      var types = [];\n      while (term[0] === \"Sig\") {\n        erase.push(term[1].eras);\n        names.push(term[1].name);\n        types.push(show(term[1].typ0, nams.concat(names.slice(0,-1)), opts));\n        term = term[1].typ1;\n      }\n      var text = \"[\";\n      for (var i = 0; i < names.length; ++i) {\n        text += erase[i] === 1 ? \"~\" : \"\";\n        text += names[i] + \" : \" + types[i];\n        text += erase[i] === 2 ? \" ~ \" : \", \";\n      }\n      text += show(term, nams.concat(names), opts);\n      text += \"]\";\n      return text;\n    case \"Par\":\n      var output;\n      var term  = [ctor, args];\n      var erase = [];\n      var terms = [];\n      while (term[0] === \"Par\") {\n        if (output = print_output(term)) {\n          break;\n        } else {\n          erase.push(term[1].eras);\n          terms.push(show(term[1].val0, nams, opts));\n          term = term[1].val1;\n        }\n      }\n      if (terms.length > 0) {\n        var text = \"[\";\n      } else {\n        var text = \"\";\n      }\n      for (var i = 0; i < terms.length; ++i) {\n        text += erase[i] === 1 ? \"~\" : \"\";\n        text += terms[i];\n        text += erase[i] === 2 ? \" ~ \" : \", \";\n      }\n      if (output) {\n        text += output;\n      } else {\n        text += show(term, nams, opts);\n      }\n      if (terms.length > 0) {\n        text += \"]\";\n      }\n      return text;\n    case \"Fst\":\n      var pair = show(args.pair, nams, opts);\n      switch (args.eras) {\n        case 0: return \"fst(\" + pair + \")\";\n        case 1: return \"~fst(\" + pair + \")\";\n        case 2: return \"fst~(\" + pair + \")\";\n        case 3: return \"~fst~(\" + pair + \")\";\n      }\n    case \"Snd\":\n      var pair = show(args.pair, nams, opts);\n      switch (args.eras) {\n        case 0: return \"snd(\" + pair + \")\";\n        case 1: return \"~snd(\" + pair + \")\";\n        case 2: return \"snd~(\" + pair + \")\";\n        case 3: return \"~snd~(\" + pair + \")\";\n      }\n    case \"Prj\":\n      var nam0 = args.nam0;\n      var nam1 = args.nam1;\n      var pair = show(args.pair, nams, opts);\n      var body = show(args.body, nams.concat([nam0, nam1]), opts);\n      var era1 = args.eras === 1 ? \"~\" : \"\";\n      var era2 = args.eras === 2 ? \"~\" : \"\";\n      return \"get [\" + era1 + nam0 + \",\" + era2 + nam1 + \"] = \" + pair + \"; \" + body;\n    case \"Slf\":\n      var name = args.name;\n      var type = show(args.type, nams.concat([name]), opts);\n      return \"${\" + name + \"} \" + type;\n    case \"New\":\n      var type = show(args.type, nams, opts);\n      var expr = show(args.expr, nams, opts);\n      return \"new(~\" + type + \") \" + expr;\n    case \"Use\":\n      var expr = show(args.expr, nams, opts);\n      return \"use(\" + expr + \")\";\n    case \"Ann\":\n      var expr = show(args.expr, nams, opts);\n      //var type = show(args.type, nams, opts);\n      //return \"\\n: \" + type + \"\\n= \" + expr;\n      return expr;\n    case \"Log\":\n      var expr = show(args.expr, nams, opts);\n      return expr;\n    case \"Hol\":\n      return \"?\" + args.name;\n    case \"Ref\":\n      return !opts.full_refs ? args.name.replace(new RegExp(\".*/\", \"g\"), \"\") : args.name;\n  }\n};\n\n// :::::::::::::\n// :: Parsing ::\n// :::::::::::::\n\n// Converts a string to a term\nconst parse = async (file, code, tokenify, loader = load_file, root = true, loaded = {}) => {\n  // Imports a local/global file, merging its definitions\n  async function do_import(import_file) {\n    if (import_file.indexOf(\"@\") === -1) {\n      local_imports[import_file] = true;\n    }\n    if (!loaded[import_file]) {\n      try {\n        var file_code = await loader(import_file);\n        loaded[import_file] = await parse(import_file, file_code, tokenify, loader, false, loaded);\n      } catch (e) {\n        throw e;\n      }\n    }\n    var {defs: file_defs\n      , unbx: file_unbx\n      , adts: file_adts\n      , open_imports: file_open_imports\n      } = loaded[import_file];\n    for (let term_path in file_defs) {\n      defs[term_path] = file_defs[term_path];\n    }\n    for (let term_path in file_unbx) {\n      unbx[term_path] = file_unbx[term_path];\n    }\n    for (let term_path in file_adts) {\n      adts[term_path] = file_adts[term_path];\n    }\n    for (let open_import in file_open_imports) {\n      open_imports[open_import] = true;\n    }\n    return true;\n  }\n\n  // Finds all imports with a given name\n  function find_name_in_imports(name) {\n    var found = [];\n    for (var open_import in open_imports) {\n      if (defs[open_import + \"/\" + name]) {\n        found.push(open_import + \"/\" + name);\n      }\n    }\n    return found;\n  }\n\n  // Returns current location\n  function loc(len = 1) {\n    return {idx: idx - len, col, row, len, file, code};\n  }\n\n  // Attempts to resolve a name into a full path\n  function ref_path(str) {\n    var result = (function () {\n      if (str.indexOf(\"/\") === -1) {\n        var [str_file, str_name] = [null, str];\n      } else {\n        var [str_file, str_name] = str.split(\"/\");\n      }\n      // If the reference includes the file...\n      if (str_file) {\n        // If it points to a qualified import, expand it\n        if (qual_imports[str_file]) {\n          return qual_imports[str_file] + \"/\" + str_name;\n        // Otherwise, return an undefined reference, as written\n        } else {\n          return str_file + \"/\" + str_name;\n        }\n      // Otherwise, if the reference is missing the file...\n      } else {\n        // If there is a local definition with that name, point to it\n        if (defs[file + \"/\" + str_name]) {\n          return file + \"/\" + str_name;\n        }\n        // Otherwise, if there are many defs with that name, it is ambiguous\n        var found = find_name_in_imports(str_name);\n        if (found.length > 1) {\n          var err_str = \"Ambiguous reference: '\" + str + \"' could refer to:\";\n          for (var i = 0; i < found.length; ++i) {\n            err_str += \"\\n- \" + found[i];\n          }\n          err_str += \"\\nType its full name to prevent this error.\";\n          error(err_str);\n        }\n        // Otherwise, if there is exactly 1 open def with that name, point to it\n        if (found.length === 1) {\n          return found[0];\n        }\n      }\n      // Otherwise, return an undefined reference to hte same file\n      return file + \"/\" + str_name;\n    })();\n    return result;\n  }\n\n  // Makes a ref given a name\n  function ref(str) {\n    return Ref(ref_path(str), false, loc(str.length));\n  }\n\n  // Attempts to make a `ref` to a known base-lib term\n  function base_ref(str) {\n    var path = ref_path(str);\n    if (defs[path]) {\n      return Ref(path, false, loc(str.length));\n    } else {\n      error(\"Attempted to use a syntax-sugar which requires `\" + str + \"` to be in scope, but it isn't.\\n\"\n          + \"To solve that, add `import Base@0` to the start of your file.\\n\"\n          + \"See http://docs.formality-lang.org/en/latest/language/Hello,-world!.html for more info.\");\n    }\n  }\n\n  // Defines a top-level term\n  function define(path, term) {\n    if (root) {\n      var name = path.replace(new RegExp(\"^[\\\\w.]*\\/\"), \"\");\n      var found = find_name_in_imports(name);\n      if (found.length > 0 || defs[ref_path(name)]) {\n        var err_str = \"Attempted to re-define '\" + name + \"', which is already defined\";\n        if (found.length > 0) {\n          err_str += \" as:\";\n          for (var i = 0; i < found.length; ++i) {\n            err_str += \"\\n- \" + found[i];\n          }\n        } else {\n          err_str += \" on this file.\";\n        }\n        error(err_str);\n      }\n    }\n    defs[path] = term;\n  }\n\n  // Creates a new hole name\n  function new_hole_name() {\n    return \"h\" + (hole_count++);\n  }\n\n  // Builds a lookup table\n  function build_charset(chars) {\n    var set = {};\n    for (var i = 0; i < chars.length; ++i) {\n      set[chars[i]] = 1;\n    }\n    return chr => set[chr] === 1;\n  }\n\n  // Some handy lookup tables\n  const is_native_op =\n    { \".+.\"   : 1\n    , \".-.\"   : 1\n    , \".*.\"   : 1\n    , \"./.\"   : 1\n    , \".%.\"   : 1\n    , \".**.\"  : 1\n    , \".&.\"   : 1\n    , \".|.\"   : 1\n    , \".^.\"   : 1\n    , \".~.\"   : 1\n    , \".>>>.\" : 1\n    , \".<<.\"  : 1\n    , \".>.\"   : 1\n    , \".<.\"   : 1\n    , \".==.\"  : 1};\n  const op_inits     = [\"<\", \">\", \".\", \"->\", \"=\"];\n  const is_op_init   = str => { for (var k of op_inits) if (str === k || str[0] === k) return str; return null; };\n  const is_name_char = build_charset(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_.-@/\");\n  const is_op_char   = build_charset(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_.-@+*/%^!<>=&|\");\n  const is_spacy     = build_charset(\" \\t\\n\\r;\");\n  const is_space     = build_charset(\" \");\n  const is_newline   = build_charset(\"\\n\");\n\n  // Advances the cursor 1 step forward\n  function next() {\n    if (tokens) {\n      tokens[tokens.length - 1][1] += code[idx];\n    }\n    if (is_newline(code[idx])) {\n      row += 1;\n      col = 0;\n    } else {\n      col += 1;\n    }\n    idx += 1;\n  }\n\n  // Advances the cursor until it finds a parseable char, skipping spaces and comments\n  function next_char(is_space = is_spacy) {\n    skip_spaces(is_space);\n    var head = code.slice(idx, idx + 2);\n    // Skips comments\n    while (head === \"//\" || head === \"/*\") {\n      // Single-line comments\n      if (head === \"//\") {\n        if (tokens) tokens.push([\"cmm\", \"\"]);\n        while (code[idx] !== \"\\n\" && idx < code.length) {\n          next();\n        }\n        next();\n      // Multi-line comments (docs)\n      } else {\n        if (tokens) tokens.push([\"doc\", \"\"]);\n        while (code.slice(idx, idx + 2) !== \"*/\" && idx < code.length) {\n          next();\n        }\n        next();\n        next();\n      }\n      if (tokens) tokens.push([\"txt\", \"\"]);\n      skip_spaces(is_space);\n      var head = code.slice(idx, idx + 2);\n    }\n  }\n\n  // Skips space chars\n  function skip_spaces(is_space = is_spacy) {\n    while (idx < code.length && is_space(code[idx])) {\n      next();\n    }\n  }\n\n  // Attempts to match a specific string\n  function match_here(string) {\n    if (code.slice(idx, idx + 2) === \"//\") {\n      return false;\n    } else {\n      var sliced = code.slice(idx, idx + string.length);\n      if (sliced === string) {\n        if (tokens) tokens.push([\"sym\", \"\"]);\n        for (var i = 0; i < string.length; ++i) {\n          next();\n        }\n        if (tokens) tokens.push([\"txt\", \"\"]);\n        return true;\n      }\n      return false;\n    }\n  }\n\n  // Skips spaces, calls `match_here`\n  function match(string, is_space = is_spacy) {\n    next_char(is_space);\n    return match_here(string);\n  }\n\n  // Attempts to match a character that is a valid operator initiator\n  function match_op_init(is_space = is_spacy) {\n    for (var i = 0; i < op_inits.length; ++i) {\n      var op_init = op_inits[i];\n      if (match(op_init, is_space)) {\n        return op_init;\n      }\n    };\n    return null;\n  };\n\n  // Throws a parse error at this location\n  function error(error_message) {\n    var part = \"\";\n    var text = \"\";\n    text += \"[PARSE-ERROR]\\n\";\n    text += error_message;\n    text += \"\\n\\nI noticed the problem on line \" + (row+1) + \", col \" + col + \", file \\x1b[4m\" + file + \".fm\\x1b[0m:\\n\\n\";\n    text += marked_code(loc());\n    text += \"\\nBut it could have happened a little earlier.\\n\";\n    text += random_excuse();\n    throw text;\n  }\n\n  // Constructs an Ind\n  function build_ind(name) {\n    if (!defs[\"*\"+name]) {\n      var numb = name === \"\" ? Math.pow(2,48) - 1 : Number(name);\n      var bits = numb.toString(2);\n      var bits = bits === \"0\" ? \"\" : bits;\n      var term = base_ref(\"base\");\n      for (var i = 0; i < bits.length; ++i) {\n        term = App(base_ref(\"twice\"), term, false);\n        if (bits[i] === \"1\") {\n          term = App(base_ref(\"step\"), term, false);\n        }\n      }\n      define(\"*\"+name, term);\n    }\n    return Ref(\"*\"+name, false, loc(name.length + 1));\n  }\n\n  // Parses an exact string, errors if it isn't there\n  function parse_exact(string) {\n    if (!match(string)) {\n      var text = \"\";\n      var part = \"\";\n      error(\"Expected '\" + string + \"', but found '\" + (code[idx] || \"(end of file)\") + \"' instead.\");\n    }\n  }\n\n  // Parses characters until `fn` is false\n  function parse_string_here(fn = is_name_char) {\n    var name = \"\";\n    while (idx < code.length && fn(code[idx])) {\n      name = name + code[idx];\n      next();\n    }\n    return name;\n  }\n\n  // Skips spaces and calls parse_string_here\n  function parse_string(fn = is_name_char) {\n    next_char();\n    return parse_string_here(fn);\n  }\n\n  // Parses an alphanumeric name\n  function parse_name() {\n    var op_init = null;\n    if (op_init = is_op_init(code[idx] + (code[idx+1] || \" \"))) {\n      match(op_init);\n      return op_init + parse_string_here(is_op_char);\n    } else {\n      return parse_string();\n    }\n  }\n\n  // Parses a term that demands a name\n  function parse_named_term(nams) {\n    // Parses matched term\n    var term = parse_term(nams);\n\n    // If no name given, attempts to infer it from term\n    if (match(\"as\")) {\n      var name = parse_string();\n    } else if (term[0] === \"Var\" && term[1].__name) {\n      var name = term[1].__name;\n    } else {\n      var name = \"self\";\n      //error(\"The term \\x1b[2m\" + show(term, nams) + \"\\x1b[0m requires an explicit name.\\n\"\n          //+ \"Provide it with the 'as' keyword. Example: \\x1b[2m\" + show(term, nams) + \" as x\\x1b[0m\");\n    }\n\n    return [name, term]\n  }\n\n  // Parses a variable, a reference, or numbers\n  function parse_atom(nams, ind_num = false) {\n    var term = null;\n    if (tokens) tokens.push([\"???\", \"\"]);\n    var name = parse_name();\n    var numb = Number(name);\n    if (name.length === 0 && !ind_num) {\n      next();\n      error(\"Unexpected symbol.\");\n    }\n    // Not a var but a number\n    if (!isNaN(numb)) {\n      // Inductive\n      if (ind_num) {\n        var term = build_ind(name);\n      // Number\n      } else {\n        var term = Val(numb, loc(name.length));\n      }\n      if (tokens) tokens[tokens.length - 1][0] = \"num\";\n    } else {\n      var skip = 0;\n      while (match_here(\"^\")) {\n        skip += 1;\n      }\n      for (var i = nams.length - 1; i >= 0; --i) {\n        if (nams[i] === name) {\n          if (skip === 0) break;\n          else skip -= 1;\n        }\n      }\n      if (i === -1) {\n        if (is_native_op[name]) {\n          term = Lam(\"x\", Num(), Lam(\"y\", Num(), Op2(name, Var(1), Var(0)), false), false);\n          if (tokens) tokens[tokens.length - 1][0] = \"nop\";\n        } else {\n          for (var mini in enlarge) {\n            if (name.slice(0, mini.length) === mini) {\n              var name = enlarge[mini] + name.slice(mini.length);\n              break;\n            }\n          }\n          term = Ref(ref_path(name), false, loc(name.length));\n          if (tokens) {\n            tokens[tokens.length - 1][0] = \"ref\";\n            tokens[tokens.length - 1][2] = term[1].name;\n          }\n        }\n      } else {\n        term = Var(nams.length - i - 1, loc(name.length));\n        term[1].__name = name;\n        if (tokens) tokens[tokens.length - 1][0] = \"var\";\n      }\n    }\n    if (tokens) tokens.push([\"txt\", \"\"]);\n    return term;\n  }\n\n  // Parses a grouping parens, `(...)`\n  function parse_parens(nams) {\n    if (match(\"(\")) {\n      var term = parse_term(nams);\n      var skip = parse_exact(\")\");\n      return term;\n    }\n  }\n\n  // Parses the type of types, `Type`\n  function parse_typ(nams) {\n    if (match(\"Type\")) {\n      return Typ(loc(4));\n    }\n  }\n\n  // Parses a type-level identity, `~A`\n  function parse_tid(nams) {\n    var init = idx;\n    if (match(\"&\")) {\n      var expr = parse_term(nams);\n      return Tid(expr, loc(idx - init));\n    }\n  }\n\n  // Parses an unrestricted type, `-A`\n  function parse_utt(nams) {\n    var init = idx;\n    if (match(\"-\")) {\n      var expr = parse_term(nams);\n      return Utt(expr, loc(idx - init));\n    }\n  }\n\n  // Parses an unrestricted term, `%t`\n  function parse_utv(nams) {\n    var init = idx;\n    if (match(\"%\")) {\n      var expr = parse_term(nams);\n      return Utv(expr, loc(idx - init));\n    }\n  }\n\n  // Parses an unrestricted elim, `+t`\n  function parse_ute(nams) {\n    var init = idx;\n    if (match(\"+\")) {\n      var expr = parse_term(nams);\n      return Ute(expr, loc(idx - init));\n    }\n  }\n\n  // Parses the `?scope?` utility\n  function parse_scope(nams) {\n    if (match(\"?scope?\")) {\n      console.log(\"Scope:\");\n      for (var i = 0; i < nams.length; ++i) {\n        console.log(\"- \" + nams[i]);\n      }\n      return parse_term(nams);\n    }\n  }\n\n  // Parses a hole, `?name`\n  function parse_hol(nams) {\n    var init = idx;\n    if (match(\"?\")) {\n      var name = parse_string_here();\n      if (name === \"\") {\n        name = new_hole_name();\n      }\n      if (used_hole_name[name]) {\n        error(\"Reused hole name: \" + name);\n      } else {\n        used_hole_name[name] = true;\n      }\n      return Hol(name, loc(idx - init));\n    }\n  }\n\n  // Parses a lambda `{x : A} t` or a forall `{x : A} -> B`\n  function parse_lam_or_all(nams) {\n    var init = idx;\n    if (match(\"{\")) {\n      var erass = [];\n      var names = [];\n      var types = [];\n      while (idx < code.length) {\n        var eras = match(\"~\");\n        var name = parse_string();\n        var type = match(\":\") ? parse_term(nams.concat(names)) : Hol(new_hole_name());\n        erass.push(eras);\n        names.push(name);\n        types.push(type);\n        if (match(\"}\")) break; else parse_exact(\",\");\n      }\n      var isall = match(\"->\");\n      var parsed = parse_term(nams.concat(names));\n      for (var i = names.length - 1; i >= 0; --i) {\n        var ctr = isall ? All : Lam;\n        parsed = ctr(names[i], types[i], parsed, erass[i], loc(idx - init));\n        if (isall && !types[i]) {\n          error(\"Parse error: invalid forall.\");\n        }\n      }\n      return parsed;\n    }\n  }\n\n  // Parses a duplication, `dup x = t; u`\n  function parse_dup(nams) {\n    var init = idx;\n    if (match(\"dup \")) {\n      var name = parse_string();\n      var skip = parse_exact(\"=\");\n      var expr = parse_term(nams);\n      var body = parse_term(nams.concat([name]));\n      return Dup(name, expr, body, loc(idx - init));\n    }\n  }\n\n  // Parses a boxed type, `!A`\n  function parse_box(nams) {\n    var init = idx;\n    if (match(\"!\")) {\n      var expr = parse_term(nams);\n      return Box(expr, loc(idx - init));\n    }\n  }\n\n  // Parses a boxed term, `#t`\n  function parse_put(nams) {\n    var init = idx;\n    if (match(\"#\")) {\n      var expr = parse_term(nams);\n      return Put(expr, loc(idx - init));\n    }\n  }\n\n  // Parses an unboxing, `^t`\n  function parse_tak(nams) {\n    var init = idx;\n    if (match(\"$\")) {\n      var expr = parse_term(nams);\n      return Tak(expr, loc(idx - init));\n    }\n  }\n\n  // Parses a let, `let x = t; u`\n  function parse_let(nams) {\n    if (match(\"let \")) {\n      var name = parse_string();\n      var skip = parse_exact(\"=\");\n      var copy = parse_term(nams);\n      var body = parse_term(nams.concat([name]));\n      return subst(body, copy, 0);\n    }\n  }\n\n  // Parses the type of numbers, `Number`\n  function parse_wrd(nams) {\n    if (match(\"Num\")) {\n      return Num(loc(4));\n    }\n  }\n\n  // Parses a string literal, `\"foo\"`\n  function parse_string_literal(nams) {\n    var init = idx;\n    if (match(\"\\\"\")) {\n      // Parses text\n      var text = \"\";\n      while (idx < code.length && code[idx] !== \"\\\"\") {\n        text += code[idx];\n        next();\n      }\n      next();\n      var bytes = [].slice.call(new TextEncoder(\"utf-8\").encode(text), 0);\n      while (bytes.length % 4 !== 0) {\n        bytes.push(0);\n      }\n      var nums = new Uint32Array(new Uint8Array(bytes).buffer);\n      var term = App(base_ref(\"nil\"), Num(), true);\n      for (var i = nums.length - 1; i >= 0; --i) {\n        var term = App(App(App(base_ref(\"cons\"), Num(), true), Val(nums[i]), false), term, false);\n      }\n      return Ann(base_ref(\"String\"), term, false, loc(idx - init));\n    }\n  }\n\n  // Parses a nat literal, `0n123`\n  function parse_nat_literal(nams) {\n    if (match(\"0n\")) {\n      var name = parse_string();\n      if (!defs[\"0n\" + name]) {\n        var numb = Number(name);\n        var term = base_ref(\"zero\");\n        for (var i = 0; i < numb; ++i) {\n          term = App(base_ref(\"succ\"), term, false);\n        }\n        define(\"0n\" + name, term);\n      }\n      return defs[\"0n\" + name];\n    }\n  }\n\n  // Parses an ind literal, `*123`\n  function parse_ind_literal(nams) {\n    if (match(\"*\")) {\n      var name = parse_string();\n      return build_ind(name);\n    }\n  }\n\n  // Parses an if-then-else, `if: t else: u`\n  function parse_ite(nams) {\n    var init = idx;\n    if (match(\"if \")) {\n      var cond = parse_term(nams);\n      var skip = match(\"then:\") || parse_exact(\":\");\n      var val0 = parse_term(nams);\n      var skip = parse_exact(\"else:\");\n      var val1 = parse_term(nams);\n      return Ite(cond, Par(val0, val1, 0), loc(idx - init));\n    }\n  }\n\n  // Parses a Number copy, `cpy x = t; u`\n  function parse_cpy(nams) {\n    var init = idx;\n    if (match(\"cpy \")) {\n      var name = parse_string();\n      var skip = parse_exact(\"=\");\n      var numb = parse_term(nams);\n      var body = parse_term(nams.concat([name]));\n      return Cpy(name, numb, body, loc(idx - init));\n    }\n  }\n\n  // Parses a sigma, `[x : A, P(x)]`, or a pair, `[t, u]`\n  function parse_sig_or_par(nams) {\n    function is_sigma(string) {\n      var i = idx;\n      while (i < code.length && (code[i] === \"~\" || code[i] === \" \") || is_name_char(code[i])) { ++i; }\n      while (i < code.length && is_space(code[i])) { ++i; }\n      return code[i] === \":\";\n    }\n    var init = idx;\n    if (match(\"[\")) {\n      if (match(\"]\")) {\n        error(\"Empty pair.\");\n      }\n      // Sigma\n      if (is_sigma()) {\n        var erass = [];\n        var names = [];\n        var types = [];\n        while (idx < code.length && is_sigma()) {\n          var era1 = match(\"~\");\n          var name = parse_string();\n          var skip = parse_exact(\":\");\n          var type = parse_term(nams.concat(names));\n          var era2 = match(\"~\");\n          erass.push(era1 ? 1 : era2 ? 2 : 0);\n          names.push(name);\n          types.push(type);\n          if (!era2) parse_exact(\",\");\n        }\n        var parsed = parse_term(nams.concat(names));\n        var skip = parse_exact(\"]\");\n        for (var i = names.length - 1; i >= 0; --i) {\n          var parsed = Sig(names[i], types[i], parsed, erass[i], loc(idx - init));\n        }\n      // Pair\n      } else {\n        var erass = [];\n        var terms = [];\n        while (idx < code.length) {\n          var era1 = match(\"~\");\n          var term = parse_term(nams);\n          var era2 = match(\"~\");\n          erass.push(era1 ? 1 : era2 ? 2 : 0);\n          terms.push(term);\n          if (match(\"]\")) break;\n          if (!era2) parse_exact(\",\");\n        }\n        var parsed = terms.pop();\n        for (var i = terms.length - 1; i >= 0; --i) {\n          var parsed = Par(terms[i], parsed, erass[i], loc(idx - init));\n        }\n      }\n      return parsed;\n    }\n  }\n\n  // Parses a fst accessor, `fst(t)`\n  function parse_fst(nams) {\n    var init = idx;\n    if (match(\"fst(\")) {\n      var eras = 0;\n    } else if (match(\"~fst(\")) {\n      var eras = 1;\n    } else if (match(\"fst~(\")) {\n      var eras = 2;\n    } else if (match(\"~fst~(\")) {\n      var eras = 3;\n    } else {\n      return;\n    }\n    var pair = parse_term(nams);\n    var skip = parse_exact(\")\");\n    return Fst(pair, eras, loc(idx - init));\n  }\n\n  // Parses a snd accessor, `snd(t)`\n  function parse_snd(nams) {\n    var init = idx;\n    if (match(\"snd(\")) {\n      var eras = 0;\n    } else if (match(\"~snd(\")) {\n      var eras = 1;\n    } else if (match(\"snd~(\")) {\n      var eras = 2;\n    } else if (match(\"~snd~(\")) {\n      var eras = 3;\n    } else {\n      return;\n    }\n    var pair = parse_term(nams);\n    var skip = parse_exact(\")\");\n    return Snd(pair, eras, loc(idx - init));\n  }\n\n  // Parses a projection, `get [x, y] = t`\n  function parse_get(nams) {\n    var init = idx;\n    if (match(\"get \")) {\n      var skip = parse_exact(\"[\");\n      var erass = [];\n      var names = [];\n      while (idx < code.length) {\n        var era1 = match(\"~\");\n        var name = parse_string();\n        var era2 = match(\"~\");\n        erass.push(era1 ? 1 : era2 ? 2 : 0);\n        names.push(name);\n        if (match(\"]\")) break;\n        if (!era2) parse_exact(\",\");\n      }\n      var skip = parse_exact(\"=\");\n      var pair = parse_term(nams);\n      var parsed = parse_term(nams.concat(names));\n      for (var i = names.length - 2; i >= 0; --i) {\n        var nam1 = names[i];\n        var nam2 = i === names.length - 2 ? names[i + 1] : \"aux\";\n        var expr = i === 0 ? pair : Var(0);\n        var body = i === 0 ? parsed : shift(parsed, 1, 2);\n        var parsed = Prj(nam1, nam2, expr, body, erass[i], loc(idx - init));\n      }\n      return parsed;\n    }\n  }\n\n  // Parses log, `log(t)`\n  function parse_log(nams) {\n    var init = idx;\n    if (match(\"log(\")) {\n      var msge = parse_term(nams);\n      var skip = parse_exact(\")\");\n      var expr = parse_term(nams);\n      return Log(msge, expr, loc(idx - init));\n    }\n  }\n\n  // Parses a self type, `$x P(x)`\n  function parse_slf(nams) {\n    var init = idx;\n    if (match(\"${\")) {\n      var name = parse_string();\n      var skip = parse_exact(\"}\");\n      var type = parse_term(nams.concat([name]));\n      return Slf(name, type, loc(idx - init));\n    }\n  }\n\n  // Parses a self intro, `new(A) t`\n  function parse_new(nams) {\n    var init = idx;\n    if (match(\"new(~\")) {\n      var type = parse_term(nams);\n      var skip = parse_exact(\")\");\n      var expr = parse_term(nams);\n      return New(type, expr, loc(idx - init));\n    }\n  }\n\n  // Parses a self elim, `%t`\n  function parse_use(nams) {\n    var init = idx;\n    if (match(\"use(\")) {\n      var expr = parse_term(nams);\n      var skip = parse_exact(\")\");\n      return Use(expr, loc(idx - init));\n    }\n  }\n\n  // Parses a case expression, `case/T | A => <term> | B => <term> : <term>`\n  function parse_case(nams) {\n    if (match(\"case/\")) {\n      // Parses ADT name\n      var adt_name = parse_string();\n\n      // Parses matched name, if available\n      var [term_name, term] = parse_named_term(nams);\n\n      // Finds ADT\n      if (!adt_name || !adts[ref_path(adt_name)]) {\n        error(\"Used case-syntax on undefined type `\" + (adt_name || \"?\") + \"`.\");\n      }\n      var {adt_name, adt_pram, adt_indx, adt_ctor} = adts[ref_path(adt_name)];\n\n      // Parses 'move' expressions\n      var moves = [];\n      while (match(\"+\")) {\n        var move_init = idx;\n        var [move_name, move_term] = parse_named_term(nams);\n        var move_skip = parse_exact(\":\");\n        var move_type = parse_term(nams\n          .concat(adt_indx.map(([name,type]) => term_name + \".\" + name))\n          .concat([term_name])\n          .concat(moves.map(([name,term,type]) => name)));\n        moves.push([move_name, move_term, move_type, loc(idx - init)]);\n      }\n\n      // Parses matched cases\n      var case_term = [];\n      var case_loc  = [];\n      for (var c = 0; c < adt_ctor.length; ++c) {\n        var init = idx;\n        var skip = parse_exact(\"|\");\n        var skip = parse_exact(adt_ctor[c][0]);\n        var skip = parse_exact(\"=>\");\n        var ctors = adt_ctor[c][1];\n        case_term[c] = parse_term(nams\n          .concat(adt_ctor[c][1].map(([name,type]) => term_name + \".\" + name))\n          .concat(moves.map(([name,term,type]) => name)));\n        for (var i = moves.length - 1; i >= 0; --i) {\n          case_term[c] = Lam(moves[i][0], null, case_term[c], false);\n        }\n        for (var i = 0; i < ctors.length; ++i) {\n          case_term[c] = Lam(term_name + \".\" + ctors[ctors.length - i - 1][0], null, case_term[c], ctors[ctors.length - i - 1][2]);\n        }\n        case_loc[c] = loc(idx - init);\n      }\n\n      // Parses matched motive\n      var moti_init = idx;\n      if (match(\":\")) {\n        var moti_term = parse_term(nams\n          .concat(adt_indx.map(([name,type]) => term_name + \".\" + name))\n          .concat([term_name])\n          .concat(moves.map(([name,term,type]) => name)));\n      } else {\n        moti_term = Hol(new_hole_name());\n      }\n      var moti_loc = loc(idx - moti_init);\n      for (var i = moves.length - 1; i >= 0; --i) {\n        var moti_term = All(moves[i][0], moves[i][2], moti_term, false, moves[i][3]);\n      }\n      var moti_term = Tid(moti_term, moti_loc);\n      var moti_term = Lam(term_name, null, moti_term, false, moti_loc);\n      for (var i = adt_indx.length - 1; i >= 0; --i) {\n        var moti_term = Lam(term_name + \".\" + adt_indx[i][0], null, moti_term, false, moti_loc);\n      }\n\n      // Builds the matched term using self-elim (\"Use\")\n      var targ = term;\n      var term = Use(term);\n      var term = App(term, moti_term, true, moti_loc);\n      for (var i = 0; i < case_term.length; ++i) {\n        var term = App(term, case_term[i], false, case_loc[i]);\n      }\n      for (var i = 0; i < moves.length; ++i) {\n        var term = App(term, moves[i][1], false, moves[i][3]);\n      }\n\n      return term;\n    }\n  }\n\n  // Parses a Number bitwise-not, `.!.(t)`\n  function parse_op2_not(nams) {\n    var init = idx;\n    if (match(\".!.(\")) {\n      var argm = parse_term(nams);\n      var skip = parse_exact(\")\");\n      return Op2(\".!.\", Val(0), argm, loc(idx - init));\n    }\n  }\n\n  // Parses an application to an Ind, `t*N`\n  function parse_app_ind(parsed, nams) {\n    var init = idx;\n    if (match_here(\"*\")) {\n      var term = parse_atom(nams, true);\n      return App(parsed, term, false, loc(idx - init));\n    }\n  }\n\n  // Parses an application, `f(x, y, z...)`\n  function parse_app(parsed, nams) {\n    var init = idx;\n    if (match(\"(\", is_space)) {\n      var term = parsed;\n      while (idx < code.length) {\n        if (match(\"_\")) {\n          var term = App(term, Hol(new_hole_name()), true, loc(idx - init));\n          if (match(\")\")) break;\n        } else {\n          var eras = match(\"~\");\n          var argm = parse_term(nams);\n          var term = App(term, argm, eras, loc(idx - init));\n          if (match(\")\")) break;\n          parse_exact(\",\");\n        }\n      }\n      return term;\n    }\n  }\n\n  // Parses a list literal, `A$[t, u, v, ...]`\n  function parse_list_literal(parsed, nams) {\n    var init = idx;\n    if (match(\"$\", is_space)) {\n      var type = parsed;\n      var list = [];\n      var skip = parse_exact(\"[\");\n      while (idx < code.length && !match(\"]\")) {\n        list.push(parse_term(nams));\n        if (match(\"]\")) break; else parse_exact(\",\");\n      }\n      var term = App(base_ref(\"nil\"), type, true, loc(idx - init));\n      for (var i = list.length - 1; i >= 0; --i) {\n        var term = App(App(App(base_ref(\"cons\"), type, true), list[i], false), term, false, loc(idx - init));\n      }\n      return term;\n    }\n  }\n\n  // Parses an annotation `t :: T`\n  function parse_ann(parsed, nams) {\n    var init = idx;\n    if (match(\"::\", is_space)) {\n      //if (match(\"Type\")) {\n        //return Tid(parsed);\n      //} else {\n        var type = parse_term(nams);\n        return Ann(type, parsed, false, loc(idx - init));\n      //}\n    }\n  }\n\n  // Parses operators, including:\n  // - Numeric operators: `t .+. u`, `t .*. u`, etc.\n  // - Arrow notation: `A -> B`\n  // - User-defined operators: `t .foo. u`\n  function parse_ops(parsed, nams) {\n    var init = idx;\n    var matched_op_init = null;\n    if (matched_op_init = match_op_init(is_space)) {\n      if (tokens) tokens.pop();\n      var func = matched_op_init + parse_string_here(x => !is_space(x));\n      if (tokens) tokens.push([\"txt\", \"\"]);\n      var argm = parse_term(nams);\n      if (is_native_op[func]) {\n        return Op2(func, parsed, argm, loc(idx - init));\n      } else if (func === \"->\") {\n        return All(\"\", parsed, shift(argm, 1, 0), false, loc(idx - init));\n      } else {\n        return App(App(ref(func), parsed, false), argm, false, loc(idx - init));\n      }\n    }\n  }\n\n  // Parses a free variable\n  function parse_var(nams) {\n    var init = idx;\n    if (match(\"^\")) {\n      var idx = Number(parse_name());\n      return Var(idx, loc(idx - init));\n    }\n  }\n\n  // Parses a term\n  function parse_term(nams) {\n    var parsed;\n\n    // Parses base term\n    if (parsed = parse_parens(nams));\n    else if (parsed = parse_typ(nams));\n    else if (parsed = parse_tid(nams));\n    else if (parsed = parse_slf(nams));\n    else if (parsed = parse_new(nams));\n    else if (parsed = parse_use(nams));\n    else if (parsed = parse_scope(nams));\n    else if (parsed = parse_hol(nams));\n    else if (parsed = parse_lam_or_all(nams));\n    else if (parsed = parse_dup(nams));\n    else if (parsed = parse_box(nams));\n    else if (parsed = parse_put(nams));\n    else if (parsed = parse_tak(nams));\n    else if (parsed = parse_let(nams));\n    else if (parsed = parse_wrd(nams));\n    else if (parsed = parse_string_literal(nams));\n    else if (parsed = parse_nat_literal(nams));\n    else if (parsed = parse_ind_literal(nams));\n    else if (parsed = parse_ite(nams));\n    else if (parsed = parse_cpy(nams));\n    else if (parsed = parse_sig_or_par(nams));\n    else if (parsed = parse_fst(nams));\n    else if (parsed = parse_snd(nams));\n    else if (parsed = parse_get(nams));\n    else if (parsed = parse_utt(nams));\n    else if (parsed = parse_utv(nams));\n    else if (parsed = parse_ute(nams));\n    else if (parsed = parse_log(nams));\n    else if (parsed = parse_case(nams));\n    else if (parsed = parse_op2_not(nams));\n    else if (parsed = parse_var(nams));\n    else     parsed = parse_atom(nams, false);\n\n    // Parses glued operators\n    var new_parsed = parse_app_ind(parsed, nams);\n    if (new_parsed) {\n      parsed = new_parsed;\n    }\n\n    // Parses spaced operators\n    var new_parsed = true;\n    while (new_parsed) {\n      if      (new_parsed = parse_app(parsed, nams));\n      else if (new_parsed = parse_list_literal(parsed, nams));\n      else if (new_parsed = parse_ann(parsed, nams));\n      else if (new_parsed = parse_ops(parsed, nams));\n      if (new_parsed) {\n        parsed = new_parsed;\n      }\n    }\n\n    return parsed;\n  }\n\n  // Parses a top-level alias\n  async function do_parse_alias() {\n    if (match(\"alias\")) {\n      var full = parse_string();\n      var skip = parse_exact(\"as\");\n      var mini = parse_string();\n      enlarge[mini] = full;\n      return true;\n    }\n  }\n\n  // Parses a top-level import\n  async function do_parse_import() {\n    if (match(\"import \")) {\n      if (tokens) tokens.push([\"imp\", \"\"]);\n      var impf = parse_string();\n      if (tokens) tokens.push([\"txt\", \"\"]);\n      var qual = match(\"as\") ? parse_string() : null;\n      var open = match(\"open\");\n      if (open) {\n        error(\"The `open` keyword is obsolete. Remove it.\");\n      }\n      if (qual) qual_imports[qual] = impf;\n      qual_imports[impf] = impf;\n      open_imports[impf] = true;\n      await do_import(impf);\n      return true;\n    }\n  }\n\n  // Parses a top-level datatype:\n  // T name {param0 : A, ...} (index0 : B, ...)\n  // | ctor0 {field0 : C, ...} (index0, ...)\n  // | ctor1 {field0 : C, ...} (index0, ...)\n  async function do_parse_datatype() {\n    if (match(\"T \")) {\n      var adt_pram = [];\n      var adt_indx = [];\n      var adt_ctor = [];\n      var adt_name = parse_string();\n      var adt_nams = [adt_name];\n      var adt_typs = [null];\n\n      // Datatype parameters\n      if (match(\"{\")) {\n        while (idx < code.length) {\n          var eras = false;\n          var name = parse_string();\n          if (match(\":\")) {\n            var type = await parse_term(adt_pram.map((([name,type]) => name)));\n          } else {\n            var type = Hol(new_hole_name());\n          }\n          adt_pram.push([name, type, eras]);\n          if (match(\"}\")) break; else parse_exact(\",\");\n        }\n      }\n\n      // Datatype indices\n      var adt_nams = adt_nams.concat(adt_pram.map(([name,type]) => name));\n      var adt_typs = adt_typs.concat(adt_pram.map(([name,type]) => type));\n      if (match(\"(\")) {\n        while (idx < code.length) {\n          //var eras = match(\"~\");\n          var eras = false;\n          var name = parse_string();\n          if (match(\":\")) {\n            var type = await parse_term(adt_nams.concat(adt_indx.map((([name,type]) => name))));\n          } else {\n            var type = Hol(new_hole_name());\n          }\n          adt_indx.push([name, type, eras]);\n          if (match(\")\")) break; else parse_exact(\",\");\n        }\n      }\n\n      // Datatype constructors\n      while (match(\"|\")) {\n        // Constructor name\n        var ctor_name = parse_string();\n        // Constructor fields\n        var ctor_flds = [];\n        if (match(\"{\")) {\n          while (idx < code.length) {\n            var eras = match(\"~\");\n            var name = parse_string();\n            if (match(\":\")) {\n              var type = await parse_term(adt_nams.concat(ctor_flds.map(([name,type]) => name)));\n            } else {\n              var type = Hol(new_hole_name());\n            }\n            ctor_flds.push([name, type, eras]);\n            if (match(\"}\")) break; else parse_exact(\",\");\n          }\n        }\n        // Constructor type (written)\n        if (match(\":\")) {\n          var ctor_type = await parse_term(adt_nams.concat(ctor_flds.map(([name,type]) => name)));\n        // Constructor type (auto-filled)\n        } else {\n          var ctor_indx = [];\n          if (match(\"(\")) {\n            while (idx < code.length) {\n              ctor_indx.push(await parse_term(adt_nams.concat(ctor_flds.map(([name,type]) => name))));\n              if (match(\")\")) break; else parse_exact(\",\");\n            }\n          }\n          var ctor_type = Var(-1 + ctor_flds.length + adt_pram.length + 1);\n          for (var p = 0; p < adt_pram.length; ++p) {\n            ctor_type = App(ctor_type, Var(-1 + ctor_flds.length + adt_pram.length - p), false);\n          }\n          for (var i = 0; i < ctor_indx.length; ++i) {\n            ctor_type = App(ctor_type, ctor_indx[i], false);\n          }\n        }\n        adt_ctor.push([ctor_name, ctor_flds, ctor_type]);\n      }\n      var adt = {adt_pram, adt_indx, adt_ctor, adt_name};\n      define(file+\"/\"+adt_name, derive_adt_type(file, adt));\n      for (var c = 0; c < adt_ctor.length; ++c) {\n        define(file+\"/\"+adt_ctor[c][0], derive_adt_ctor(file, adt, c));\n      }\n      adts[file+\"/\"+adt_name] = adt;\n\n      return true;\n    }\n  }\n\n  // Parses a top-level `?defs` util\n  async function do_parse_defs_util() {\n    if (match(\"?defs\")) {\n      var filt = match(\"/\") ? parse_string(x => x !== \"/\") : \"\";\n      var regx = new RegExp(filt, \"i\");\n      console.log(\"Definitions:\");\n      for (var def in defs) {\n        if (def[0] !== \"$\" && regx.test(def)) {\n          console.log(\"- \" + def);\n        }\n      }\n      return true;\n    }\n  }\n\n  // Parses a top-level definition, including:\n  //\n  // - Untyped definitions:\n  //\n  //   name <term>\n  //\n  // - Typed definitions:\n  //\n  //    name : {arg0 : A, arg1 : B, ...} -> RetType\n  //      <term>\n  //\n  // - Boxed definitions:\n  //\n  //    #name : {par0 : T, par1 : U} -> !{arg0 : A, arg1 : B} -> RetType\n  //      <term>\n  //\n  // - Recursive definitions:\n  //\n  //    #name*N : {par0 : T, par1 : U} -> !{arg0 : A, arg1 : B} -> RetType\n  //      <term>\n  //    halt: <term>\n  //\n  // - Cased arguments:\n  //\n  //    name : {case arg0 : A, case arg1 : B} -> RetType\n  //    | Aa Ba => <term>\n  //    | Aa Bb => <term>\n  //    | Ab Ba => <term>\n  //    | Ab Bb => <term>\n  //\n  // And so on...\n  async function do_parse_def() {\n    // Parses box annotation\n    var boxed = match(\"#\");\n\n    // Parses definition name\n    if (tokens) tokens.push([\"def\", \"\"]);\n    var name = parse_name();\n\n    if (name.length === 0) {\n      error(\"Expected a definition.\");\n    }\n    if (tokens) tokens[tokens.length - 1][2] = file+\"/\"+name;\n    if (tokens) tokens.push([\"txt\", \"\"]);\n\n    // If name is empty, stop\n    if (name.length === 0) return false;\n\n    // Parses recursion depth name\n    var recur     = match_here(\"*\");\n    var rec_depth = recur ? parse_string() : null;\n    var rec_idx_n = recur ? [rec_depth] : [];\n    var rec_names = recur ? [name] : [];\n\n    var typed = match(\":\");\n\n    // Typed definition\n    if (typed) {\n\n      // Parses level 0 argument names and types\n      var lv0_erass = [];\n      var lv0_names = [];\n      var lv0_boxed = [];\n      var lv0_dup_n = [];\n      var lv0_dup_t = [];\n      var lv0_dup_i = [];\n      var lv0_types = [];\n      if (boxed && match(\"{\")) {\n        var count = 0;\n        while (idx < code.length) {\n          var arg_eras = match(\"~\");\n          var arg_name = parse_string();\n          if (match(\":\")) {\n            var arg_boxd = match(\"!\");\n            var arg_type = await parse_term(lv0_names);\n          } else {\n            var arg_boxd = false;\n            var arg_type = Hol(new_hole_name());\n          }\n          lv0_erass.push(arg_eras);\n          lv0_names.push(arg_name);\n          lv0_boxed.push(arg_boxd);\n          if (arg_boxd) {\n            lv0_dup_n.push(arg_name);\n            lv0_dup_t.push(null);\n            lv0_dup_i.push(count);\n          }\n          lv0_types.push(arg_type);\n          if (match(\"}\")) break; else parse_exact(\",\");\n          ++count;\n        }\n        var skip = parse_exact(\"->\");\n      }\n\n      // Parses extra level_0 duplications\n      var lv0_imp_n = [];\n      var lv0_imp_t = [];\n      var lv0_imp_v = [];\n      while (match(\"dup \")) {\n        var dup_name = parse_string();\n        var dup_skip = parse_exact(\"=\");\n        var dup_expr = parse_term(lv0_names.concat(lv0_imp_n));\n        lv0_imp_n.push(dup_name);\n        lv0_imp_t.push(null);\n        lv0_imp_v.push(dup_expr);\n      }\n\n      // Checks if it is properly boxed\n      if ((recur || boxed) && !match(\"!\")) {\n        error((recur ? \"Recursive definition\" : \"Definition\") + \" `\" + name + \"` must be boxed. Annotate its type with a `!`.\");\n      }\n\n      // Parses argument names and types\n      var erass = [];\n      var names = [];\n      var projs = [];\n      var keeps = [];\n      var wordn = [];\n      var wordt = [];\n      var wordi = [];\n      var types = [];\n      var basex = null;\n      if (match(\"{\")) {\n        var count = 0;\n        while (idx < code.length) {\n          var arg_proj = match(\"case \");\n          var arg_eras = match(\"~\");\n          var arg_halt = match(\"halt\");\n          var arg_name = parse_string();\n          if (match(\":\")) {\n            var arg_type = await parse_term(lv0_names.concat(lv0_dup_n).concat(lv0_imp_n).concat(rec_idx_n).concat(names));\n          } else {\n            var arg_type = Hol(new_hole_name());\n          }\n          erass.push(arg_eras);\n          names.push(arg_name);\n          types.push(arg_type);\n          basex = arg_halt ? count : basex;\n          if (arg_proj) {\n            projs.push(count);\n          } else if (!arg_eras) {\n            keeps.push(count);\n          }\n          if (arg_type[0] === \"Num\") {\n            wordn.push(arg_name);\n            wordt.push(Num());\n            wordi.push(count);\n          };\n          if (match(\"}\")) break; else parse_exact(\",\");\n          ++count;\n        }\n        var skip = parse_exact(\"->\");\n      }\n      var type = await parse_term(lv0_names.concat(lv0_dup_n).concat(lv0_imp_n).concat(rec_idx_n).concat(names));\n\n      // Parses the definition body\n      var body_nams = lv0_names.concat(lv0_dup_n).concat(lv0_imp_n).concat(rec_idx_n).concat(rec_names).concat(names);\n\n      // Case-tree syntax\n      if (projs.length > 0) {\n\n        // Finds the ADTs from annotated types\n        var proj_adts = [];\n        for (var i = 0; i < projs.length; ++i) {\n          var proj_type = types[projs[i]];\n          while (proj_type[0] === \"App\") {\n            proj_type = erase(proj_type[1].func);\n          }\n          var adt_name = proj_type[0] === \"Ref\" ? ref_path(proj_type[1].name) : null;\n          if (adts[adt_name]) {\n            proj_adts[i] = adts[adt_name];\n          } else {\n            error(\"Couldn't find the datatype of the `\" + names[projs[i]] + \"` argument of the `\" + name + \"` function.\\n\"\n                + \"This is a language limitation. Consider removing type alises, or using the case expression instead.\");\n          }\n        }\n\n        // Builds the objects for each proj\n        var proj_names = [];\n        var proj_terms = [];\n        var proj_types = [];\n        var proj_infos = [];\n        for (var i = 0; i < projs.length; ++i) {\n          proj_infos[i] = {\n            name: names[projs[i]],\n            orig: Var(-1 + names.length - projs[i]),\n            term: Var(-1 + names.length - projs[i]),\n            type: shift(types[projs[i]], names.length - projs[i], 0),\n            adt: proj_adts[i]\n          };\n        }\n\n        // Builds the objects for each keep\n        var keep_infos = [];\n        if (recur) {\n          var moti_type = ref(name + \".moti\");\n          for (var i = 0; i < lv0_names.length; ++i) {\n            var moti_type = App(moti_type, Var(-1 + names.length + rec_names.length + rec_idx_n.length + lv0_imp_n.length + lv0_dup_n.length + lv0_names.length - i), false);\n          }\n          var moti_type = App(moti_type, Ute(Var(-1 + names.length + rec_names.length + rec_idx_n.length)), false);\n          keep_infos.push({\n            name: name,\n            orig: Var(-1 + names.length + rec_names.length),\n            term: Var(-1 + names.length + rec_names.length),\n            type: moti_type\n          });\n        }\n        for (var i = 0; i < keeps.length; ++i) {\n          keep_infos.push({\n            name: names[keeps[i]],\n            orig: Var(-1 + names.length - keeps[i]),\n            term: Var(-1 + names.length - keeps[i]),\n            type: shift(shift(types[keeps[i]], names.length - keeps[i], 0), recur ? 1 : 0, names.length)\n          });\n        }\n\n        // Builds the initial motive\n        var moti = type;\n        var moti = shift(moti, rec_idx_n.length, names.length); // Adds recur variable\n        if (recur) { // Adjusts recur index to step(n)\n          var moti = replace(names.length + rec_names.length + rec_idx_n.length - 1, App(ref(\"step\"), Ute(Var(names.length + 1)), false), moti);\n        }\n\n        // Builds the case-tree by matching projected terms\n        var term = await (async function parse_case_tree(idx, projs, keeps, moti, branch, nams) {\n          // We still have values to project\n          if (idx < projs.length) {\n\n            // Gets the projected dataype\n            var {adt_name, adt_pram, adt_indx, adt_ctor} = projs[idx].adt;\n            if (adt_indx.length > 0) {\n              error(\"The case argument syntax isn't compatible with the indexed datatype '\" + adt_name + \"' yet.\\n\"\n                  + \"Use a case expression to write the body of the '\" + name + \"' function instead.\");\n            }\n\n            // Builds the application motive\n            var term_moti = shift(moti, adt_indx.length + 1 + projs.length - (idx + 1) + keeps.length, 0);\n            for (var i = keeps.length - 1; i >= 0; --i) {\n              var term_moti = All(keeps[i].name, shift(keeps[i].type, 1 + projs.length - (idx + 1) + i, 0), term_moti, false);\n            }\n            for (var i = projs.length - 1; i > idx; --i) {\n              var term_moti = replace(projs[i].orig[1].index + 1 + i - (idx + 1) + 1, Var(0), term_moti);\n              var term_moti = All(projs[i].name, shift(projs[i].type, 1 + i - (idx + 1), 0), term_moti, false);\n            }\n            var term_moti = Tid(term_moti);\n            var term_moti = replace(projs[i].orig[1].index + 1, Var(0), term_moti);\n            var term_moti = Lam(projs[idx].name, null, term_moti, false);\n\n            // Builds the application term\n            var term = Use(projs[idx].term);\n            var term = App(term, term_moti, true);\n\n            // Builds each applied case\n            for (var ctor_n = 0; ctor_n < adt_ctor.length; ++ctor_n) {\n              // Adjusts scope to enter case\n              var fldn = adt_ctor[ctor_n][1].map((([name,type,eras]) => projs[idx].name + \".\" + name));\n              var fldt = adt_ctor[ctor_n][1].map((([name,type,eras]) => type));\n              var prjn = projs.slice(idx + 1).map(({name}) => name);\n              var kepn = keeps.map(({name}) => name);\n              var newn = [].concat(fldn).concat(prjn).concat(kepn);\n\n              // Adjusts keeps to enter case\n              var new_keeps = [];\n              for (var i = 0; i < keeps.length; ++i) {\n                new_keeps.push({\n                  name: keeps[i].name,\n                  term: Var(-1 + keeps.length - i),\n                  orig: shift(keeps[i].orig, newn.length, 0),\n                  type: shift(keeps[i].type, newn.length, 0)\n                });\n              }\n\n              // Adjusts projs to enter case\n              var new_projs = [];\n              for (var i = 0; i < projs.length; ++i) {\n                new_projs.push({\n                  name: projs[i].name,\n                  term: i < idx\n                    ? shift(projs[i].term, newn.length, 0)\n                    : Var(-1 + kepn.length + prjn.length - (i - (idx + 1))),\n                  orig: shift(projs[i].orig, newn.length, 0),\n                  type: shift(projs[i].type, newn.length, 0),\n                  adt: projs[i].adt\n                });\n              }\n\n              // Builds the substitution list for ADT parameters\n              var adtt = projs[idx].type;\n              var pram = [];\n              while (adtt[0] === \"App\") {\n                pram.push(adtt[1].argm);\n                adtt = adtt[1].func;\n              }\n              if (pram.length !== adt_pram.length) {\n                error(\"Couldn't build parameter list for argument `\" + projs[idx].name + \"` of function `\" + name + \"`.\\n\"\n                    + \"This is a language limitation. Consider removing type alises, or using the case expression instead.\");\n              }\n              var subs = [ref(adt_name)].concat(pram.reverse());\n\n              // Add constructor fields to keeps\n              for (var i = 0; i < fldn.length; ++i) {\n                var field_type = fldt[i];\n                var field_type = subst_many(field_type, subs, i);\n                var field_type = shift(field_type, newn.length, 0);\n                new_keeps.push({\n                  name: fldn[i],\n                  term: Var(-1 + newn.length - i),\n                  orig: Var(-1 + newn.length - i),\n                  type: field_type\n                });\n              }\n\n              // Adjusts motive to enter case\n              var new_moti = shift(moti, newn.length, 0);\n\n              // Builds the case body recursively\n              var argm = await parse_case_tree(idx + 1, new_projs, new_keeps, new_moti, branch.concat([ctor_n]), nams.concat(newn));\n\n              // Substitutes the open form of the projected value\n              var self = ref(adt_ctor[ctor_n][0]);\n              for (var i = 0; i < fldn.length; ++i) {\n                self = App(self, Var(-1 + kepn.length + prjn.length + fldn.length - i), false);\n              }\n              var argm = replace(projs[idx].orig[1].index + newn.length, self, argm);\n\n              // Wraps keeps, projs and field lambdas\n              for (var i = kepn.length - 1; i >= 0; --i) {\n                argm = Lam(kepn[i], null, argm, false);\n              }\n              for (var i = prjn.length - 1; i >= 0; --i) {\n                argm = Lam(prjn[i], null, argm, false);\n              }\n              for (var i = fldn.length - 1; i >= 0; --i) {\n                argm = Lam(fldn[i], null, argm, false);\n              }\n              var term = App(term, argm, false);\n            }\n\n            // Applies term to each proj and keep\n            for (var i = idx + 1; i < projs.length; ++i) {\n              var term = App(term, projs[i].term, false);\n            }\n            for (var i = 0; i < keeps.length; ++i) {\n              var term = App(term, keeps[i].term, false);\n            }\n\n            return term;\n          } else {\n            // Parses the case line\n            var skip = parse_exact(\"|\");\n            for (var i = 0; i < branch.length; ++i) {\n              var skip = parse_exact(projs[i].adt.adt_ctor[branch[i]][0]);\n            }\n            var skip = parse_exact(\"=>\");\n\n            // Parses the case term\n            var term = parse_term(nams);\n\n            return term;\n          }\n        })(0, proj_infos, keep_infos, moti, [], body_nams);\n\n      } else {\n        var term = await parse_term(body_nams.concat(wordn));\n\n        // Fills numeric copies\n        for (var i = wordn.length - 1; i >= 0; --i) {\n          var term = Cpy(wordn[i], Var(-1 + names.length + i - wordi[i]), term);\n        }\n      }\n\n      // Parses the halting case\n      if (recur && basex === null && !match(\"halt:\")) {\n        error(\"The bounded-recursive (inductive) definition '\" + name + \"' needs a halting (base) case. Provide it using `halt:`.\");\n      }\n      if (recur && basex !== null) {\n        var base = Var(-1 + names.length - basex);\n      } else if (recur) {\n        var base = await parse_term(lv0_names.concat(lv0_dup_n).concat(lv0_imp_n).concat(names));\n      } else {\n        var base = null;\n      }\n\n      // Fills type wrapper\n      if (type[0] === \"Typ\") {\n        var term = Tid(term);\n      }\n      var type = Tid(type);\n\n      // Fills foralls and lambdas of arguments\n      for (var i = names.length - 1; i >= 0; --i) {\n        var type = All(names[i], types[i], type, erass[i]);\n        var term = Lam(names[i], null, term, erass[i]);\n        var base = base && Lam(names[i], null, base, erass[i]);\n      }\n\n      // Aux function to add level 0 headers\n      const lv0_headers = (is_type, term, eras = true) => {\n        for (var i = lv0_imp_n.length - 1; i >= 0; --i) {\n          var term = Dup(lv0_imp_n[i], lv0_imp_v[i], term);\n        }\n        for (var i = lv0_dup_n.length - 1; i >= 0; --i) {\n          var term = Dup(lv0_dup_n[i], Var(-1 + lv0_names.length + i - lv0_dup_i[i]), term);\n        }\n        for (var i = lv0_names.length - 1; i >= 0; --i) {\n          var term = (is_type ? All : Lam)(lv0_names[i], is_type ? (lv0_boxed[i] ? Box : (x=>x))(lv0_types[i]) : null, term, eras && lv0_erass[i]);\n        }\n        return term;\n      }\n\n      // Builds a non-recursive, non-boxed definition\n      if (!recur && !boxed) {\n        define(file+\"/\"+name, Ann(type, term, false));\n\n      // Builds a non-recursive, boxed definition\n      } else if (!recur && boxed) {\n        var type = lv0_headers(1, Box(type), true);\n        var term = lv0_headers(0, Put(term), true);\n        define(file+\"/\"+name, Ann(type, term, false));\n        unbx[file+\"/\"+name] = {depth: lv0_names.length + lv0_dup_n.length + lv0_imp_n.length};\n\n      // Builds a recursive, non-boxed definition\n      } else if (!boxed && recur) {\n        error(\"Bounded-recursive (inductive) definition `\" + name + \"` must be boxed. Add a '!' before its name.\");\n\n      // Builds a recursive, boxed definition\n      } else if (boxed && recur) {\n        // Builds the motive\n        var moti_type = lv0_headers(1, All(rec_depth, base_ref(\"Ind\"), Typ(), false), false);\n        var moti_term = lv0_headers(0, Lam(rec_depth, null, type, false), false);\n\n        // Builds the step case\n        var step_typ0 = subst(shift(type, 1, 1), Ute(Var(0)), 0);\n        var step_typ1 = shift(subst(shift(type, 1, 1), App(base_ref(\"step\"), Ute(Var(0)), false), 0), 1, 0);\n        var step_type = lv0_headers(1, Box(All(rec_depth, Utt(base_ref(\"Ind\")), All(name, step_typ0, step_typ1, false), true)), true);\n        var step_term = lv0_headers(0, Put(Lam(rec_depth, null, Lam(name, null, term, false), true)), true);\n\n        // Builds the base case\n        var base_type = lv0_headers(1, Box(subst(type, base_ref(\"base\"), 0)), true);\n        var base_term = lv0_headers(0, Put(base), true);\n\n        // Builds the recursive function\n        var ind_moti = ref(name+\".moti\");\n        var ind_step = ref(name+\".step\");\n        var ind_base = ref(name+\".base\");\n        for (var i = 0, c = 0; i < lv0_names.length; ++i) {\n          if (lv0_boxed[i]) {\n            var vari = Put(Var(-1 + lv0_imp_n.length + lv0_dup_n.length - (c++)));\n          } else {\n            var vari = Var(-1 + lv0_imp_n.length + lv0_dup_n.length + lv0_names.length - i);\n          }\n          if (lv0_types[i][0] === \"Typ\") {\n            var vari = Tid(vari);\n          }\n          if (lv0_types[i][0] === \"Utt\") {\n            var vari = Utv(Ute(vari));\n          }\n          ind_moti = App(ind_moti, vari, false);\n          ind_step = App(ind_step, vari, lv0_erass[i]);\n          ind_base = App(ind_base, vari, lv0_erass[i]);\n        }\n        var type = All(rec_depth, base_ref(\"Ind\"), lv0_headers(1, Box(subst(type, Var(lv0_names.length + lv0_dup_n.length + lv0_imp_n.length), 0)), true), false);\n        var term = App(base_ref(\"ind\"), Var(lv0_names.length + lv0_dup_n.length + lv0_imp_n.length), false);\n        var term = App(term, ind_moti, true);\n        var term = App(term, ind_step, false);\n        var term = App(term, ind_base, false);\n        var term = Lam(rec_depth, null, lv0_headers(0, term, true), false);\n\n        define(file+\"/\"+name+\".moti\", Ann(moti_type, moti_term, false));\n        define(file+\"/\"+name+\".step\", Ann(step_type, step_term, false));\n        define(file+\"/\"+name+\".base\", Ann(base_type, base_term, false));\n        define(file+\"/\"+name, Ann(type, term, false));\n        //console.log(\"add.moti\");\n        //console.log(show(moti_type));\n        //console.log(show(moti_term));\n        //console.log(\"\");\n        //console.log(\"add.step\");\n        //console.log(show(step_type));\n        //console.log(show(step_term));\n        //console.log(\"\");\n        //console.log(\"add.base\");\n        //console.log(show(base_type));\n        //console.log(show(base_term));\n        //console.log(\"\");\n        //console.log(\"add\");\n        //console.log(show(type));\n        //console.log(show(term));\n        unbx[file+\"/\"+name+\".moti\"] = {depth: lv0_names.length + lv0_dup_n.length + lv0_imp_n.length};\n        unbx[file+\"/\"+name+\".step\"] = {depth: lv0_names.length + lv0_dup_n.length + lv0_imp_n.length};\n        unbx[file+\"/\"+name+\".base\"] = {depth: lv0_names.length + lv0_dup_n.length + lv0_imp_n.length};\n        unbx[file+\"/\"+name]         = {depth: lv0_names.length + lv0_dup_n.length + lv0_imp_n.length + 1};\n      }\n\n    // Untyped definition\n    } else {\n      var term = await parse_term([]);\n      define(file+\"/\"+name, term);\n    }\n\n    return true;\n  }\n\n  // When a reference to a boxed definiton is used inside a boxed definition,\n  // automatically unbox it by appending `dup ref = ref; ...` to the term\n  function perform_auto_unboxing() {\n    for (var path in unbx) {\n      var info = unbx[path];\n      var term = defs[path];\n      var lens = {term, field: \"expr\"};\n      for (var i = 0; i < info.depth; ++i) {\n        var lens = {term: lens.term[1][lens.field], field: \"body\"};\n      }\n      var unbox = [];\n      function go(term) {\n        return rewrite(term, (term, scope, erased) => {\n          if (term[0] === \"Tak\" && !erased) {\n            term = Tak(go(term[1].expr));\n            for (var i = 0; i < scope.length; ++i) {\n              term = subst(term, Val(0), 0);\n            }\n            for (var i = 0; i < unbox.length; ++i) {\n              if (equal(term[1].expr, unbox[i][1], 0, {show})) {\n                return Ref(\"$TMP$\" + (unbox.length - 1)); // share identical unbox\n              }\n            }\n            unbox.push([\"k\" + unbox.length, term[1].expr]);\n            return Ref(\"$TMP$\" + (unbox.length - 1));\n          }\n        })\n      };\n      lens.term[1][lens.field] = go(lens.term[1][lens.field]);\n      for (var i = unbox.length - 1; i >= 0; --i) {\n        lens.term[1][lens.field] = Dup(unbox[i][0], unbox[i][1], shift(lens.term[1][lens.field], 1, 0));\n      }\n      lens.term[1][lens.field] = rewrite(lens.term[1][lens.field], (term, scope) => {\n        if (term[0] === \"Ref\" && term[1].name.slice(0,5) === \"$TMP$\") {\n          return Var(-1 + scope.length - Number(term[1].name.slice(5)));\n        }\n      });\n    }\n  }\n\n  // Parses all definitions\n  var open_imports = {};\n  var qual_imports = {};\n  var local_imports = {};\n  var file_version = {};\n  var used_hole_name = {};\n  var hole_count = 0;\n  var tokens = tokenify ? [[\"txt\",\"\"]] : null;\n  var idx = 0;\n  var row = 0;\n  var col = 0;\n  var defs = {};\n  var adts = {};\n  var unbx = {};\n  var enlarge = {};\n  while (idx < code.length) {\n    next_char();\n    if (await do_parse_alias());\n    else if (await do_parse_import());\n    else if (await do_parse_datatype());\n    else if (await do_parse_defs_util());\n    else if (!(await do_parse_def())) break;\n    next_char();\n  }\n  if (root) {\n    perform_auto_unboxing();\n  }\n\n  return {\n    defs,\n    adts,\n    unbx,\n    tokens,\n    local_imports,\n    qual_imports,\n    open_imports\n  };\n}\n\n// :::::::::::\n// :: Utils ::\n// :::::::::::\n\n// Generates a name\nconst gen_name = (n) => {\n  var str = \"\";\n  ++n;\n  while (n > 0) {\n    --n;\n    str += String.fromCharCode(97 + n % 26);\n    n = Math.floor(n / 26);\n  }\n  return str;\n};\n\n// Maps defs\nconst replace_refs = ([ctor, term, hash, loc], renamer, depth = 0) => {\n  switch (ctor) {\n    case \"Var\":\n      return Var(term.index, loc);\n    case \"Typ\":\n      return Typ(loc);\n    case \"Tid\":\n      var expr = replace_refs(term.expr, renamer, depth);\n      return Tid(expr, loc);\n    case \"Utt\":\n      var expr = replace_refs(term.expr, renames, depth);\n      return Utt(expr, loc);\n    case \"Utv\":\n      var expr = replace_refs(term.expr, renames, depth);\n      return Utv(expr, loc);\n    case \"Ute\":\n      var expr = replace_refs(term.expr, renames, depth);\n      return Ute(expr, loc);\n    case \"All\":\n      var name = term.name;\n      var bind = replace_refs(term.bind, renamer, depth);\n      var body = replace_refs(term.body, renamer, depth + 1);\n      var eras = term.eras;\n      return All(name, bind, body, eras, loc);\n    case \"Lam\":\n      var name = term.name;\n      var bind = term.bind && replace_refs(term.bind, renamer, depth);\n      var body = replace_refs(term.body, renamer, depth + 1);\n      var eras = term.eras;\n      return Lam(name, bind, body, eras, loc);\n    case \"App\":\n      var func = replace_refs(term.func, renamer, depth);\n      var argm = replace_refs(term.argm, renamer, depth);\n      var eras = term.eras;\n      return App(func, argm, term.eras, loc);\n    case \"Box\":\n      var expr = replace_refs(term.expr, renamer, depth);\n      return Box(expr, loc);\n    case \"Put\":\n      var expr = replace_refs(term.expr, renamer, depth);\n      return Put(expr, loc);\n    case \"Tak\":\n      var expr = replace_refs(term.expr, renamer, depth);\n      return Tak(expr, loc);\n    case \"Dup\":\n      var name = term.name;\n      var expr = replace_refs(term.expr, renamer, depth);\n      var body = replace_refs(term.body, renamer, depth + 1);\n      return Dup(name, expr, body, loc);\n    case \"Num\":\n      return Num(loc);\n    case \"Val\":\n      var numb = term.numb;\n      return Val(numb, loc);\n    case \"Op1\":\n    case \"Op2\":\n      var func = term.func;\n      var num0 = replace_refs(term.num0, renamer, depth);\n      var num1 = replace_refs(term.num1, renamer, depth);\n      return Op2(func, num0, num1, loc);\n    case \"Ite\":\n      var cond = replace_refs(term.cond, renamer, depth);\n      var pair = replace_refs(term.pair, renamer, depth);\n      return Ite(cond, pair, loc);\n    case \"Cpy\":\n      var name = term.name;\n      var numb = replace_refs(term.numb, renamer, depth);\n      var body = replace_refs(term.body, renamer, depth + 1);\n      return Cpy(name, numb, body, loc);\n    case \"Sig\":\n      var name = term.name;\n      var typ0 = replace_refs(term.typ0, renamer, depth);\n      var typ1 = replace_refs(term.typ1, renamer, depth + 1);\n      var eras = term.eras;\n      return Sig(name, typ0, typ1, eras, loc);\n    case \"Par\":\n      var val0 = replace_refs(term.val0, renamer, depth);\n      var val1 = replace_refs(term.val1, renamer, depth);\n      var eras = term.eras;\n      return Par(val0, val1, eras, loc);\n    case \"Fst\":\n      var pair = replace_refs(term.pair, renamer, depth);\n      var eras = term.eras;\n      return Fst(pair, eras, loc);\n    case \"Snd\":\n      var pair = replace_refs(term.pair, renamer, depth);\n      var eras = term.eras;\n      return Snd(pair, eras, loc);\n    case \"Prj\":\n      var nam0 = term.nam0;\n      var nam1 = term.nam1;\n      var pair = replace_refs(term.pair, renamer, depth);\n      var body = replace_refs(term.body, renamer, depth + 2);\n      var eras = term.eras;\n      return Prj(nam0, nam1, pair, body, eras, loc);\n    case \"Slf\":\n      var name = term.name;\n      var type = replace_refs(term.type, renamer, depth + 1);\n      return Slf(name, type, loc);\n    case \"New\":\n      var type = replace_refs(term.type, renamer, depth);\n      var expr = replace_refs(term.expr, renamer, depth);\n      return New(type, expr, loc);\n    case \"Use\":\n      var expr = replace_refs(term.expr, renamer, depth);\n      return Use(expr, loc);\n    case \"Ann\":\n      var type = replace_refs(term.type, renamer, depth);\n      var expr = replace_refs(term.expr, renamer, depth);\n      var done = term.done;\n      return Ann(type, expr, done, loc);\n    case \"Log\":\n      var msge = replace_refs(term.msge, renamer, depth);\n      var expr = replace_refs(term.expr, renamer, depth);\n      return Log(msge, expr, loc);\n    case \"Hol\":\n      var name = term.name;\n      return Hol(name, loc);\n    case \"Ref\":\n      var new_name = renamer(term.name, depth);\n      if (typeof new_name === \"string\") {\n        return Ref(new_name, term.eras, loc);\n      } else if (typeof new_name === \"object\") {\n        return new_name;\n      } else {\n        return Ref(term.name, term.eras, loc);\n      }\n  }\n}\n\nconst rewrite = ([ctor, term, hash, loc], rewriter, scope = [], erased = false, only_once = false) => {\n  var rewritten = rewriter([ctor, term], scope, erased);\n  if (rewritten) {\n    return only_once ? rewritten : rewrite(rewritten, rewriter, scope, erased, only_once);\n  } else {\n    switch (ctor) {\n      case \"Var\":\n        return Var(term.index, loc);\n      case \"Typ\":\n        return Typ(loc);\n      case \"Tid\":\n        var expr = rewrite(term.expr, rewriter, scope, true, only_once);\n        return Tid(expr, loc);\n      case \"Utt\":\n        var expr = rewrite(term.expr, rewriter, scope, true, only_once);\n        return Utt(expr, loc);\n      case \"Utv\":\n        var expr = rewrite(term.expr, rewriter, scope, true, only_once);\n        return Utv(expr, loc);\n      case \"Ute\":\n        var expr = rewrite(term.expr, rewriter, scope, true, only_once);\n        return Ute(expr, loc);\n      case \"All\":\n        var name = term.name;\n        var bind = rewrite(term.bind, rewriter, scope, true, only_once);\n        var body = rewrite(term.body, rewriter, scope.concat([name]), true, only_once);\n        var eras = term.eras;\n        return All(name, bind, body, eras, loc);\n      case \"Lam\":\n        var name = term.name;\n        var bind = term.bind && rewrite(term.bind, rewriter, scope, true, only_once);\n        var body = rewrite(term.body, rewriter, scope.concat([name]), erased, only_once);\n        var eras = term.eras;\n        return Lam(name, bind, body, eras, loc);\n      case \"App\":\n        var func = rewrite(term.func, rewriter, scope, erased, only_once);\n        var argm = rewrite(term.argm, rewriter, scope, term.eras || erased, only_once);\n        var eras = term.eras;\n        return App(func, argm, term.eras, loc);\n      case \"Box\":\n        var expr = rewrite(term.expr, rewriter, scope, true, only_once);\n        return Box(expr, loc);\n      case \"Put\":\n        var expr = rewrite(term.expr, rewriter, scope, erased, only_once);\n        return Put(expr, loc);\n      case \"Tak\":\n        var expr = rewrite(term.expr, rewriter, scope, true, only_once);\n        return Tak(expr, loc);\n      case \"Dup\":\n        var name = term.name;\n        var expr = rewrite(term.expr, rewriter, scope, erased, only_once);\n        var body = rewrite(term.body, rewriter, scope.concat([name]), erased, only_once);\n        return Dup(name, expr, body, loc);\n      case \"Num\":\n        return Num(loc);\n      case \"Val\":\n        var numb = term.numb;\n        return Val(numb, loc);\n      case \"Op1\":\n      case \"Op2\":\n        var func = term.func;\n        var num0 = rewrite(term.num0, rewriter, scope, erased, only_once);\n        var num1 = rewrite(term.num1, rewriter, scope, erased, only_once);\n        return Op2(func, num0, num1, loc);\n      case \"Ite\":\n        var cond = rewrite(term.cond, rewriter, scope, erased, only_once);\n        var pair = rewrite(term.pair, rewriter, scope, erased, only_once);\n        return Ite(cond, pair, loc);\n      case \"Cpy\":\n        var name = term.name;\n        var numb = rewrite(term.numb, rewriter, scope, erased, only_once);\n        var body = rewrite(term.body, rewriter, scope.concat([name]), erased, only_once);\n        return Cpy(name, numb, body, loc);\n      case \"Sig\":\n        var name = term.name;\n        var typ0 = rewrite(term.typ0, rewriter, scope, true, only_once);\n        var typ1 = rewrite(term.typ1, rewriter, scope.concat([name]), true, only_once);\n        var eras = term.eras;\n        return Sig(name, typ0, typ1, eras, loc);\n      case \"Par\":\n        var val0 = rewrite(term.val0, rewriter, scope, term.eras === 1 || erased, only_once);\n        var val1 = rewrite(term.val1, rewriter, scope, term.eras === 1 || erased, only_once);\n        var eras = term.eras;\n        return Par(val0, val1, eras, loc);\n      case \"Fst\":\n        var pair = rewrite(term.pair, rewriter, scope, erased, only_once);\n        var eras = term.eras;\n        return Fst(pair, eras, loc);\n      case \"Snd\":\n        var pair = rewrite(term.pair, rewriter, scope, erased, only_once);\n        var eras = term.eras;\n        return Snd(pair, eras, loc);\n      case \"Prj\":\n        var nam0 = term.nam0;\n        var nam1 = term.nam1;\n        var pair = rewrite(term.pair, rewriter, scope, erased, only_once);\n        var body = rewrite(term.body, rewriter, scope.concat([nam0, nam1]), erased, only_once);\n        var eras = term.eras;\n        return Prj(nam0, nam1, pair, body, eras, loc);\n      case \"Slf\":\n        var name = term.name;\n        var type = rewrite(term.type, rewriter, scope.concat([name]), true, only_once);\n        return Slf(name, type, loc);\n      case \"New\":\n        var type = rewrite(term.type, rewriter, scope, true, only_once);\n        var expr = rewrite(term.expr, rewriter, scope, erased, only_once);\n        return New(type, expr, loc);\n      case \"Use\":\n        var expr = rewrite(term.expr, rewriter, scope, erased, only_once);\n        return Use(expr, loc);\n      case \"Ann\":\n        var type = rewrite(term.type, rewriter, scope, true, only_once);\n        var expr = rewrite(term.expr, rewriter, scope, erased, only_once);\n        var done = term.done;\n        return Ann(type, expr, done, loc);\n      case \"Log\":\n        var msge = rewrite(term.msge, rewriter, scope, true, only_once);\n        var expr = rewrite(term.expr, rewriter, scope, erased, only_once);\n        return Log(msge, expr, loc);\n      case \"Hol\":\n        var name = term.name;\n        return Hol(name, loc);\n      case \"Ref\":\n        var name = term.name;\n        var eras = term.eras;\n        var file = term.file;\n        return Ref(name, eras, loc);\n    }\n  }\n}\n\nconst replace = (idx, val, term) => {\n  var term = shift(term, 1, idx);\n  var term = subst(term, val, idx + 1);\n  return term;\n}\n\n// :::::::::::::::::::\n// :: Syntax Sugars ::\n// :::::::::::::::::::\n\n// Syntax sugars for datatypes. They transform a statement like:\n//\n//   data ADT <p0 : Param0, p1 : Param1...> {i0 : Index0, i1 : Index1}\n//   | ctr0 {ctr_fld0 : Ctr0_Fld0, ctr0_fld1 : Ctr0_Fld1, ...} : Cr0Type\n//   | ctr1 {ctr_fld0 : Ctr0_Fld0, ctr0_fld1 : Ctr0_Fld1, ...} : Cr0Type\n//   | ...\n//\n// on its corresponding self-encoded datatype:\n//\n//   def ADT\n//   = {p0 : Param0, p1 : Param1, ..., i0 : Index0, i1 : Index1, ...} =>\n//     : Type\n//     $ self\n//     {~P   : {i0 : Index0, i1 : Index1, ..., wit : (ADT i0 i1...)} -> Type} ->\n//     {ctr0 : {ctr0_fld0 : Ctr0_Fld0, ctr0_fld1 : Ctr0_Fld1, ...} -> (Ctr0Type[ADT <- P] (ADT.ctr0 Param0 Param1... ctr0_fld0 ctr0_fld1 ...))} ->\n//     {ctr1 : {ctr1_fld0 : Ctr1_Fld0, ctr1_fld1 : Ctr1_Fld1, ...} -> (Ctr0Type[ADT <- P] (ADT.ctr1 Param0 Param1... ctr1_fld1 ctr0_fld1 ...))} ->\n//     ... ->\n//     (P i0 i1... self)\n//\n//   def ADT.ctr0\n//   = {~p0 : Param0, ~p1 : Param1, ..., ctr0_fld0 : Ctr0_Fld0, ctr1_fld1 : Ctr1_Fld1, ...} =>\n//     : Ctr0Type\n//     @ Ctr0Type\n//       {~P, ctr0, ctr1, ...} =>\n//       (ctr0 ctr0_fld0 ctr0_fld1 ...)\n//\n//   (...)\nconst derive_adt_type = (file, {adt_pram, adt_indx, adt_ctor, adt_name}) => {\n  return (function adt_arg(p, i) {\n    // ... {p0 : Param0, p1 : Param1...} ...\n    if (p < adt_pram.length) {\n      return Lam(adt_pram[p][0], adt_pram[p][1], adt_arg(p + 1, i), adt_pram[p][2]);\n    // ... {i0 : Index0, i1 : Index...} ...\n    } else if (i < adt_indx.length) {\n      var substs = [Ref(file+\"/\"+adt_name)];\n      for (var P = 0; P < p; ++P) {\n        substs.push(Var(-1 + i + p - P));\n      }\n      return Lam(adt_indx[i][0], subst_many(adt_indx[i][1], substs, i), adt_arg(p, i + 1), adt_indx[i][2]);\n    } else {\n      return (\n        // ... : Type ...\n        Ann(Typ(),\n        // ... $ self ...\n        Slf(\"self\",\n        // ... P : ...\n        All(\"P\",\n          (function motive(i) {\n            // ... {i0 : Index0, i1 : Index1...} ...\n            if (i < adt_indx.length) {\n              var substs = [Ref(file+\"/\"+adt_name)];\n              for (var P = 0; P < p; ++P) {\n                substs.push(Var(-1 + i + 1 + adt_indx.length + p - P));\n              }\n              return All(adt_indx[i][0], subst_many(adt_indx[i][1], substs, i), motive(i + 1), adt_indx[i][2]);\n            // ... {wit : (ADT i0 i1...)} -> Type ...\n            } else {\n              var wit_t = Ref(file+\"/\"+adt_name);\n              for (var P = 0; P < adt_pram.length; ++P) {\n                wit_t = App(wit_t, Var(-1 + i + 1 + i + adt_pram.length - P), adt_pram[P][2]);\n              }\n              for (var I = 0; I < i; ++I) {\n                wit_t = App(wit_t, Var(-1 + i - I), adt_indx[I][2]);\n              }\n              return All(\"wit\", wit_t, Typ(), false);\n            }\n          })(0),\n        (function ctor(i) {\n          if (i < adt_ctor.length) {\n            // ... ctrX : ...\n            return All(adt_ctor[i][0], (function field(j) {\n              var subst_prams = [];\n              for (var P = 0; P < adt_pram.length; ++P) {\n                subst_prams.push(Var(-1 + j + i + 1 + 1 + adt_indx.length + adt_pram.length - P));\n              }\n              // ... {ctrX_fldX : CtrX_FldX, ctrX_fld1 : CtrX_Fld1, ...} -> ...\n              if (j < adt_ctor[i][1].length) {\n                var sub = [Ref(file+\"/\"+adt_name)].concat(subst_prams);\n                var typ = subst_many(adt_ctor[i][1][j][1], sub, j);\n                return All(adt_ctor[i][1][j][0], typ, field(j + 1), adt_ctor[i][1][j][2]);\n              // ... (CtrXType[ADT <- P] (ADT.ctrX ParamX Param1... ctrX_fldX ctrX_fld1 ...)) -> ...\n              } else {\n                var typ = adt_ctor[i][2];\n                var sub = [Var(-1 + j + i + 1)].concat(subst_prams);\n                var typ = subst_many(adt_ctor[i][2], sub, j);\n                var rem = typ;\n                for (var I = 0; I < adt_indx.length; ++I) {\n                  rem = rem[1].func;\n                }\n                rem[0] = \"Var\";\n                rem[1] = {index: -1 + i + j + 1};\n                var wit = Ref(file+\"/\"+adt_ctor[i][0]);\n                for (var P = 0; P < adt_pram.length; ++P) {\n                  var wit = App(wit, Var(-1 + j + i + 1 + 1 + adt_indx.length + adt_pram.length - P), true);\n                }\n                for (var F = 0; F < adt_ctor[i][1].length; ++F) {\n                  var wit = App(wit, Var(-1 + j - F), adt_ctor[i][1][F][2]);\n                }\n                return App(typ, wit, false);\n              }\n            })(0),\n            ctor(i + 1),\n            false);\n          } else {\n            // ... (P i0 i1... self)\n            var ret = Var(adt_ctor.length + 1 - 1);\n            for (var i = 0; i < adt_indx.length; ++i) {\n              var ret = App(ret, Var(adt_ctor.length + 1 + 1 + adt_indx.length - i - 1), adt_indx[i][2]);\n            }\n            var ret = App(ret, Var(adt_ctor.length + 1 + 1 - 1), false);\n            return ret;\n          }\n        })(0),\n        true))));\n    }\n  })(0, 0);\n}\n\nconst derive_adt_ctor = (file, {adt_pram, adt_indx, adt_ctor, adt_name}, c) => {\n  return (function arg(p, i, f) {\n    var substs = [Ref(file+\"/\"+adt_name)];\n    for (var P = 0; P < p; ++P) {\n      substs.push(Var(-1 + f + p - P));\n    }\n    // {~p0 : Param0, ~p1 : Param1...} ...\n    if (p < adt_pram.length) {\n      return Lam(adt_pram[p][0], adt_pram[p][1], arg(p + 1, i, f), true);\n    // ... {ctr0_fld0 : Ctr0_Fld0, ctr1_fld1 : Ctr1_Fld1, ...} ...\n    } else if (f < adt_ctor[c][1].length) {\n      return Lam(adt_ctor[c][1][f][0], subst_many(adt_ctor[c][1][f][1], substs, f), arg(p, i, f + 1), adt_ctor[c][1][f][2]);\n    } else {\n      var type = subst_many(adt_ctor[c][2], substs, f);\n      // ... : CtrXType {~P} ...\n      return Ann(type, New(type, Lam(\"P\", null, (function opt(k) {\n        // ... {ctr0, ctr1...} ...\n        if (k < adt_ctor.length) {\n          return Lam(adt_ctor[k][0], null, opt(k + 1), false);\n        // (ctrX ctrX_fld0 ctrX_fld1 ...)\n        } else {\n          var sel = Var(-1 + adt_ctor.length - c);\n          for (var F = 0; F < adt_ctor[c][1].length; ++F) {\n            var fld = Var(-1 + adt_ctor.length + 1 + adt_ctor[c][1].length - F);\n            // Unrestricted field\n            if (adt_ctor[c][1][F][1][0] === \"Utt\") {\n              var fld = Utv(Ute(fld));\n            }\n            var sel = App(sel, fld, adt_ctor[c][1][F][2]);\n          }\n          return sel;\n        }\n      })(0), true)), false);\n    }\n  })(0, adt_indx.length, 0);\n}\n\nconst reduce = (term, opts) => {\n  return core_reduce(term, {...opts, show});\n};\n\nconst typecheck = (term, expect, opts) => {\n  return core_typecheck(term, expect, {...opts, show});\n};\n\n// Evaluates a term to normal form in different modes\n// run : String -> (String | Term) -> Opts -> Term\nconst run = (mode, term, opts = {}) => {\n  var eras = opts.erased ? erase : (x => x);\n  var defs = opts.defs || {};\n  if (typeof term === \"string\") {\n    term = defs[term] || Ref(term);\n  }\n\n  switch (mode) {\n\n    case \"REDUCE_DEBUG\":\n      term = eras(term);\n      try {\n        opts.unbox = true;\n        opts.undup = true;\n        term = reduce(term, opts);\n      } catch (e) {\n        console.log(e);\n        term = reduce(term, {...opts, weak: true});\n      }\n      break;\n\n    case \"REDUCE_DEBUG\":\n    case \"REDUCE_NATIVE\":\n      term = eras(term);\n      term = to_js.decompile(to_js.compile(term, defs));\n      break;\n\n    case \"REDUCE_OPTIMAL\":\n      term = eras(term);\n      var net = to_net.compile(term, defs);\n      if (opts.stats && opts.stats.input_net === null) {\n        opts.stats.input_net = JSON.parse(JSON.stringify(net));\n      }\n      if (opts.strict) {\n        var new_stats = net.reduce_strict(opts.stats || {});\n      } else {\n        var new_stats = net.reduce_lazy(opts.stats || {});\n      }\n      if (opts.stats && opts.stats.output_net !== undefined) {\n        opts.stats.output_net = JSON.parse(JSON.stringify(net));\n      }\n      term = to_net.decompile(net);\n      break;\n\n    case \"TYPECHECK\":\n      term = typecheck(term, null, opts);\n      break;\n  }\n\n  return term;\n};\n\nmodule.exports = {\n  Var, Typ, Tid, Utt, Utv, Ute, All, Lam,\n  App, Box, Put, Tak, Dup, Num, Val, Op1,\n  Op2, Ite, Cpy, Sig, Par, Fst, Snd, Prj,\n  Slf, New, Use, Ann, Log, Hol, Ref,\n  derive_adt_ctor,\n  derive_adt_type,\n  equal,\n  erase,\n  gen_name,\n  parse,\n  reduce,\n  replace_refs,\n  run,\n  shift,\n  show,\n  subst,\n  subst_many,\n  typecheck,\n  haltcheck,\n  version,\n};\n\n\n//# sourceURL=webpack:///../formality/src/fm-lang.js?");

/***/ }),

/***/ "../formality/src/fm-lib.js":
/*!**********************************!*\
  !*** ../formality/src/fm-lib.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var fm = module.exports = {\n  core   : __webpack_require__(/*! ./fm-core */ \"../formality/src/fm-core.js\"),\n  json   : __webpack_require__(/*! ./fm-json */ \"../formality/src/fm-json.js\"),\n  lang   : __webpack_require__(/*! ./fm-lang */ \"../formality/src/fm-lang.js\"),\n  net    : __webpack_require__(/*! ./fm-net */ \"../formality/src/fm-net.js\"),\n  to_js  : __webpack_require__(/*! ./fm-to-js */ \"../formality/src/fm-to-js.js\"),\n  to_net : __webpack_require__(/*! ./fm-to-net */ \"../formality/src/fm-to-net.js\"),\n  forall : __webpack_require__(/*! ./forall */ \"../formality/src/forall.js\"),\n};\n\n\n//# sourceURL=webpack:///../formality/src/fm-lib.js?");

/***/ }),

/***/ "../formality/src/fm-net.js":
/*!**********************************!*\
  !*** ../formality/src/fm-net.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// ~~ Formality Interaction Net System ~~\n\n// PtrNum types\nconst PTR = 0;\nconst NUM = 1;\n\n// Node types\nconst NOD = 0;\nconst OP1 = 1;\nconst OP2 = 2;\nconst ITE = 3;\n\n// Base types\nconst Pointer = (addr, port) => ({typ: PTR, val: (addr << 2) + (port & 3)});\nconst addr_of = (ptrn) => ptrn.val >>> 2;\nconst slot_of = (ptrn) => ptrn.val & 3;\nconst Numeric = (numb) => ({typ: NUM, val: numb});\nconst numb_of = (ptrn) => ptrn.val;\nconst type_of = (ptrn) => ptrn.typ;\nconst ptrn_eq = (a, b) => a.typ === b.typ && a.val === b.val;\nconst ptrn_st = a => a.typ + \":\" + a.val;\n\nclass Net {\n  // A net stores nodes (this.nodes), reclaimable memory addrs (this.freed) and active pairs (this.redex)\n  constructor() {\n    this.nodes = []; // nodes\n    this.freed = []; // integers\n    this.redex = []; // array of (integer, integer) tuples representing addrs\n    this.find_redex = true;\n  }\n\n  // Allocates a new node, return its addr\n  alloc_node(type, kind) {\n\n    // If there is reclaimable memory, use it\n    if (this.freed.length > 0) {\n      var addr = this.freed.pop();\n\n    // Otherwise, extend the array of nodes\n    } else {\n      var addr = this.nodes.length / 4;\n    }\n\n    // Fill the memory with an empty node without pointers\n    this.nodes[addr * 4 + 0] = addr * 4 + 0;\n    this.nodes[addr * 4 + 1] = addr * 4 + 1;\n    this.nodes[addr * 4 + 2] = addr * 4 + 2;\n    this.nodes[addr * 4 + 3] = (kind << 6) + ((type & 0x7) << 3);\n    return addr;\n  }\n\n  // Deallocates a node, allowing its space to be reclaimed\n  free_node(addr) {\n    this.nodes[addr * 4 + 0] = addr * 4 + 0;\n    this.nodes[addr * 4 + 1] = addr * 4 + 1;\n    this.nodes[addr * 4 + 2] = addr * 4 + 2;\n    this.nodes[addr * 4 + 3] = 0;\n    this.freed.push(addr);\n  }\n\n  is_free(addr) {\n    return this.nodes[addr * 4 + 0] === addr * 4 + 0\n        && this.nodes[addr * 4 + 1] === addr * 4 + 1\n        && this.nodes[addr * 4 + 2] === addr * 4 + 2\n        && this.nodes[addr * 4 + 3] === 0;\n  }\n\n  // Returns if given slot holds a number\n  is_numeric(addr, slot) {\n    return (this.nodes[addr * 4 + 3] >>> slot) & 1; \n  }\n\n  set_port(addr, slot, ptrn) {\n    if (type_of(ptrn) === NUM) {\n      this.nodes[addr * 4 + slot] = numb_of(ptrn);\n      this.nodes[addr * 4 + 3] = this.nodes[addr * 4 + 3] | (1 << slot);\n    } else {\n      this.nodes[addr * 4 + slot] = (addr_of(ptrn) << 2) + (slot_of(ptrn) & 3);\n      this.nodes[addr * 4 + 3] = this.nodes[addr * 4 + 3] & ~(1 << slot);\n    }\n  }\n\n  get_port(addr, slot) {\n    var val = this.nodes[addr * 4 + slot];\n    return !this.is_numeric(addr, slot) ? Pointer(val >>> 2, val & 3) : Numeric(val);\n  }\n\n  type_of(addr) {\n    return (this.nodes[addr * 4 + 3] >>> 3) & 0x7;\n  }\n\n  set_type(addr, type) {\n    this.nodes[addr * 4 + 3] = (this.nodes[addr * 4 + 3] & ~0b111000) | (type << 3);\n  }\n\n  kind_of(addr) {\n    return this.nodes[addr * 4 + 3] >>> 6;\n  }\n\n  // Given a pointer to a port, returns a pointer to the opposing port\n  enter_port(ptrn) {\n    if (type_of(ptrn) === NUM) { \n      throw \"Can't enter a numeric pointer.\";\n    } else {\n      return this.get_port(addr_of(ptrn), slot_of(ptrn));\n    }\n  }\n\n  // Connects two ports\n  link_ports(a_ptrn, b_ptrn) {\n    var a_numb = type_of(a_ptrn) === NUM;\n    var b_numb = type_of(b_ptrn) === NUM;\n\n    // Point ports to each-other\n    if (!a_numb) this.set_port(addr_of(a_ptrn), slot_of(a_ptrn), b_ptrn);\n    if (!b_numb) this.set_port(addr_of(b_ptrn), slot_of(b_ptrn), a_ptrn);\n\n    // If both are main ports, add this to the list of active pairs\n    if (this.find_redex && !(a_numb && b_numb) && (a_numb || slot_of(a_ptrn) === 0) && (b_numb || slot_of(b_ptrn) === 0)) {\n      this.redex.push(a_numb ? addr_of(b_ptrn) : addr_of(a_ptrn));\n    }\n  }\n\n  // Disconnects a port, causing both sides to point to themselves\n  unlink_port(a_ptrn) {\n    if (type_of(a_ptrn) === PTR) {\n      var b_ptrn = this.enter_port(a_ptrn);\n      if (type_of(b_ptrn) === PTR && ptrn_eq(this.enter_port(b_ptrn), a_ptrn)) {\n        this.set_port(addr_of(a_ptrn), slot_of(a_ptrn), a_ptrn);\n        this.set_port(addr_of(b_ptrn), slot_of(b_ptrn), b_ptrn);\n      }\n    }\n  }\n\n  // Rewrites an active pair\n  rewrite(a_addr) {\n    var a_ptrn = Pointer(a_addr, 0);\n    var b_ptrn = this.get_port(a_addr, 0);\n    if (type_of(b_ptrn) === NUM) {\n      var a_type = this.type_of(a_addr);\n      var a_kind = this.kind_of(a_addr);\n\n      // UnaryOperation\n      if (a_type === OP1) {\n        var dst = this.enter_port(Pointer(a_addr, 2));\n        var fst = numb_of(b_ptrn);\n        var snd = numb_of(this.enter_port(Pointer(a_addr, 1)));\n        switch (a_kind) {\n          case  0: var res = Numeric(fst + snd); break;\n          case  1: var res = Numeric(fst - snd); break;\n          case  2: var res = Numeric(fst * snd); break;\n          case  3: var res = Numeric(fst / snd); break;\n          case  4: var res = Numeric(fst % snd); break;\n          case  5: var res = Numeric(fst ** snd); break;\n          case  6: var res = Numeric(fst & snd); break;\n          case  7: var res = Numeric(fst | snd); break;\n          case  8: var res = Numeric(fst ^ snd); break;\n          case  9: var res = Numeric(~snd); break;\n          case 10: var res = Numeric(fst >>> snd); break;\n          case 11: var res = Numeric(fst << snd); break;\n          case 12: var res = Numeric(fst > snd ? 1 : 0); break;\n          case 13: var res = Numeric(fst < snd ? 1 : 0); break;\n          case 14: var res = Numeric(fst === snd ? 1 : 0); break;\n          default: throw \"[ERROR]\\nInvalid interaction.\";\n        }\n        this.link_ports(dst, res);\n        this.unlink_port(Pointer(a_addr, 0));\n        this.unlink_port(Pointer(a_addr, 2));\n        this.free_node(a_addr);\n      \n      // BinaryOperation\n      } else if (a_type === OP2) {\n        this.set_type(a_addr, OP1);\n        this.link_ports(Pointer(a_addr, 0), this.enter_port(Pointer(a_addr, 1)));\n        this.unlink_port(Pointer(a_addr, 1));\n        this.link_ports(Pointer(a_addr, 1), b_ptrn);\n    \n      // NumberDuplication\n      } else if (a_type === NOD) {\n        this.link_ports(b_ptrn, this.enter_port(Pointer(a_addr, 1)));\n        this.link_ports(b_ptrn, this.enter_port(Pointer(a_addr, 2)));\n        this.free_node(a_addr);\n\n      // IfThenElse\n      } else if (a_type === ITE) {\n        var cond_val = numb_of(b_ptrn) === 0;\n        var pair_ptr = this.enter_port(Pointer(a_addr, 1));\n        this.set_type(a_addr, NOD);\n        this.link_ports(Pointer(a_addr, 0), pair_ptr);\n        this.unlink_port(Pointer(a_addr, 1));\n        var dest_ptr = this.enter_port(Pointer(a_addr, 2));\n        this.link_ports(Pointer(a_addr, cond_val ? 2 : 1), dest_ptr);\n        if (!cond_val) this.unlink_port(Pointer(a_addr, 2));\n        this.link_ports(Pointer(a_addr, cond_val ? 1 : 2), Pointer(a_addr, cond_val ? 1 : 2));\n\n      } else {\n        throw \"[ERROR]\\nInvalid interaction.\";\n      }\n\n    } else {\n      var b_addr = addr_of(b_ptrn);\n      var a_type = this.type_of(a_addr);\n      var b_type = this.type_of(b_addr);\n      var a_kind = this.kind_of(a_addr);\n      var b_kind = this.kind_of(b_addr);\n\n      // NodeAnnihilation, UnaryAnnihilation, BinaryAnnihilation\n      if ( a_type === NOD && b_type === NOD && a_kind === b_kind\n        || a_type === OP1 && b_type === OP1\n        || a_type === OP2 && b_type === OP2\n        || a_type === ITE && b_type === ITE) {\n        var a_aux1_dest = this.enter_port(Pointer(a_addr, 1));\n        var b_aux1_dest = this.enter_port(Pointer(b_addr, 1));\n        this.link_ports(a_aux1_dest, b_aux1_dest);\n        var a_aux2_dest = this.enter_port(Pointer(a_addr, 2));\n        var b_aux2_dest = this.enter_port(Pointer(b_addr, 2));\n        this.link_ports(a_aux2_dest, b_aux2_dest);\n        for (var i = 0; i < 3; i++) {\n          this.unlink_port(Pointer(a_addr, i));\n          this.unlink_port(Pointer(b_addr, i));\n        }\n        this.free_node(a_addr);\n        if (a_addr !== b_addr) {\n          this.free_node(b_addr);\n        }\n\n      // NodeDuplication, BinaryDuplication\n      } else if\n        (  a_type === NOD && b_type === NOD && a_kind !== b_kind\n        || a_type === NOD && b_type === OP2\n        || a_type === NOD && b_type === ITE) {\n        var p_addr = this.alloc_node(b_type, b_kind);\n        var q_addr = this.alloc_node(b_type, b_kind);\n        var r_addr = this.alloc_node(a_type, a_kind);\n        var s_addr = this.alloc_node(a_type, a_kind);\n        this.link_ports(Pointer(r_addr, 1), Pointer(p_addr, 1));\n        this.link_ports(Pointer(s_addr, 1), Pointer(p_addr, 2));\n        this.link_ports(Pointer(r_addr, 2), Pointer(q_addr, 1));\n        this.link_ports(Pointer(s_addr, 2), Pointer(q_addr, 2));\n        this.link_ports(Pointer(p_addr, 0), this.enter_port(Pointer(a_addr, 1)));\n        this.link_ports(Pointer(q_addr, 0), this.enter_port(Pointer(a_addr, 2)));\n        this.link_ports(Pointer(r_addr, 0), this.enter_port(Pointer(b_addr, 1)));\n        this.link_ports(Pointer(s_addr, 0), this.enter_port(Pointer(b_addr, 2)));\n        for (var i = 0; i < 3; i++) {\n          this.unlink_port(Pointer(a_addr, i));\n          this.unlink_port(Pointer(b_addr, i));\n        }\n        this.free_node(a_addr);\n        if (a_addr !== b_addr) {\n          this.free_node(b_addr);\n        }\n\n      // UnaryDuplication\n      } else if\n        (  a_type === NOD && b_type === OP1\n        || a_type === ITE && b_type === OP1) {\n        var p_addr = this.alloc_node(b_type, b_kind);\n        var q_addr = this.alloc_node(b_type, b_kind);\n        var s_addr = this.alloc_node(a_type, a_kind);\n        this.link_ports(Pointer(p_addr, 1), this.enter_port(Pointer(b_addr, 1)));\n        this.link_ports(Pointer(q_addr, 1), this.enter_port(Pointer(b_addr, 1)));\n        this.link_ports(Pointer(s_addr, 1), Pointer(p_addr, 2));\n        this.link_ports(Pointer(s_addr, 2), Pointer(q_addr, 2));\n        this.link_ports(Pointer(p_addr, 0), this.enter_port(Pointer(a_addr, 1)));\n        this.link_ports(Pointer(q_addr, 0), this.enter_port(Pointer(a_addr, 2)));\n        this.link_ports(Pointer(s_addr, 0), this.enter_port(Pointer(b_addr, 2)));\n        for (var i = 0; i < 3; i++) {\n          this.unlink_port(Pointer(a_addr, i));\n          this.unlink_port(Pointer(b_addr, i));\n        }\n        this.free_node(a_addr);\n        if (a_addr !== b_addr) {\n          this.free_node(b_addr);\n        }\n      \n      // Permutations\n      } else if (a_type === OP1 && b_type === NOD) {\n        return this.rewrite(b_addr);\n      } else if (a_type === OP2 && b_type === NOD) {\n        return this.rewrite(b_addr);\n      } else if (a_type === ITE && b_type === NOD) {\n        return this.rewrite(b_addr);\n\n      // InvalidInteraction\n      } else {\n        throw \"[ERROR]\\nInvalid interaction.\";\n      }\n    }\n  }\n\n  // Rewrites active pairs until none is left, reducing the graph to normal form.\n  // This could be performed in parallel and doesn't need GC.\n  reduce_strict(stats) {\n    var rewrites = 0;\n    var loops = 0;\n    var max_len = 0;\n    while (this.redex.length > 0) {\n      for (var i = 0, l = this.redex.length; i < l; ++i) {\n        this.rewrite(this.redex.pop());\n        stats.max_len = Math.max(stats.max_len, this.nodes.length / 4);\n        ++stats.rewrites;\n      }\n      ++stats.loops;\n    }\n  }\n\n  // Rewrites active pairs until none is left, reducing the graph to normal form.\n  // This avoids unecessary computations, but is sequential and would need GC.\n  reduce_lazy(stats) {\n    this.find_redex = false;\n    var warp = [];\n    var back = [];\n    var prev = Pointer(0, 1);\n    var next = this.enter_port(prev);\n    var rwts = 0;\n    while (true) {\n      ++stats.loops;\n      if (type_of(next) === PTR && (addr_of(next) === 0 || this.is_free(addr_of(next)))) {\n        if (warp.length === 0) {\n          break;\n        } else {\n          prev = warp.pop();\n          next = this.enter_port(prev);\n        }\n      } else {\n        if (slot_of(prev) === 0 && (type_of(next) === NUM || slot_of(next) === 0)) {\n          try {\n            this.rewrite(addr_of(prev));\n          } catch (e) {\n            return;\n          }\n          stats.rewrites += 1;\n          stats.max_len = Math.max(stats.max_len, this.nodes.length / 4);\n          do { prev = back.pop(); } while (type_of(prev) !== PTR);\n          next = this.enter_port(prev);\n          ++rwts;\n        } else if (type_of(next) === NUM) {\n          [prev,next] = [next,prev];\n        } else if (slot_of(next) === 0) {\n          if (this.type_of(addr_of(next)) !== OP1) {\n            warp.push(Pointer(addr_of(next), 1));\n          }\n          prev = Pointer(addr_of(next), 2);\n          next = this.enter_port(prev);\n        } else {\n          back.push(prev);\n          prev = Pointer(addr_of(next), 0);\n          next = this.enter_port(prev);\n        }\n      }\n    }\n    this.find_redex = true;\n  }\n\n  // Returns a string that is preserved on reduction, good for debugging\n  denote(ptrn = this.enter_port(Pointer(0, 1)), exit = []) {\n    function path_to_string(path) {\n      var str = \"<\";\n      while (path) {\n        str += path.head === 1 ? \"a\" : \"b\";\n        path = path.tail; \n      }\n      str += \">\";\n      return str;\n    }\n    while (true) {\n      if (type_of(ptrn) === PTR) {\n        var ai = addr_of(ptrn);\n        var as = slot_of(ptrn)\n        var ak = this.kind_of(ai);\n        switch (this.type_of(ai)) {\n          case NOD:\n            if (slot_of(ptrn) === 0) {\n              if (exit[ak]) {\n                var new_exit = exit.slice(0);\n                new_exit[ak] = new_exit[ak].tail;\n                ptrn = this.enter_port(Pointer(ai, Number(exit[ak].head)));\n                exit = new_exit;\n                continue; // tail-call: denote(ptrn, exit)\n              } else {\n                var lft = this.denote(this.enter_port(Pointer(ai, 1)), exit);\n                var rgt = this.denote(this.enter_port(Pointer(ai, 2)), exit);\n                return \"(\" + ak + \" \" + lft + \" \" + rgt + \")\";\n              }\n            } else {\n              if (ai === 0) {\n                while (exit[exit.length - 1] === null) exit.pop();\n                return exit.map(path_to_string).join(\":\");\n              } else {\n                var new_exit = exit.slice(0);\n                new_exit[ak] = {head: as, tail: new_exit[ak] || null};\n                ptrn = this.enter_port(Pointer(ai, 0));\n                exit = new_exit;\n                continue; // tail-call: denote(ptrn, exit)\n              }\n            }\n            break;\n          default:\n            return \"<TODO>\";\n        }\n      } else {\n        return \"#\" + numb_of(ptrn);\n      }\n    }\n  }\n\n  to_string() {\n    const pointer = (ptrn) => {\n      if (type_of(ptrn) === NUM) {\n        return \"#\" + numb_of(ptrn);\n      } else {\n        return addr_of(ptrn) + \"abc\"[slot_of(ptrn)];\n      }\n    };\n    var text = '';\n    for (var i = 0; i < this.nodes.length / 4; i++) {\n      if (this.is_free(i)) {\n        text += i + \": ~\\n\";\n      } else {\n        var type = this.type_of(i);\n        var kind = this.kind_of(i);\n        text += i + ': ';\n        text += \"[\" + type + \":\" + kind + \"| \";\n        text += pointer(this.get_port(i, 0)) + \" \";\n        text += pointer(this.get_port(i, 1)) + \" \";\n        text += pointer(this.get_port(i, 2)) + \"]\";\n        text += \" ... \" + this.is_numeric(i,0) + \" \" + this.is_numeric(i,1) + \" \" + this.is_numeric(i,2);\n        text += \"\\n\";\n      }\n    }\n    return text;\n  }\n}\n\nmodule.exports = {Pointer, addr_of, slot_of, Numeric, numb_of, type_of, ptrn_eq, ptrn_st, Net, NUM, PTR, NOD, OP1, OP2, ITE};\n\n\n//# sourceURL=webpack:///../formality/src/fm-net.js?");

/***/ }),

/***/ "../formality/src/fm-to-js.js":
/*!************************************!*\
  !*** ../formality/src/fm-to-js.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const fm = __webpack_require__(/*! ./fm-core.js */ \"../formality/src/fm-core.js\");\n\n// Converts a Formality-Core Term to a native JavaScript function\nconst compile = (term, opts, vars = null) => {\n  var [ctor, term] = term;\n  switch (ctor) {\n    case \"Var\":\n      for (var i = 0; i < term.index; ++i) {\n        vars = vars[1];\n      }\n      return vars[0];\n    case \"Lam\":\n      return x => compile(term.body, opts, [x, vars]);\n    case \"App\":\n      var func = compile(term.func, opts, vars);\n      var argm = compile(term.argm, opts, vars);\n      return func(argm);\n    case \"Put\":\n      return compile(term.expr, opts, vars);\n    case \"Dup\": \n      var expr = compile(term.expr, opts, vars);\n      var body = x => compile(term.body, opts, [x,vars]);\n      return body(expr);\n    case \"Val\":\n      return term.numb;\n    case \"Op1\":\n    case \"Op2\":\n      var func = term.func;\n      var num0 = compile(term.num0, opts, vars);\n      var num1 = compile(term.num1, opts, vars);\n      switch (func) {\n        case \".+.\"  : return num0 + num1;\n        case \".-.\"  : return num0 - num1;\n        case \".*.\"  : return num0 * num1;\n        case \"./.\"  : return num0 / num1;\n        case \".%.\"  : return num0 % num1;\n        case \".**.\" : return num0 ** num1;\n        case \".&.\"  : return num0 & num1;\n        case \".|.\"  : return num0 | num1;\n        case \".^.\"  : return num0 ^ num1;\n        case \".~.\"  : return ~ num1;\n        case \".>>.\" : return num0 >>> num1;\n        case \".<<.\" : return num0 << num1;\n        case \".>.\"  : return num0 > num1;\n        case \".<.\"  : return num0 < num1;\n        default: throw \"TODO: implement operator \"\n      }\n    case \"Ite\":\n      var cond = compile(term.cond, opts, vars);\n      var pair = compile(term.pair, opts, vars);\n      return cond ? pair[0] : pair[1];\n    case \"Cpy\":\n      var numb = compile(term.numb, opts, vars);\n      var body = x => compile(term.body, opts, [x,vars]);\n      return body(numb);\n    case \"Par\":\n      var val0 = compile(term.val0, opts, vars);\n      var val1 = compile(term.val1, opts, vars);\n      return [val0, val1];\n    case \"Fst\":\n      var pair = compile(term.pair, opts, vars);\n      return pair[0];\n    case \"Snd\":\n      var pair = compile(term.pair, opts, vars);\n      return pair[1];\n    case \"Prj\":\n      var nam0 = term.nam0;\n      var nam1 = term.nam1;\n      var pair = compile(term.pair, opts, vars);\n      var body = (x,y) => compile(term.body, opts, [y,[x,vars]]);\n      return body(pair[0], pair[1]);\n    case \"Log\":\n      return compile(term.expr, opts, vars);\n    case \"Ref\":\n      return compile(fm.erase((opts.defs||{})[term.name]), opts, vars);\n  }\n};\n\n// Converts a native JavaScript function back to a Formality-Core term\nconst decompile = (func) => {\n  return (function go(term, depth) {\n    function APP(variable) {\n      return function FM_DECOMPILE_GET(arg){\n        if (arg === null) {\n          return variable;\n        } else {\n          return APP(d => fm.App(variable(d), go(arg, d), false));\n        }\n      };\n    };\n    function VAR(d) {\n      return fm.Var(d - 1 - depth);\n    };\n    if (typeof term === \"function\" && term.name === \"FM_DECOMPILE_GET\") {\n      return term(null)(depth);\n    } else if (typeof term === \"object\") {\n      var val0 = go(term[0], depth);\n      var val1 = go(term[1], depth);\n      return fm.Par(val0, val1);\n    } else if (typeof term === \"number\") {\n      return fm.Val(term);\n    } else if (typeof term === \"function\") {\n      var body = go(term(APP(VAR)), depth + 1);\n      return fm.Lam(\"x\" + depth, null, body, false);\n    } else if (typeof term === \"string\") {\n      throw \"[ERROR]\\nThis native JS function can't be decompiled to Formality:\\n\\n\"\n        + func.toString()\n        + \"\\n\\nIt possibly uses numeric operators on free variables, which can't be decompiled yet.\";\n    } else {\n      return term;\n    }\n  })(func, 0);\n};\n\nmodule.exports = {compile, decompile};\n\n\n//# sourceURL=webpack:///../formality/src/fm-to-js.js?");

/***/ }),

/***/ "../formality/src/fm-to-net.js":
/*!*************************************!*\
  !*** ../formality/src/fm-to-net.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// ~~ Compiles Formality Core to Formality Net ~~\n\nconst {Var, App, Lam, Val, Op1, Op2, Ite, Par, Fst, Snd, Hol, erase} = __webpack_require__(/*! ./fm-core.js */ \"../formality/src/fm-core.js\");\nconst {Net, Pointer, Numeric, addr_of, slot_of, type_of, numb_of, ptrn_eq, ptrn_st, NOD, OP1, OP2, NUM, ITE, PTR, FOR} = __webpack_require__(/*! ./fm-net.js */ \"../formality/src/fm-net.js\");\n\nconst op_kind = {\n   0 : \".+.\"   , \".+.\"   : 0 ,\n   1 : \".-.\"   , \".-.\"   : 1 ,\n   2 : \".*.\"   , \".*.\"   : 2 ,\n   3 : \"./.\"   , \"./.\"   : 3 ,\n   4 : \".%.\"   , \".%.\"   : 4 ,\n   5 : \".**.\"  , \".**.\"  : 5 ,\n   6 : \".&.\"   , \".&.\"   : 6 ,\n   7 : \".|.\"   , \".|.\"   : 7 ,\n   8 : \".^.\"   , \".^.\"   : 8 ,\n   9 : \".~.\"   , \".~.\"   : 9 ,\n  10 : \".>>>.\" , \".>>>.\" : 10 ,\n  11 : \".<<.\"  , \".<<.\"  : 11 ,\n  12 : \".>.\"   , \".>.\"   : 12 ,\n  13 : \".<.\"   , \".<.\"   : 13 ,\n  14 : \".==.\"  , \".==.\"  : 14 ,\n};\n\nconst compile = (term, defs = {}) => {\n  const ref_ptrs = {};\n  const build_net = (term, net, var_ptrs, level) => {\n    const get_var = (ptrn) => {\n      if (type_of(ptrn) === NUM) {\n        return ptrn;\n      } else {\n        if (ptrn_eq(net.enter_port(ptrn), ptrn)) {\n          return ptrn;\n        } else {\n          var dups_ptrn = net.enter_port(ptrn);\n          var dup_addr = net.alloc_node(NOD, level_of[ptrn_st(ptrn)] + 1);\n          net.link_ports(Pointer(dup_addr, 0), ptrn);\n          net.link_ports(Pointer(dup_addr, 1), dups_ptrn);\n          return Pointer(dup_addr, 2);\n        }\n      }\n    };\n    switch (term[0]) {\n      case \"Dup\":\n        var expr_ptr = build_net(term[1].expr, net, var_ptrs, level);\n        level_of[ptrn_st(expr_ptr)] = level;\n        var_ptrs.push(expr_ptr);\n        var body_ptr = build_net(term[1].body, net, var_ptrs, level);\n        var_ptrs.pop();\n        return body_ptr;\n      case \"Put\":\n        var expr_ptr = build_net(term[1].expr, net, var_ptrs, level + 1);\n        return expr_ptr;\n      case \"Lam\":\n        var lam_addr = net.alloc_node(NOD, 0);\n        net.link_ports(Pointer(lam_addr, 1), Pointer(lam_addr, 1));\n        level_of[ptrn_st(Pointer(lam_addr, 1))] = level;\n        var_ptrs.push(Pointer(lam_addr, 1));\n        var body_ptr = build_net(term[1].body, net, var_ptrs, level);\n        var_ptrs.pop();\n        net.link_ports(Pointer(lam_addr, 2), body_ptr);\n        return Pointer(lam_addr, 0);\n      case \"App\":\n        var app_addr = net.alloc_node(NOD, 0);\n        var func_ptr = build_net(term[1].func, net, var_ptrs, level);\n        net.link_ports(Pointer(app_addr, 0), func_ptr);\n        var argm_ptr = build_net(term[1].argm, net, var_ptrs, level);\n        net.link_ports(Pointer(app_addr, 1), argm_ptr)\n        return Pointer(app_addr, 2);\n      case \"Val\":\n        return Numeric(term[1].numb);\n      case \"Op1\":\n        var op1_addr = net.alloc_node(OP1, op_kind[term[1].func]);\n        net.link_ports(Numeric(term[1].num1[1].numb), Pointer(op1_addr, 1));\n        var num0_ptr = build_net(term[1].num0, net, var_ptrs, level);\n        net.link_ports(num0_ptr, Pointer(op1_addr, 0));\n        return Pointer(op1_addr, 2);\n      case \"Op2\":\n        var op2_addr = net.alloc_node(OP2, op_kind[term[1].func]);\n        var num0_ptr = build_net(term[1].num0, net, var_ptrs, level);\n        net.link_ports(Pointer(op2_addr, 1), num0_ptr);\n        var num1_ptr = build_net(term[1].num1, net, var_ptrs, level);\n        net.link_ports(Pointer(op2_addr, 0), num1_ptr);\n        return Pointer(op2_addr, 2);\n      case \"Par\":\n        var par_addr = net.alloc_node(NOD, 0xFFFF);\n        var val0_ptr = build_net(term[1].val0, net, var_ptrs, level);\n        net.link_ports(Pointer(par_addr, 1), val0_ptr);\n        var val1_ptr = build_net(term[1].val1, net, var_ptrs, level);\n        net.link_ports(Pointer(par_addr, 2), val1_ptr);\n        return Pointer(par_addr, 0);\n      case \"Fst\":\n        var fst_addr = net.alloc_node(NOD, 0xFFFF);\n        var pair_ptr = build_net(term[1].pair, net, var_ptrs, level);\n        net.link_ports(Pointer(fst_addr, 0), pair_ptr);\n        net.link_ports(Pointer(fst_addr, 2), Pointer(fst_addr, 2));\n        return Pointer(fst_addr, 1);\n      case \"Snd\":\n        var snd_addr = net.alloc_node(NOD, 0xFFFF);\n        var pair_ptr = build_net(term[1].pair, net, var_ptrs, level);\n        net.link_ports(Pointer(snd_addr, 0), pair_ptr);\n        net.link_ports(Pointer(snd_addr, 1), Pointer(snd_addr, 1));\n        return Pointer(snd_addr, 2);\n      case \"Prj\":\n        var prj_addr = net.alloc_node(NOD, 0xFFFF);\n        level_of[ptrn_st(Pointer(prj_addr, 1))] = level;\n        level_of[ptrn_st(Pointer(prj_addr, 2))] = level;\n        var pair_ptr = build_net(term[1].pair, net, var_ptrs, level);\n        var_ptrs.push(Pointer(prj_addr, 1));\n        var_ptrs.push(Pointer(prj_addr, 2));\n        var body_ptr = build_net(term[1].body, net, var_ptrs, level);\n        var_ptrs.pop();\n        var_ptrs.pop();\n        net.link_ports(Pointer(prj_addr, 0), pair_ptr);\n        return body_ptr;\n      case \"Ite\":\n        var ite_addr = net.alloc_node(ITE, 0xFFFF);\n        var cond_ptr = build_net(term[1].cond, net, var_ptrs, level);\n        net.link_ports(Pointer(ite_addr, 0), cond_ptr);\n        var pair_ptr = build_net(term[1].pair, net, var_ptrs, level);\n        net.link_ports(Pointer(ite_addr, 1), pair_ptr);\n        return Pointer(ite_addr, 2);\n      case \"Cpy\":\n        var numb_ptr = build_net(term[1].numb, net, var_ptrs, level);\n        level_of[ptrn_st(numb_ptr)] = 0xFFFE;\n        var_ptrs.push(numb_ptr);\n        var body_ptr = build_net(term[1].body, net, var_ptrs, level);\n        var_ptrs.pop();\n        return body_ptr;\n      case \"Log\":\n        return build_net(term[1].expr, net, var_ptrs, level);\n      case \"Var\":\n        return get_var(var_ptrs[var_ptrs.length - term[1].index - 1]);\n      case \"Hol\":\n        throw \"[ERROR]\\nCan't compile a hole.\";\n      case \"Utv\":\n        throw \"[ERROR]\\nCan't compile an unrestricted term.\";\n      case \"Ref\":\n        var ref_ptrn = ref_ptrs[term[1].name];\n        // First time seeing this ref\n        if (!ref_ptrn) {\n          // Create a dup node for it and recurse\n          var dup_addr = net.alloc_node(NOD, 0xFFFD);\n          var ref_ptrn = Pointer(dup_addr, 1);\n          ref_ptrs[term[1].name] = ref_ptrn;\n          var dref = erase(defs[term[1].name]);\n          var dref_ptr = build_net(dref, net, var_ptrs, level);\n          net.link_ports(Pointer(dup_addr, 0), dref_ptr);\n          return Pointer(dup_addr, 2);\n        // Already created the dup node for this ref\n        } else {\n          // First use: just connect to the port 1 of the dup node\n          if (ptrn_eq(net.enter_port(ref_ptrn), ref_ptrn)) {\n            return ref_ptrn;\n          // Other uses: extend with another dup node and connect\n          } else {\n            var dups_ptrn = net.enter_port(ref_ptrn);\n            var dup_addr = net.alloc_node(NOD, 0xFFFD);\n            net.link_ports(Pointer(dup_addr, 0), ref_ptrn);\n            net.link_ports(Pointer(dup_addr, 1), dups_ptrn);\n            return Pointer(dup_addr, 2);\n          }\n        }\n      default:\n        return build_net(Lam(\"\", null, Var(0), false), net, var_ptrs, level);\n    }\n  };\n  var level_of = {};\n  var net = new Net();\n  var root_addr = net.alloc_node(NOD, 0);\n  var term_ptr = build_net(term, net, [], 0);\n  net.link_ports(Pointer(root_addr, 0), Pointer(root_addr, 2));\n  net.link_ports(Pointer(root_addr, 1), term_ptr);\n  // Removes invalid redexes. They can be created by the\n  // compiler when duplicating variables more than once.\n  net.redex = net.redex.filter((a_addr) => {\n    var b_ptrn = net.enter_port(Pointer(a_addr, 0));\n    if (type_of(b_ptrn) !== NUM) {\n      var b_addr = addr_of(b_ptrn);\n      var a_p0 = Pointer(a_addr, 0);\n      var b_p0 = Pointer(b_addr, 0);\n      var a_ok = ptrn_eq(net.enter_port(a_p0), b_p0);\n      var b_ok = ptrn_eq(net.enter_port(b_p0), a_p0);\n      return a_ok && b_ok;\n    } else {\n      return true;\n    }\n  });\n  // Optimization: if a ref is only used once, remove the unecessary dup node\n  for (var name in ref_ptrs) {\n    var ref_ptrn = ref_ptrs[name];\n    if (ptrn_eq(net.enter_port(ref_ptrn), ref_ptrn)) {\n      var dup_addr = addr_of(ref_ptrn);\n      var ref_ptrn = net.enter_port(Pointer(dup_addr, 0));\n      var loc_ptrn = net.enter_port(Pointer(dup_addr, 2));\n      net.link_ports(ref_ptrn, loc_ptrn);\n      net.free_node(dup_addr);\n    }\n  }\n  return net;\n};\n\nconst decompile = (net) => {\n  const build_term = (net, ptrn, var_ptrs, dup_exit) => {\n    if (type_of(ptrn) === NUM) {\n      return Val(numb_of(ptrn));\n    } else {\n      var addr = addr_of(ptrn);\n      var type = net.type_of(addr);\n      var kind = net.kind_of(addr);\n      if (type === NOD) {\n        if (kind === 0) {\n          switch (slot_of(ptrn)) {\n            case 0:\n              var_ptrs.push(Pointer(addr, 1));\n              var body = build_term(net, net.enter_port(Pointer(addr, 2)), var_ptrs, dup_exit);\n              var_ptrs.pop();\n              return Lam(\"x\" + var_ptrs.length, null, body, false);\n            case 1:\n              for (var index = 0; index < var_ptrs.length; ++index) {\n                if (ptrn_eq(var_ptrs[var_ptrs.length - index - 1], ptrn)) {\n                  return Var(index);\n                }\n              }\n            case 2:\n              var argm = build_term(net, net.enter_port(Pointer(addr, 1)), var_ptrs, dup_exit);\n              var func = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n              return App(func, argm, false);\n          }\n        } else if (kind === 0xFFFF) {\n          switch (slot_of(ptrn)) {\n            case 0:\n              var val0 = build_term(net, net.enter_port(Pointer(addr, 1)), var_ptrs, dup_exit);\n              var val1 = build_term(net, net.enter_port(Pointer(addr, 2)), var_ptrs, dup_exit);\n              return Par(val0, val1);\n            case 1:\n              var pair = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n              return Fst(pair);\n            case 2:\n              var pair = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n              return Snd(pair);\n          }\n        } else {\n          switch (slot_of(ptrn)) {\n            case 0:\n              var exit = dup_exit.pop();\n              var term = build_term(net, net.enter_port(Pointer(addr, exit)), var_ptrs, dup_exit);\n              dup_exit.push(exit);\n              return term;\n            default:\n              dup_exit.push(slot_of(ptrn));\n              var term = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n              dup_exit.pop();\n              return term;\n          }\n        }\n      } else if (type === OP1) {\n        var num0 = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n        var num1 = Val(numb_of(net.enter_port(Pointer(addr, 1))));\n        return Op1(op_kind[kind], num0, num1);\n      } else if (type === OP2) {\n        var num0 = build_term(net, net.enter_port(Pointer(addr, 1)), var_ptrs, dup_exit);\n        var num1 = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n        return Op2(op_kind[kind], num0, num1);\n      } else if (type === ITE) {\n        var cond = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n        var pair = build_term(net, net.enter_port(Pointer(addr, 1)), var_ptrs, dup_exit);\n        return Ite(cond, pair);\n      }\n    }\n  };\n  return build_term(net, net.enter_port(Pointer(0, 1)), [], []);\n};\n\nconst norm_with_stats = (term, defs = {}, lazy = true) => {\n  var net = compile(term, defs);\n  var stats = lazy ? net.reduce_lazy() : net.reduce();\n  var norm = decompile(net);\n  return {norm, stats};\n};\n\nconst norm = (term, defs, lazy) => {\n  return norm_with_stats(term, defs, lazy).norm;\n};\n\nmodule.exports = {compile, decompile, norm_with_stats, norm};\n\n\n//# sourceURL=webpack:///../formality/src/fm-to-net.js?");

/***/ }),

/***/ "../formality/src/forall.js":
/*!**********************************!*\
  !*** ../formality/src/forall.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {// This module is responsible for loading and publishing files from the Forall repository\n// For now this is using the deprecated moonad.org/api repository, but will be updated to the newer\n// Forall API once the service is deployed and ready to be used.\n//\n// This also exports a few \"loader decorators\" to enable caching depending on the environment\n\nconst xhr = __webpack_require__(/*! xhr-request-promise */ \"../formality/node_modules/xhr-request-promise/index.js\");\nconst version = __webpack_require__(/*! ./../package.json */ \"../formality/package.json\").version;\n\n// Load file related things only on node\nconst {fs, path, async_read_file, async_write_file} = (\n  typeof window === \"object\"\n  ? () => ({})\n  : () => {\n    const {promisify} = eval('require(\"util\")');\n    const path = eval('require(\"path\")');\n    const fs = eval('require(\"fs\")');\n\n    const async_read_file = promisify(fs.readFile)\n    const async_write_file = promisify(fs.writeFile)\n\n    return {fs, path, async_read_file, async_write_file}\n  }\n)()\n\n// load_file receives the name of the file and returns the code asyncronously\n//\n// load_file(file: String) -> Promise<String>\nconst load_file = (file) => post(\"load_file\", {file});\n\n// save_file receives the file name without the version, the code, and returns, asynchronously\n// the saved global file name (with the version after the @).\n//\n// save_file(file: String, code: String) -> Promise<String>\nconst save_file = (file, code) => post(\"save_file\", {file, code});\n\n// Receives a file name and returns a list of parents for that file\n//\n// load_file_parents(file: String) -> Promise<String[]>\nconst load_file_parents = (file) => post(\"load_file_parents\", {file});\n\n// Transforms a file loader in order to add local file system cache.\n// It receives the file loader and optionally, a path to save the files\n//\n// with_file_system_cache(\n//   loader: String -> Promise<String>,\n//   cache_dir_path?: String\n// ) -> Promise<String>\nconst with_file_system_cache = (loader, cache_dir_path) => async (file) => {\n  const dir_path = cache_dir_path || get_default_fs_cache_path();\n  setup_cache_dir(dir_path);\n  const cached_file_path = path.join(dir_path, file + \".fm\");\n  if(fs.existsSync(cached_file_path)) {\n    return await async_read_file(cached_file_path, \"utf8\");\n  }\n\n  const code = await loader(file)\n\n  await async_write_file(cached_file_path, code, \"utf8\");\n\n  return code;\n}\n\n// Transforms a file loader in order to add local files for development.\n// It receives the file loader and optionally, a path where the files are\n//\n// with_local_files(\n//   loader: String -> Promise<String>,\n//   local_dir_path?: String\n// ) -> Promise<String>\nconst with_local_files = (loader, local_dir_path) => async (file) => {\n  const dir_path = local_dir_path || process.cwd();\n  const local_file_path = path.join(dir_path, file + \".fm\");\n  const has_local_file = fs.existsSync(local_file_path);\n\n  if(has_local_file) {\n    return await async_read_file(local_file_path, \"utf8\");\n  }\n\n  return await loader(file);\n}\n\n// Transforms a file loader in order to add local file system cache.\n// It receives the file loader and optionally, a prefix for the local storage key\n// defaulting to `FPM@${FM_VERSION}/`\n//\n// with_local_storage_cache(\n//   loader: String -> Promise<String>,\n//   prefix?: String\n// ) -> Promise<String>\nconst with_local_storage_cache = (loader, prefix = `FPM@${version}/`) => async (file) => {\n  const cached = window.localStorage.getItem(prefix + file)\n  if(cached) {\n    return cached;\n  }\n\n  const code = await loader(file)\n\n  window.localStorage.setItem(prefix + file, code)\n\n  return code;\n}\n\nmodule.exports = {\n  load_file_parents,\n  load_file,\n  save_file,\n  with_file_system_cache,\n  with_local_files,\n  with_local_storage_cache,\n}\n\n// Utils not exported\n\nconst get_default_fs_cache_path = () => path.join(process.cwd(), \"fm_modules\");\n\nconst setup_cache_dir = (cache_dir_path) => {\n  var version_file_path = path.join(cache_dir_path, \"version\");\n  var has_cache_dir = fs.existsSync(cache_dir_path);\n  var has_version_file = has_cache_dir && fs.existsSync(version_file_path);\n  var correct_version = has_version_file && fs.readFileSync(version_file_path, \"utf8\") === version;\n  if (!has_cache_dir || !has_version_file || !correct_version) {\n    if (has_cache_dir) {\n      var files = fs.readdirSync(cache_dir_path);\n      for (var i = 0; i < files.length; ++i) {\n        fs.unlinkSync(path.join(cache_dir_path, files[i]));\n      }\n      fs.rmdirSync(cache_dir_path);\n    }\n    fs.mkdirSync(cache_dir_path);\n    fs.writeFileSync(version_file_path, version);\n  }\n}\n\n// The current API is just a simple RPC, so this function helps a lot\nconst post = (func, body) => {\n  return xhr(\"http://moonad.org/api/\" + func,\n    { method: \"POST\"\n    , json: true\n    , body})\n    .then(res => {\n      if (res[0] === \"ok\") {\n        return res[1];\n      } else {\n        throw res[1];\n      }\n    });\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../inferno-hello-world/node_modules/process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///../formality/src/forall.js?");

/***/ }),

/***/ "./node_modules/preact/dist/preact.module.js":
/*!***************************************************!*\
  !*** ./node_modules/preact/dist/preact.module.js ***!
  \***************************************************/
/*! exports provided: render, hydrate, createElement, h, Fragment, createRef, isValidElement, Component, cloneElement, createContext, toChildArray, _unmount, options */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return H; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hydrate\", function() { return I; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createElement\", function() { return h; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return h; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Fragment\", function() { return d; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createRef\", function() { return p; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isValidElement\", function() { return l; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Component\", function() { return y; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cloneElement\", function() { return L; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createContext\", function() { return M; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toChildArray\", function() { return b; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_unmount\", function() { return A; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"options\", function() { return n; });\nvar n,l,u,i,t,o,f,r={},e=[],c=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|^--/i;function s(n,l){for(var u in l)n[u]=l[u];return n}function a(n){var l=n.parentNode;l&&l.removeChild(n)}function h(n,l,u){var i,t,o,f,r=arguments;if(l=s({},l),arguments.length>3)for(u=[u],i=3;i<arguments.length;i++)u.push(r[i]);if(null!=u&&(l.children=u),null!=n&&null!=n.defaultProps)for(t in n.defaultProps)void 0===l[t]&&(l[t]=n.defaultProps[t]);return f=l.key,null!=(o=l.ref)&&delete l.ref,null!=f&&delete l.key,v(n,l,f,o)}function v(l,u,i,t){var o={type:l,props:u,key:i,ref:t,__k:null,__p:null,__b:0,__e:null,__d:null,__c:null,constructor:void 0};return n.vnode&&n.vnode(o),o}function p(){return{}}function d(n){return n.children}function y(n,l){this.props=n,this.context=l}function m(n,l){if(null==l)return n.__p?m(n.__p,n.__p.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return\"function\"==typeof n.type?m(n):null}function w(n){var l,u;if(null!=(n=n.__p)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return w(n)}}function g(l){(!l.__d&&(l.__d=!0)&&1===u.push(l)||t!==n.debounceRendering)&&(t=n.debounceRendering,(n.debounceRendering||i)(k))}function k(){var n,l,i,t,o,f,r;for(u.sort(function(n,l){return l.__v.__b-n.__v.__b});n=u.pop();)n.__d&&(i=void 0,t=void 0,f=(o=(l=n).__v).__e,(r=l.__P)&&(i=[],t=T(r,o,s({},o),l.__n,void 0!==r.ownerSVGElement,null,i,null==f?m(o):f),$(i,o),t!=f&&w(o)))}function _(n,l,u,i,t,o,f,c,s){var h,v,p,d,y,w,g,k=u&&u.__k||e,_=k.length;if(c==r&&(c=null!=o?o[0]:_?m(u,0):null),h=0,l.__k=b(l.__k,function(u){if(null!=u){if(u.__p=l,u.__b=l.__b+1,null===(p=k[h])||p&&u.key==p.key&&u.type===p.type)k[h]=void 0;else for(v=0;v<_;v++){if((p=k[v])&&u.key==p.key&&u.type===p.type){k[v]=void 0;break}p=null}if(d=T(n,u,p=p||r,i,t,o,f,c,s),(v=u.ref)&&p.ref!=v&&(g||(g=[])).push(v,u.__c||d,u),null!=d){if(null==w&&(w=d),null!=u.__d)d=u.__d,u.__d=null;else if(o==p||d!=c||null==d.parentNode){n:if(null==c||c.parentNode!==n)n.appendChild(d);else{for(y=c,v=0;(y=y.nextSibling)&&v<_;v+=2)if(y==d)break n;n.insertBefore(d,c)}\"option\"==l.type&&(n.value=\"\")}c=d.nextSibling,\"function\"==typeof l.type&&(l.__d=d)}}return h++,u}),l.__e=w,null!=o&&\"function\"!=typeof l.type)for(h=o.length;h--;)null!=o[h]&&a(o[h]);for(h=_;h--;)null!=k[h]&&A(k[h],k[h]);if(g)for(h=0;h<g.length;h++)z(g[h],g[++h],g[++h])}function b(n,l,u){if(null==u&&(u=[]),null==n||\"boolean\"==typeof n)l&&u.push(l(null));else if(Array.isArray(n))for(var i=0;i<n.length;i++)b(n[i],l,u);else u.push(l?l(\"string\"==typeof n||\"number\"==typeof n?v(null,n,null,null):null!=n.__e||null!=n.__c?v(n.type,n.props,n.key,null):n):n);return u}function x(n,l,u,i,t){var o;for(o in u)o in l||P(n,o,null,u[o],i);for(o in l)t&&\"function\"!=typeof l[o]||\"value\"===o||\"checked\"===o||u[o]===l[o]||P(n,o,l[o],u[o],i)}function C(n,l,u){\"-\"===l[0]?n.setProperty(l,u):n[l]=\"number\"==typeof u&&!1===c.test(l)?u+\"px\":null==u?\"\":u}function P(n,l,u,i,t){var o,f,r,e,c;if(\"key\"===(l=t?\"className\"===l?\"class\":l:\"class\"===l?\"className\":l)||\"children\"===l);else if(\"style\"===l)if(o=n.style,\"string\"==typeof u)o.cssText=u;else{if(\"string\"==typeof i&&(o.cssText=\"\",i=null),i)for(f in i)u&&f in u||C(o,f,\"\");if(u)for(r in u)i&&u[r]===i[r]||C(o,r,u[r])}else\"o\"===l[0]&&\"n\"===l[1]?(e=l!==(l=l.replace(/Capture$/,\"\")),c=l.toLowerCase(),l=(c in n?c:l).slice(2),u?(i||n.addEventListener(l,N,e),(n.l||(n.l={}))[l]=u):n.removeEventListener(l,N,e)):\"list\"!==l&&\"tagName\"!==l&&\"form\"!==l&&!t&&l in n?n[l]=null==u?\"\":u:\"function\"!=typeof u&&\"dangerouslySetInnerHTML\"!==l&&(l!==(l=l.replace(/^xlink:?/,\"\"))?null==u||!1===u?n.removeAttributeNS(\"http://www.w3.org/1999/xlink\",l.toLowerCase()):n.setAttributeNS(\"http://www.w3.org/1999/xlink\",l.toLowerCase(),u):null==u||!1===u?n.removeAttribute(l):n.setAttribute(l,u))}function N(l){this.l[l.type](n.event?n.event(l):l)}function T(l,u,i,t,o,f,r,e,c){var a,h,v,p,m,w,g,k,x,C,P=u.type;if(void 0!==u.constructor)return null;(a=n.__b)&&a(u);try{n:if(\"function\"==typeof P){if(k=u.props,x=(a=P.contextType)&&t[a.__c],C=a?x?x.props.value:a.__p:t,i.__c?g=(h=u.__c=i.__c).__p=h.__E:(\"prototype\"in P&&P.prototype.render?u.__c=h=new P(k,C):(u.__c=h=new y(k,C),h.constructor=P,h.render=D),x&&x.sub(h),h.props=k,h.state||(h.state={}),h.context=C,h.__n=t,v=h.__d=!0,h.__h=[]),null==h.__s&&(h.__s=h.state),null!=P.getDerivedStateFromProps&&s(h.__s==h.state?h.__s=s({},h.__s):h.__s,P.getDerivedStateFromProps(k,h.__s)),p=h.props,m=h.state,v)null==P.getDerivedStateFromProps&&null!=h.componentWillMount&&h.componentWillMount(),null!=h.componentDidMount&&h.__h.push(h.componentDidMount);else{if(null==P.getDerivedStateFromProps&&null==h.__e&&null!=h.componentWillReceiveProps&&h.componentWillReceiveProps(k,C),!h.__e&&null!=h.shouldComponentUpdate&&!1===h.shouldComponentUpdate(k,h.__s,C)){for(h.props=k,h.state=h.__s,h.__d=!1,h.__v=u,u.__e=i.__e,u.__k=i.__k,a=0;a<u.__k.length;a++)u.__k[a]&&(u.__k[a].__p=u);break n}null!=h.componentWillUpdate&&h.componentWillUpdate(k,h.__s,C),null!=h.componentDidUpdate&&h.__h.push(function(){h.componentDidUpdate(p,m,w)})}h.context=C,h.props=k,h.state=h.__s,(a=n.__r)&&a(u),h.__d=!1,h.__v=u,h.__P=l,a=h.render(h.props,h.state,h.context),u.__k=b(null!=a&&a.type==d&&null==a.key?a.props.children:a),null!=h.getChildContext&&(t=s(s({},t),h.getChildContext())),v||null==h.getSnapshotBeforeUpdate||(w=h.getSnapshotBeforeUpdate(p,m)),_(l,u,i,t,o,f,r,e,c),h.base=u.__e,h.__h.length&&r.push(h),g&&(h.__E=h.__p=null),h.__e=null}else u.__e=j(i.__e,u,i,t,o,f,r,c);(a=n.diffed)&&a(u)}catch(l){n.__e(l,u,i)}return u.__e}function $(l,u){n.__c&&n.__c(u,l),l.some(function(u){try{l=u.__h,u.__h=[],l.some(function(n){n.call(u)})}catch(l){n.__e(l,u.__v)}})}function j(n,l,u,i,t,o,f,c){var s,a,h,v,p,d=u.props,y=l.props;if(t=\"svg\"===l.type||t,null==n&&null!=o)for(s=0;s<o.length;s++)if(null!=(a=o[s])&&(null===l.type?3===a.nodeType:a.localName===l.type)){n=a,o[s]=null;break}if(null==n){if(null===l.type)return document.createTextNode(y);n=t?document.createElementNS(\"http://www.w3.org/2000/svg\",l.type):document.createElement(l.type),o=null}if(null===l.type)null!=o&&(o[o.indexOf(n)]=null),d!==y&&(n.data=y);else if(l!==u){if(null!=o&&(o=e.slice.call(n.childNodes)),h=(d=u.props||r).dangerouslySetInnerHTML,v=y.dangerouslySetInnerHTML,!c){if(d===r)for(d={},p=0;p<n.attributes.length;p++)d[n.attributes[p].name]=n.attributes[p].value;(v||h)&&(v&&h&&v.__html==h.__html||(n.innerHTML=v&&v.__html||\"\"))}x(n,y,d,t,c),l.__k=l.props.children,v||_(n,l,u,i,\"foreignObject\"!==l.type&&t,o,f,r,c),c||(\"value\"in y&&void 0!==y.value&&y.value!==n.value&&(n.value=null==y.value?\"\":y.value),\"checked\"in y&&void 0!==y.checked&&y.checked!==n.checked&&(n.checked=y.checked))}return n}function z(l,u,i){try{\"function\"==typeof l?l(u):l.current=u}catch(l){n.__e(l,i)}}function A(l,u,i){var t,o,f;if(n.unmount&&n.unmount(l),(t=l.ref)&&z(t,null,u),i||\"function\"==typeof l.type||(i=null!=(o=l.__e)),l.__e=l.__d=null,null!=(t=l.__c)){if(t.componentWillUnmount)try{t.componentWillUnmount()}catch(l){n.__e(l,u)}t.base=t.__P=null}if(t=l.__k)for(f=0;f<t.length;f++)t[f]&&A(t[f],u,i);null!=o&&a(o)}function D(n,l,u){return this.constructor(n,u)}function H(l,u,i){var t,f,c;n.__p&&n.__p(l,u),f=(t=i===o)?null:i&&i.__k||u.__k,l=h(d,null,[l]),c=[],T(u,(t?u:i||u).__k=l,f||r,r,void 0!==u.ownerSVGElement,i&&!t?[i]:f?null:e.slice.call(u.childNodes),c,i||r,t),$(c,l)}function I(n,l){H(n,l,o)}function L(n,l){return l=s(s({},n.props),l),arguments.length>2&&(l.children=e.slice.call(arguments,2)),v(n.type,l,l.key||n.key,l.ref||n.ref)}function M(n){var l={},u={__c:\"__cC\"+f++,__p:n,Consumer:function(n,l){return n.children(l)},Provider:function(n){var i,t=this;return this.getChildContext||(i=[],this.getChildContext=function(){return l[u.__c]=t,l},this.shouldComponentUpdate=function(l){n.value!==l.value&&i.some(function(n){n.context=l.value,g(n)})},this.sub=function(n){i.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){i.splice(i.indexOf(n),1),l&&l.call(n)}}),n.children}};return u.Consumer.contextType=u,u}n={},l=function(n){return null!=n&&void 0===n.constructor},y.prototype.setState=function(n,l){var u=this.__s!==this.state&&this.__s||(this.__s=s({},this.state));(\"function\"!=typeof n||(n=n(u,this.props)))&&s(u,n),null!=n&&this.__v&&(this.__e=!1,l&&this.__h.push(l),g(this))},y.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),g(this))},y.prototype.render=d,u=[],i=\"function\"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,t=n.debounceRendering,n.__e=function(n,l,u){for(var i;l=l.__p;)if((i=l.__c)&&!i.__p)try{if(i.constructor&&null!=i.constructor.getDerivedStateFromError)i.setState(i.constructor.getDerivedStateFromError(n));else{if(null==i.componentDidCatch)continue;i.componentDidCatch(n)}return g(i.__E=i)}catch(l){n=l}throw n},o=r,f=0;\n//# sourceMappingURL=preact.module.js.map\n\n\n//# sourceURL=webpack:///./node_modules/preact/dist/preact.module.js?");

/***/ }),

/***/ "./node_modules/preact/hooks/dist/hooks.module.js":
/*!********************************************************!*\
  !*** ./node_modules/preact/hooks/dist/hooks.module.js ***!
  \********************************************************/
/*! exports provided: useState, useReducer, useEffect, useLayoutEffect, useRef, useImperativeHandle, useMemo, useCallback, useContext, useDebugValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useState\", function() { return a; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useReducer\", function() { return v; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useEffect\", function() { return m; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useLayoutEffect\", function() { return p; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useRef\", function() { return l; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useImperativeHandle\", function() { return d; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useMemo\", function() { return s; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useCallback\", function() { return y; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useContext\", function() { return T; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useDebugValue\", function() { return w; });\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ \"./node_modules/preact/dist/preact.module.js\");\nvar t,r,u=[],i=preact__WEBPACK_IMPORTED_MODULE_0__[\"options\"].__r;preact__WEBPACK_IMPORTED_MODULE_0__[\"options\"].__r=function(n){i&&i(n),t=0,(r=n.__c).__H&&(r.__H.t.forEach(g),r.__H.t.forEach(q),r.__H.t=[])};var o=preact__WEBPACK_IMPORTED_MODULE_0__[\"options\"].diffed;preact__WEBPACK_IMPORTED_MODULE_0__[\"options\"].diffed=function(n){o&&o(n);var t=n.__c;if(t){var r=t.__H;r&&r.t.length&&A(u.push(t))}};var f=preact__WEBPACK_IMPORTED_MODULE_0__[\"options\"].__c;preact__WEBPACK_IMPORTED_MODULE_0__[\"options\"].__c=function(n,t){t.some(function(n){n.__h.forEach(g),n.__h=n.__h.filter(function(n){return!n.u||q(n)})}),f&&f(n,t)};var c=preact__WEBPACK_IMPORTED_MODULE_0__[\"options\"].unmount;function e(t){preact__WEBPACK_IMPORTED_MODULE_0__[\"options\"].__h&&preact__WEBPACK_IMPORTED_MODULE_0__[\"options\"].__h(r);var u=r.__H||(r.__H={i:[],t:[]});return t>=u.i.length&&u.i.push({}),u.i[t]}function a(n){return v(E,n)}function v(n,u,i){var o=e(t++);return o.__c||(o.__c=r,o.u=[i?i(u):E(void 0,u),function(t){var r=n(o.u[0],t);o.u[0]!==r&&(o.u[0]=r,o.__c.setState({}))}]),o.u}function m(n,u){var i=e(t++);x(i.o,u)&&(i.u=n,i.o=u,r.__H.t.push(i))}function p(n,u){var i=e(t++);x(i.o,u)&&(i.u=n,i.o=u,r.__h.push(i))}function l(n){return s(function(){return{current:n}},[])}function d(n,t,r){p(function(){\"function\"==typeof n?n(t()):n&&(n.current=t())},null==r?r:r.concat(n))}function s(n,r){var u=e(t++);return x(u.o,r)?(u.o=r,u.v=n,u.u=n()):u.u}function y(n,t){return s(function(){return n},t)}function T(n){var u=r.context[n.__c];if(!u)return n.__p;var i=e(t++);return null==i.u&&(i.u=!0,u.sub(r)),u.props.value}function w(t,r){preact__WEBPACK_IMPORTED_MODULE_0__[\"options\"].useDebugValue&&preact__WEBPACK_IMPORTED_MODULE_0__[\"options\"].useDebugValue(r?r(t):t)}preact__WEBPACK_IMPORTED_MODULE_0__[\"options\"].unmount=function(n){c&&c(n);var t=n.__c;if(t){var r=t.__H;r&&r.i.forEach(function(n){return n.m&&n.m()})}};var A=function(){};function F(){u.some(function(n){n.__P&&(n.__H.t.forEach(g),n.__H.t.forEach(q),n.__H.t=[])}),u=[]}if(\"undefined\"!=typeof window){var _=preact__WEBPACK_IMPORTED_MODULE_0__[\"options\"].requestAnimationFrame;A=function(t){1!==t&&_===preact__WEBPACK_IMPORTED_MODULE_0__[\"options\"].requestAnimationFrame||((_=preact__WEBPACK_IMPORTED_MODULE_0__[\"options\"].requestAnimationFrame)||function(n){var t=function(){clearTimeout(r),cancelAnimationFrame(u),setTimeout(n)},r=setTimeout(t,100),u=requestAnimationFrame(t)})(F)}}function g(n){n.m&&n.m()}function q(n){var t=n.u();\"function\"==typeof t&&(n.m=t)}function x(n,t){return!n||t.some(function(t,r){return t!==n[r]})}function E(n,t){return\"function\"==typeof t?t(n):t}\n//# sourceMappingURL=hooks.module.js.map\n\n\n//# sourceURL=webpack:///./node_modules/preact/hooks/dist/hooks.module.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const href = window.location.href;\nconst qidx = href.indexOf(\"?\");\nconst file = qidx !== -1 ? href.slice(qidx+1) : \"DemoApp@0\";\nconst app_file = \"App@7\";\n\nconst {h, render} = __webpack_require__(/*! preact */ \"./node_modules/preact/dist/preact.module.js\");\nconst {useState, useEffect} = __webpack_require__(/*! preact/hooks */ \"./node_modules/preact/hooks/dist/hooks.module.js\");\nconst fm = __webpack_require__(/*! ./../../formality */ \"../formality/src/fm-lib.js\");\n\nconst FormalityApp = (props) => {\n  var [state, setState] = useState(null);\n  var [funcs, setFuncs] = useState(null);\n\n  var demo_state, demo_render, demo_update;\n\n  useEffect(async () => {\n    var loader = fm.forall.with_local_storage_cache(fm.forall.load_file);\n    var {defs} = await fm.lang.parse(\"main\", `import ${props.file}`, true, loader);\n\n    var get_state = fm.to_js.compile(fm.lang.erase(defs[`${app_file}/get_state`]), {defs});\n    var get_render = fm.to_js.compile(fm.lang.erase(defs[`${app_file}/get_render`]), {defs});\n    var get_update = fm.to_js.compile(fm.lang.erase(defs[`${app_file}/get_update`]), {defs});\n    var doc_to_json = fm.to_js.compile(fm.lang.erase(defs[`${app_file}/doc_to_json`]), {defs});\n    //console.log(\"get_state\", get_state);\n\n    var app = fm.to_js.compile(fm.lang.erase(defs[`${props.file}/main`]), {defs});\n    //console.log(\"app\", app);\n    var app_state = get_state(app);\n    //console.log(\"app_state\", app_state);\n    var app_render = get_render(app);\n    //console.log(\"app_render\", app_render);\n    var app_update = get_update(app);\n    //console.log(\"app_update\", app_update);\n\n    setFuncs({state: app_state, render: app_render, update: app_update, doc_to_json});\n    setState(app_state);\n  }, [0]);\n\n  const onClick = () => {\n    setState(funcs.update(null, state));\n  };\n\n  if (state === null || funcs === null) {\n    return h(\"div\", {}, \"(loading app...)\");\n  } else {\n    //console.log(\"... state: \", state);\n    //console.log(\"... native_render: \", funcs.render(state));\n    //console.log(\"... native_json: \", funcs.doc_to_json(funcs.render(state)));\n    //console.log(\"... json: \", fm.json.native_from(funcs.doc_to_json(funcs.render(state))));\n    return h(\"div\", {onClick}, render_doc(fm.json.native_from(funcs.doc_to_json(funcs.render(state)))));\n  }\n};\n\nconst render_doc = (doc) => {\n  switch (doc.type) {\n    case \"text\": return h(\"span\", {}, doc.value);\n    case \"numb\": return h(\"span\", {}, String(doc.value));\n    case \"many\": return doc.value.map(x => h(\"div\", {}, render_doc(x)));\n  }\n};\n\nwindow.onload = () => {\n  render(h(FormalityApp, {file}), document.getElementById(\"main\"));\n};\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ })

/******/ });